{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Java Learning Platform","text":"<p>Welcome to the Java Learning Platform - a comprehensive resource for Java developers covering core concepts to advanced microservices architecture.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":""},{"location":"#java-core","title":"Java Core","text":"<ul> <li>Basic Concepts</li> <li>Basics</li> <li>Object-Oriented Programming</li> <li>Collections Framework</li> <li>Exceptions</li> <li>Exception Handling</li> <li>Multithreading</li> <li>Concurrency</li> <li>File I/O</li> <li>Lambda Expressions and Streams</li> <li>Generics</li> <li>Memory Management</li> <li>Testing</li> </ul>"},{"location":"#spring-boot","title":"Spring Boot","text":"<ul> <li>Core Concepts</li> <li>Starter</li> <li>REST API</li> <li>Data Access</li> <li>Security</li> <li>Testing</li> <li>Actuator</li> <li>Deployment</li> <li>AOP</li> <li>Configuration</li> <li>Spring Data JPA</li> <li>Spring Data MongoDB</li> <li>Kafka Integration</li> <li>Spring AI</li> <li>Best Practices</li> </ul>"},{"location":"#microservices","title":"Microservices","text":"<ul> <li>Basics</li> <li>Communication Patterns</li> <li>Service Discovery</li> <li>Resilience Patterns</li> <li>API Gateway</li> <li>Security</li> <li>Monitoring</li> <li>Deployment</li> <li>Testing</li> <li>Best Practices</li> <li>Saga Pattern</li> <li>CQRS Pattern</li> <li>Platform Architecture</li> </ul>"},{"location":"#kubernetes","title":"Kubernetes","text":"<ul> <li>Basics</li> <li>Deployment</li> <li>Services</li> <li>Config &amp; Secrets</li> <li>Storage</li> <li>Scaling</li> <li>Monitoring</li> <li>Security</li> <li>Networking</li> <li>Troubleshooting</li> <li>Best Practices</li> </ul>"},{"location":"#design-patterns","title":"Design Patterns","text":"<ul> <li>Principles</li> <li>Best Practices</li> <li>J2EE Patterns</li> <li>Behavioral Patterns</li> <li>Structural Patterns</li> <li>Creational Patterns</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Deployment Guide</li> <li>Search Implementation</li> </ul>"},{"location":"#how-to-use-this-platform","title":"How to Use This Platform","text":"<p>This learning platform is designed to be flexible and accommodate different learning styles:</p>"},{"location":"#structured-learning-path","title":"Structured Learning Path","text":"<p>For those new to Java or wanting a comprehensive education, we recommend following the sections in order: 1. Java Core 2. Spring Boot 3. Design Patterns 4. Microservices 5. Kubernetes</p>"},{"location":"#reference-guide","title":"Reference Guide","text":"<p>Experienced developers can use this platform as a reference by directly accessing specific topics of interest.</p>"},{"location":"#practical-application","title":"Practical Application","text":"<p>Each section includes practical examples and exercises to reinforce learning.</p>"},{"location":"#search-documentation","title":"Search Documentation","text":"<p>To find specific topics quickly, use the search functionality available at the top of each page.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to improve this learning platform. See our contribution guidelines for more details.</p>"},{"location":"#deployment","title":"Deployment","text":"<p>This documentation is deployed using GitHub Pages. For details on the deployment process, see our deployment guide.</p>"},{"location":"#feedback","title":"Feedback","text":"<p>Your feedback is valuable to us! Please submit your comments and suggestions through our feedback form or open an issue in our GitHub repository.</p>"},{"location":"#license","title":"License","text":"<p>This learning platform is licensed under the MIT License. </p>"},{"location":"CONTRIBUTING/","title":"Contributing to Java Learning Platform","text":"<p>Thank you for your interest in contributing to the Java Learning Platform! This document provides guidelines and instructions for contributing to our documentation.</p>"},{"location":"CONTRIBUTING/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are several ways you can contribute to the Java Learning Platform:</p> <ol> <li>Content Improvements: Correct errors, clarify explanations, or expand on existing content</li> <li>New Content: Add new topics or sections that are missing</li> <li>Code Examples: Improve or add new code examples</li> <li>Technical Improvements: Enhance the platform's functionality, search capabilities, etc.</li> <li>Feedback: Provide feedback on existing content</li> </ol>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<ul> <li>GitHub account</li> <li>Git installed locally</li> <li>Basic knowledge of Markdown</li> <li>Python 3.8+ for local testing</li> </ul>"},{"location":"CONTRIBUTING/#setup-process","title":"Setup Process","text":"<ol> <li>Fork the repository</li> <li>Clone your fork locally    <pre><code>git clone https://github.com/yourusername/java-learning.git\ncd java-learning\n</code></pre></li> <li>Install dependencies    <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Run the documentation locally    <pre><code>mkdocs serve\n</code></pre></li> </ol>"},{"location":"CONTRIBUTING/#contribution-workflow","title":"Contribution Workflow","text":"<ol> <li>Create a new branch for your work    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></li> <li>Make your changes</li> <li>Test your changes locally using <code>mkdocs serve</code></li> <li>Commit your changes with a clear commit message    <pre><code>git commit -am \"Add explanation of Spring Boot profiles\"\n</code></pre></li> <li>Push your changes to your fork    <pre><code>git push origin feature/your-feature-name\n</code></pre></li> <li>Create a pull request from your fork to the main repository</li> </ol>"},{"location":"CONTRIBUTING/#content-guidelines","title":"Content Guidelines","text":""},{"location":"CONTRIBUTING/#style-and-formatting","title":"Style and Formatting","text":"<ul> <li>Use clear, concise language</li> <li>Follow the existing document structure</li> <li>Use proper Markdown formatting</li> <li>Include code examples where appropriate</li> <li>Ensure code examples are correct and runnable</li> </ul>"},{"location":"CONTRIBUTING/#adding-new-content","title":"Adding New Content","text":"<ol> <li>Create new Markdown files in the appropriate subdirectory</li> <li>Update the <code>nav</code> section in <code>mkdocs.yml</code> to include your new file</li> <li>Ensure your content includes:</li> <li>Clear introduction</li> <li>Well-structured content with proper headings</li> <li>Code examples where applicable</li> <li>References or further reading</li> </ol>"},{"location":"CONTRIBUTING/#review-process","title":"Review Process","text":"<p>All contributions go through the following review process:</p> <ol> <li>Initial review by maintainers</li> <li>Technical accuracy verification</li> <li>Style and formatting check</li> <li>Feedback and suggested changes</li> <li>Final approval and merge</li> </ol>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project adheres to a Code of Conduct. By participating, you are expected to uphold this code.</p>"},{"location":"CONTRIBUTING/#questions","title":"Questions?","text":"<p>If you have any questions or need help with the contribution process, please open an issue on GitHub or contact the maintainers directly.</p> <p>Thank you for contributing to the Java Learning Platform! </p>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2023 Your Organization</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>"},{"location":"deployment-guide/","title":"Macro Rendering Error","text":"<p>File: <code>deployment-guide.md</code></p> <p>UndefinedError: 'secrets' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mkdocs_macros/plugin.py\", line 527, in render\n    return md_template.render(**page_variables)\n           ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 86, in top-level template code\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\njinja2.exceptions.UndefinedError: 'secrets' is undefined\n</code></pre>"},{"location":"feedback/","title":"Feedback","text":"<p>We value your feedback on the Java Learning Platform. Your input helps us improve our content and user experience.</p>"},{"location":"feedback/#quick-feedback","title":"Quick Feedback","text":"<p>Was this documentation helpful to you?</p> \ud83d\udc4d Yes \ud83d\udc4e No"},{"location":"feedback/#detailed-feedback","title":"Detailed Feedback","text":"<p>Please let us know what we can improve:</p> Which section are you providing feedback on? Please select Java Core Spring Boot Microservices Kubernetes Design Patterns Overall Platform What type of feedback are you providing? Please select Technical error or correction Suggestion for improvement Missing content Positive feedback Question Other Please provide your feedback: Your email (optional, if you'd like us to follow up): Submit Feedback"},{"location":"feedback/#github-issues","title":"GitHub Issues","text":"<p>You can also provide feedback by opening an issue in our GitHub repository:</p> <p>  Report an issue </p> <p>Thank you for helping us improve the Java Learning Platform! </p>"},{"location":"search-implementation/","title":"Search Implementation for Java Learning Platform","text":""},{"location":"search-implementation/#overview","title":"Overview","text":"<p>This document details the implementation of the search functionality for the Java Learning Platform. An effective search system is crucial for users to quickly find relevant content across the extensive documentation.</p>"},{"location":"search-implementation/#search-requirements","title":"Search Requirements","text":"<ol> <li>Full-Text Search: Enable searching across all content of the documentation</li> <li>Relevance Ranking: Return results based on relevance to search query</li> <li>Fast Performance: Sub-second response times for search queries</li> <li>Filter Capabilities: Allow filtering by content category (Java, Spring Boot, etc.)</li> <li>Highlighting: Highlight matching terms in search results</li> <li>Suggestions: Provide search suggestions as users type</li> <li>Mobile Support: Fully functional on mobile devices</li> </ol>"},{"location":"search-implementation/#technical-implementation","title":"Technical Implementation","text":""},{"location":"search-implementation/#search-technology-stack","title":"Search Technology Stack","text":"<p>We've selected a combined approach using:</p> <ol> <li>MkDocs with Material Theme:</li> <li>Built-in search functionality based on lunr.js</li> <li> <p>Client-side search index generation</p> </li> <li> <p>Lunr.js Enhancements:</p> </li> <li>Customized tokenization for technical terms</li> <li>Boosting specific sections (titles, headings)</li> <li> <p>Stemming for improved matching</p> </li> <li> <p>Search UI Components:</p> </li> <li>Autocomplete dropdown</li> <li>Results preview with context</li> <li>Keyboard navigation support</li> </ol>"},{"location":"search-implementation/#search-index-configuration","title":"Search Index Configuration","text":"<pre><code># In mkdocs.yml\nplugins:\n  - search:\n      lang: en\n      separator: '[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&amp;[lg]t;'\n      min_search_length: 3\n      prebuild_index: true\n      indexing: 'full'\n</code></pre>"},{"location":"search-implementation/#custom-search-enhancements","title":"Custom Search Enhancements","text":"<ol> <li> <p>Technical Term Handling:    <pre><code>// Custom tokenizer to handle camelCase, code snippets, and technical terms\nfunction customTokenizer(input) {\n  // Handle camelCase\n  const camelCaseSplit = input.replace(/([a-z])([A-Z])/g, '$1 $2');\n\n  // Handle special technical terms\n  const technicalTerms = camelCaseSplit.replace(/(Spring Boot|Java EE|Kubernetes)/g, \n                                               (match) =&gt; `\"${match}\"`);\n\n  return lunr.tokenizer(technicalTerms);\n}\n</code></pre></p> </li> <li> <p>Field Boosting:    <pre><code>// Configure importance of different content sections\nconst searchIndex = lunr(function() {\n  this.ref('id');\n  this.field('title', { boost: 10 });\n  this.field('headings', { boost: 5 });\n  this.field('content', { boost: 1 });\n\n  // Use custom tokenizer\n  this.tokenizer = customTokenizer;\n\n  // Add documents to the index\n  documents.forEach(function(doc) {\n    this.add(doc);\n  }, this);\n});\n</code></pre></p> </li> </ol>"},{"location":"search-implementation/#search-results-interface","title":"Search Results Interface","text":"<p>The search UI includes:</p> <ol> <li>Search Box:</li> <li>Prominent placement in the navigation bar</li> <li>Keyboard shortcut: \"/\" (slash)</li> <li> <p>Placeholder text: \"Search documentation...\"</p> </li> <li> <p>Results Display:</p> </li> <li>Section categorization (Java, Spring Boot, etc.)</li> <li>Highlighted matching terms</li> <li>Context snippet showing surrounding content</li> <li> <p>Direct links to specific sections within pages</p> </li> <li> <p>No Results Handling:</p> </li> <li>Suggestions for related terms</li> <li>Links to main category pages</li> <li>Option to browse all documentation</li> </ol>"},{"location":"search-implementation/#example-search-flow","title":"Example Search Flow","text":"<ol> <li>User types \"spring dependency injection\"</li> <li>As they type, suggestions appear below the search box</li> <li>Upon pressing Enter or selecting a suggestion:</li> <li>Results are displayed in a modal/overlay</li> <li>Results are grouped by category (Spring Boot section appears first)</li> <li>Matching terms \"spring\", \"dependency\", and \"injection\" are highlighted</li> <li>Direct links to relevant sections are provided</li> </ol>"},{"location":"search-implementation/#mobile-experience","title":"Mobile Experience","text":"<p>The search functionality is optimized for mobile devices with:</p> <ol> <li>Touch-Friendly Interface:</li> <li>Larger hit areas for search results</li> <li> <p>Swipe gestures to dismiss results</p> </li> <li> <p>Responsive Design:</p> </li> <li>Full-screen search results on small screens</li> <li>Maintained context highlighting</li> <li>Optimized load times for mobile networks</li> </ol>"},{"location":"search-implementation/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Configure Base MkDocs Search:</li> <li>Set up lunr.js with the Material theme</li> <li> <p>Configure initial search settings in mkdocs.yml</p> </li> <li> <p>Customize Search Index:</p> </li> <li>Implement custom tokenizer for technical terms</li> <li>Configure field boosting for relevant sections</li> <li> <p>Add special handling for code blocks and examples</p> </li> <li> <p>Enhance Search UI:</p> </li> <li>Implement autocomplete functionality</li> <li>Design and implement results display</li> <li> <p>Add keyboard navigation support</p> </li> <li> <p>Optimize for Performance:</p> </li> <li>Pre-build search index during site generation</li> <li>Implement lazy loading of search resources</li> <li> <p>Compress search index for faster downloads</p> </li> <li> <p>Test and Iterate:</p> </li> <li>Test with real user queries</li> <li>Analyze search logs for common patterns</li> <li>Refine relevance ranking based on usage data</li> </ol>"},{"location":"search-implementation/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Index Size Management:</li> <li>Split index by major sections for large documentation</li> <li>Exclude code examples from main search index</li> <li> <p>Implement separate code-specific search</p> </li> <li> <p>Client-Side Optimization:</p> </li> <li>Minimize main thread blocking during search</li> <li>Use web workers for search processing</li> <li> <p>Implement debouncing for search input</p> </li> <li> <p>Progressive Enhancement:</p> </li> <li>Provide basic search functionality without JavaScript</li> <li>Enhance experience for modern browsers</li> <li>Fallback to category browsing when search is unavailable</li> </ol>"},{"location":"search-implementation/#monitoring-and-improvement","title":"Monitoring and Improvement","text":"<ol> <li>Search Analytics:</li> <li>Track common search terms</li> <li>Identify searches with no results</li> <li> <p>Monitor average search result position clicked</p> </li> <li> <p>Continuous Improvement:</p> </li> <li>Regular review of search logs</li> <li>Update content based on common searches</li> <li>Adjust boosting and relevance settings based on usage</li> </ol>"},{"location":"search-implementation/#future-enhancements","title":"Future Enhancements","text":"<ol> <li>Natural Language Processing:</li> <li>Implement NLP for more intelligent query understanding</li> <li>Add synonym support for technical terms</li> <li> <p>Integrate intent detection for complex queries</p> </li> <li> <p>Personalized Search:</p> </li> <li>Track user's reading history for context</li> <li>Adjust result ranking based on user's skill level</li> <li> <p>Suggest related content based on search patterns</p> </li> <li> <p>Voice Search:</p> </li> <li>Implement voice input for search queries</li> <li>Optimize for technical term recognition</li> <li>Provide voice response for search results</li> </ol>"},{"location":"search-implementation/#references","title":"References","text":"<ul> <li>MkDocs Search Documentation</li> <li>Lunr.js Documentation</li> <li>Material for MkDocs Search</li> <li>Web Search UI Patterns </li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/","title":"Behavioral Design Patterns","text":""},{"location":"design-patterns/design-patterns-behavioral/#overview","title":"Overview","text":"<p>Behavioral design patterns are concerned with algorithms and the assignment of responsibilities between objects. They characterize complex control flow that's difficult to follow at run-time. They shift your focus away from flow of control to let you concentrate just on the way objects are interconnected. This guide covers essential behavioral design patterns in Java, their implementation, use cases, advantages, and potential drawbacks.</p>"},{"location":"design-patterns/design-patterns-behavioral/#prerequisites","title":"Prerequisites","text":"<ul> <li>Solid understanding of Java programming</li> <li>Familiarity with object-oriented programming concepts</li> <li>Basic knowledge of SOLID principles</li> <li>Understanding of class inheritance and interfaces</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the purpose and benefits of behavioral design patterns</li> <li>Learn when and how to implement different behavioral patterns</li> <li>Recognize appropriate use cases for each pattern</li> <li>Implement behavioral patterns in Java applications</li> <li>Understand the trade-offs between different behavioral patterns</li> <li>Apply best practices when implementing behavioral patterns</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Behavioral Patterns</li> <li>Chain of Responsibility Pattern</li> <li>Command Pattern</li> <li>Interpreter Pattern</li> <li>Iterator Pattern</li> <li>Mediator Pattern</li> <li>Memento Pattern</li> <li>Observer Pattern</li> <li>State Pattern</li> <li>Strategy Pattern</li> <li>Template Method Pattern</li> <li>Visitor Pattern</li> <li>Best Practices</li> <li>Common Pitfalls</li> <li>Comparing Behavioral Patterns</li> </ol>"},{"location":"design-patterns/design-patterns-behavioral/#introduction-to-behavioral-patterns","title":"Introduction to Behavioral Patterns","text":"<p>Behavioral patterns focus on communication between objects, how they interact and distribute responsibility. They help make complex flows more manageable by organizing the responsibilities and interactions between classes and objects.</p>"},{"location":"design-patterns/design-patterns-behavioral/#why-use-behavioral-patterns","title":"Why Use Behavioral Patterns?","text":"<ol> <li>Flexibility: They allow changing behavior at runtime.</li> <li>Loose Coupling: They reduce dependencies between communicating objects.</li> <li>Responsibility Allocation: They define clear roles for objects when carrying out tasks.</li> <li>Encapsulation: They encapsulate algorithms and behaviors that can vary.</li> </ol>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-behavioral-patterns","title":"When to Use Behavioral Patterns","text":"<ul> <li>When you want to define how objects communicate with each other</li> <li>When you need to encapsulate algorithms and make them interchangeable</li> <li>When you want to separate the logic that varies from what stays the same</li> <li>When you need to define complex workflows and interactions</li> <li>When you want to implement communication mechanisms between objects </li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#chain-of-responsibility-pattern","title":"Chain of Responsibility Pattern","text":"<p>The Chain of Responsibility pattern creates a chain of receiver objects for a request. This pattern decouples sender and receiver of a request based on the type of request.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent","title":"Intent","text":"<ul> <li>Avoid coupling the sender of a request to its receiver</li> <li>Allow more than one object to handle a request</li> <li>Chain receiving objects and pass the request along the chain until an object handles it</li> <li>Dynamically modify the chain at runtime</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation","title":"Implementation","text":"<pre><code>// Handler interface\nabstract class Handler {\n    protected Handler successor;\n\n    public void setSuccessor(Handler successor) {\n        this.successor = successor;\n    }\n\n    public abstract void handleRequest(Request request);\n}\n\n// Request class\nclass Request {\n    private String type;\n    private String content;\n\n    public Request(String type, String content) {\n        this.type = type;\n        this.content = content;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}\n\n// Concrete handlers\nclass ConcreteHandler1 extends Handler {\n    @Override\n    public void handleRequest(Request request) {\n        if (\"type1\".equals(request.getType())) {\n            System.out.println(\"Handler 1 is handling the request: \" + request.getContent());\n        } else if (successor != null) {\n            successor.handleRequest(request);\n        } else {\n            System.out.println(\"Request cannot be handled\");\n        }\n    }\n}\n\nclass ConcreteHandler2 extends Handler {\n    @Override\n    public void handleRequest(Request request) {\n        if (\"type2\".equals(request.getType())) {\n            System.out.println(\"Handler 2 is handling the request: \" + request.getContent());\n        } else if (successor != null) {\n            successor.handleRequest(request);\n        } else {\n            System.out.println(\"Request cannot be handled\");\n        }\n    }\n}\n\nclass ConcreteHandler3 extends Handler {\n    @Override\n    public void handleRequest(Request request) {\n        if (\"type3\".equals(request.getType())) {\n            System.out.println(\"Handler 3 is handling the request: \" + request.getContent());\n        } else if (successor != null) {\n            successor.handleRequest(request);\n        } else {\n            System.out.println(\"Request cannot be handled\");\n        }\n    }\n}\n\n// Client code\nHandler h1 = new ConcreteHandler1();\nHandler h2 = new ConcreteHandler2();\nHandler h3 = new ConcreteHandler3();\n\n// Set up the chain\nh1.setSuccessor(h2);\nh2.setSuccessor(h3);\n\n// Send requests through the chain\nh1.handleRequest(new Request(\"type1\", \"Request 1\"));\nh1.handleRequest(new Request(\"type2\", \"Request 2\"));\nh1.handleRequest(new Request(\"type3\", \"Request 3\"));\nh1.handleRequest(new Request(\"type4\", \"Request 4\"));\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#logging-example","title":"Logging Example","text":"<pre><code>// Logging levels\nenum LogLevel {\n    INFO(1), DEBUG(2), ERROR(3);\n\n    private int level;\n\n    LogLevel(int level) {\n        this.level = level;\n    }\n\n    public int getLevel() {\n        return level;\n    }\n}\n\n// Logger interface\nabstract class Logger {\n    protected LogLevel level;\n    protected Logger nextLogger;\n\n    public Logger(LogLevel level) {\n        this.level = level;\n    }\n\n    public void setNextLogger(Logger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    public void logMessage(LogLevel level, String message) {\n        if (this.level.getLevel() &lt;= level.getLevel()) {\n            write(message);\n        }\n\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    protected abstract void write(String message);\n}\n\n// Concrete loggers\nclass ConsoleLogger extends Logger {\n    public ConsoleLogger(LogLevel level) {\n        super(level);\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"Console Logger: \" + message);\n    }\n}\n\nclass FileLogger extends Logger {\n    public FileLogger(LogLevel level) {\n        super(level);\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"File Logger: \" + message);\n    }\n}\n\nclass EmailLogger extends Logger {\n    public EmailLogger(LogLevel level) {\n        super(level);\n    }\n\n    @Override\n    protected void write(String message) {\n        System.out.println(\"Email Logger: \" + message);\n    }\n}\n\n// Usage\nLogger consoleLogger = new ConsoleLogger(LogLevel.INFO);\nLogger fileLogger = new FileLogger(LogLevel.DEBUG);\nLogger emailLogger = new EmailLogger(LogLevel.ERROR);\n\n// Set up the chain\nconsoleLogger.setNextLogger(fileLogger);\nfileLogger.setNextLogger(emailLogger);\n\n// Log messages\nSystem.out.println(\"--- Logging INFO ---\");\nconsoleLogger.logMessage(LogLevel.INFO, \"This is an information.\");\n\nSystem.out.println(\"--- Logging DEBUG ---\");\nconsoleLogger.logMessage(LogLevel.DEBUG, \"This is a debug information.\");\n\nSystem.out.println(\"--- Logging ERROR ---\");\nconsoleLogger.logMessage(LogLevel.ERROR, \"This is an error information.\");\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#approval-process-example","title":"Approval Process Example","text":"<pre><code>// Purchase request class\nclass PurchaseRequest {\n    private double amount;\n    private String purpose;\n\n    public PurchaseRequest(double amount, String purpose) {\n        this.amount = amount;\n        this.purpose = purpose;\n    }\n\n    public double getAmount() {\n        return amount;\n    }\n\n    public String getPurpose() {\n        return purpose;\n    }\n}\n\n// Approver interface\nabstract class Approver {\n    protected Approver successor;\n    protected String name;\n\n    public Approver(String name) {\n        this.name = name;\n    }\n\n    public void setSuccessor(Approver successor) {\n        this.successor = successor;\n    }\n\n    public abstract void processRequest(PurchaseRequest request);\n}\n\n// Concrete approvers\nclass Manager extends Approver {\n    private static final double APPROVAL_LIMIT = 1000.0;\n\n    public Manager(String name) {\n        super(name);\n    }\n\n    @Override\n    public void processRequest(PurchaseRequest request) {\n        if (request.getAmount() &lt;= APPROVAL_LIMIT) {\n            System.out.println(\"Manager \" + name + \" approved purchase request for $\" \n                              + request.getAmount() + \" for \" + request.getPurpose());\n        } else if (successor != null) {\n            System.out.println(\"Manager \" + name + \" forwards request to \" + successor.getClass().getSimpleName());\n            successor.processRequest(request);\n        } else {\n            System.out.println(\"Request cannot be approved\");\n        }\n    }\n}\n\nclass Director extends Approver {\n    private static final double APPROVAL_LIMIT = 5000.0;\n\n    public Director(String name) {\n        super(name);\n    }\n\n    @Override\n    public void processRequest(PurchaseRequest request) {\n        if (request.getAmount() &lt;= APPROVAL_LIMIT) {\n            System.out.println(\"Director \" + name + \" approved purchase request for $\" \n                              + request.getAmount() + \" for \" + request.getPurpose());\n        } else if (successor != null) {\n            System.out.println(\"Director \" + name + \" forwards request to \" + successor.getClass().getSimpleName());\n            successor.processRequest(request);\n        } else {\n            System.out.println(\"Request cannot be approved\");\n        }\n    }\n}\n\nclass VicePresident extends Approver {\n    private static final double APPROVAL_LIMIT = 10000.0;\n\n    public VicePresident(String name) {\n        super(name);\n    }\n\n    @Override\n    public void processRequest(PurchaseRequest request) {\n        if (request.getAmount() &lt;= APPROVAL_LIMIT) {\n            System.out.println(\"Vice President \" + name + \" approved purchase request for $\" \n                              + request.getAmount() + \" for \" + request.getPurpose());\n        } else if (successor != null) {\n            System.out.println(\"Vice President \" + name + \" forwards request to \" + successor.getClass().getSimpleName());\n            successor.processRequest(request);\n        } else {\n            System.out.println(\"Request cannot be approved\");\n        }\n    }\n}\n\nclass President extends Approver {\n    private static final double APPROVAL_LIMIT = 50000.0;\n\n    public President(String name) {\n        super(name);\n    }\n\n    @Override\n    public void processRequest(PurchaseRequest request) {\n        if (request.getAmount() &lt;= APPROVAL_LIMIT) {\n            System.out.println(\"President \" + name + \" approved purchase request for $\" \n                              + request.getAmount() + \" for \" + request.getPurpose());\n        } else if (successor != null) {\n            System.out.println(\"President \" + name + \" forwards request to \" + successor.getClass().getSimpleName());\n            successor.processRequest(request);\n        } else {\n            System.out.println(\"Request cannot be approved - requires board approval\");\n        }\n    }\n}\n\n// Usage\nApprover manager = new Manager(\"John\");\nApprover director = new Director(\"Sarah\");\nApprover vicePresident = new VicePresident(\"Emily\");\nApprover president = new President(\"Michael\");\n\n// Set up the chain\nmanager.setSuccessor(director);\ndirector.setSuccessor(vicePresident);\nvicePresident.setSuccessor(president);\n\n// Process purchase requests\nmanager.processRequest(new PurchaseRequest(800.0, \"Office supplies\"));\nmanager.processRequest(new PurchaseRequest(2500.0, \"Conference room equipment\"));\nmanager.processRequest(new PurchaseRequest(7000.0, \"Company retreat\"));\nmanager.processRequest(new PurchaseRequest(25000.0, \"New server infrastructure\"));\nmanager.processRequest(new PurchaseRequest(100000.0, \"New office building\"));\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-chain-of-responsibility-pattern","title":"When to Use the Chain of Responsibility Pattern","text":"<ul> <li>When more than one object may handle a request, and the handler isn't known in advance</li> <li>When you want to issue a request to one of several objects without specifying the receiver explicitly</li> <li>When the set of objects that can handle a request should be specified dynamically</li> <li>When you want to avoid hardwiring the request sender to its receiver</li> <li>When the handler can be determined at runtime</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages","title":"Advantages","text":"<ul> <li>Reduces coupling between the sender of a request and its receivers</li> <li>Increases flexibility in assigning responsibilities to objects</li> <li>Allows adding or removing responsibilities dynamically at runtime</li> <li>Follows the Single Responsibility Principle - each handler performs a single task</li> <li>Follows the Open/Closed Principle - new handlers can be added without breaking existing code</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages","title":"Disadvantages","text":"<ul> <li>No guarantee that a request will be handled - it might fall off the end of the chain</li> <li>Can be hard to observe and debug the runtime characteristics</li> <li>May lead to poor performance if the chain is too long</li> <li>Can lead to circular references if not implemented carefully</li> <li>May result in sender having no feedback if a request wasn't handled </li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#command-pattern","title":"Command Pattern","text":"<p>The Command pattern encapsulates a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_1","title":"Intent","text":"<ul> <li>Encapsulate a request as an object</li> <li>Allow the parameterization of clients with different requests</li> <li>Allow saving requests in a queue</li> <li>Support undoable operations</li> <li>Structure a system around high-level operations built on primitive operations</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_1","title":"Implementation","text":"<pre><code>// Command interface\ninterface Command {\n    void execute();\n}\n\n// Receiver class\nclass Light {\n    private boolean isOn = false;\n\n    public void turnOn() {\n        isOn = true;\n        System.out.println(\"Light is ON\");\n    }\n\n    public void turnOff() {\n        isOn = false;\n        System.out.println(\"Light is OFF\");\n    }\n}\n\n// Concrete commands\nclass LightOnCommand implements Command {\n    private Light light;\n\n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.turnOn();\n    }\n}\n\nclass LightOffCommand implements Command {\n    private Light light;\n\n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.turnOff();\n    }\n}\n\n// Invoker\nclass RemoteControl {\n    private Command command;\n\n    public void setCommand(Command command) {\n        this.command = command;\n    }\n\n    public void pressButton() {\n        command.execute();\n    }\n}\n\n// Client code\nLight livingRoomLight = new Light();\n\nCommand livingRoomLightOn = new LightOnCommand(livingRoomLight);\nCommand livingRoomLightOff = new LightOffCommand(livingRoomLight);\n\nRemoteControl remote = new RemoteControl();\n\n// Turn on the light\nremote.setCommand(livingRoomLightOn);\nremote.pressButton();\n\n// Turn off the light\nremote.setCommand(livingRoomLightOff);\nremote.pressButton();\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#undoable-commands","title":"Undoable Commands","text":"<pre><code>// Command interface with undo capability\ninterface UndoableCommand {\n    void execute();\n    void undo();\n}\n\n// Receiver class\nclass TV {\n    private boolean isOn = false;\n    private int volume = 0;\n\n    public void turnOn() {\n        isOn = true;\n        System.out.println(\"TV is ON\");\n    }\n\n    public void turnOff() {\n        isOn = false;\n        System.out.println(\"TV is OFF\");\n    }\n\n    public void setVolume(int volume) {\n        this.volume = volume;\n        System.out.println(\"TV volume set to \" + volume);\n    }\n\n    public int getVolume() {\n        return volume;\n    }\n\n    public boolean isOn() {\n        return isOn;\n    }\n}\n\n// Concrete commands\nclass TVOnCommand implements UndoableCommand {\n    private TV tv;\n    private boolean previousState;\n\n    public TVOnCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    @Override\n    public void execute() {\n        previousState = tv.isOn();\n        tv.turnOn();\n    }\n\n    @Override\n    public void undo() {\n        if (!previousState) {\n            tv.turnOff();\n        }\n    }\n}\n\nclass TVOffCommand implements UndoableCommand {\n    private TV tv;\n    private boolean previousState;\n\n    public TVOffCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    @Override\n    public void execute() {\n        previousState = tv.isOn();\n        tv.turnOff();\n    }\n\n    @Override\n    public void undo() {\n        if (previousState) {\n            tv.turnOn();\n        }\n    }\n}\n\nclass TVVolumeCommand implements UndoableCommand {\n    private TV tv;\n    private int previousVolume;\n    private int newVolume;\n\n    public TVVolumeCommand(TV tv, int newVolume) {\n        this.tv = tv;\n        this.newVolume = newVolume;\n    }\n\n    @Override\n    public void execute() {\n        previousVolume = tv.getVolume();\n        tv.setVolume(newVolume);\n    }\n\n    @Override\n    public void undo() {\n        tv.setVolume(previousVolume);\n    }\n}\n\n// Remote control with undo capability\nclass RemoteControlWithUndo {\n    private UndoableCommand command;\n    private UndoableCommand lastCommand;\n\n    public void setCommand(UndoableCommand command) {\n        this.command = command;\n    }\n\n    public void pressButton() {\n        command.execute();\n        lastCommand = command;\n    }\n\n    public void pressUndoButton() {\n        if (lastCommand != null) {\n            lastCommand.undo();\n        }\n    }\n}\n\n// Usage\nTV tv = new TV();\n\nUndoableCommand tvOn = new TVOnCommand(tv);\nUndoableCommand tvOff = new TVOffCommand(tv);\nUndoableCommand tvVolume10 = new TVVolumeCommand(tv, 10);\nUndoableCommand tvVolume20 = new TVVolumeCommand(tv, 20);\n\nRemoteControlWithUndo remote = new RemoteControlWithUndo();\n\n// Turn on the TV\nremote.setCommand(tvOn);\nremote.pressButton();\n\n// Change volume to 10\nremote.setCommand(tvVolume10);\nremote.pressButton();\n\n// Change volume to 20\nremote.setCommand(tvVolume20);\nremote.pressButton();\n\n// Undo volume change (back to 10)\nremote.pressUndoButton();\n\n// Turn off the TV\nremote.setCommand(tvOff);\nremote.pressButton();\n\n// Undo turning off (back to on)\nremote.pressUndoButton();\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#macro-commands","title":"Macro Commands","text":"<pre><code>// Command interface\ninterface Command {\n    void execute();\n}\n\n// Receiver classes\nclass Light {\n    private String location;\n\n    public Light(String location) {\n        this.location = location;\n    }\n\n    public void turnOn() {\n        System.out.println(location + \" light is ON\");\n    }\n\n    public void turnOff() {\n        System.out.println(location + \" light is OFF\");\n    }\n}\n\nclass Stereo {\n    private String location;\n\n    public Stereo(String location) {\n        this.location = location;\n    }\n\n    public void on() {\n        System.out.println(location + \" stereo is ON\");\n    }\n\n    public void off() {\n        System.out.println(location + \" stereo is OFF\");\n    }\n\n    public void setCD() {\n        System.out.println(location + \" stereo is set to CD mode\");\n    }\n\n    public void setVolume(int volume) {\n        System.out.println(location + \" stereo volume is set to \" + volume);\n    }\n}\n\n// Concrete commands\nclass LightOnCommand implements Command {\n    private Light light;\n\n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.turnOn();\n    }\n}\n\nclass LightOffCommand implements Command {\n    private Light light;\n\n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.turnOff();\n    }\n}\n\nclass StereoOnWithCDCommand implements Command {\n    private Stereo stereo;\n\n    public StereoOnWithCDCommand(Stereo stereo) {\n        this.stereo = stereo;\n    }\n\n    @Override\n    public void execute() {\n        stereo.on();\n        stereo.setCD();\n        stereo.setVolume(11);\n    }\n}\n\nclass StereoOffCommand implements Command {\n    private Stereo stereo;\n\n    public StereoOffCommand(Stereo stereo) {\n        this.stereo = stereo;\n    }\n\n    @Override\n    public void execute() {\n        stereo.off();\n    }\n}\n\n// Macro command\nclass MacroCommand implements Command {\n    private Command[] commands;\n\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n\n    @Override\n    public void execute() {\n        for (Command command : commands) {\n            command.execute();\n        }\n    }\n}\n\n// Invoker\nclass RemoteControl {\n    private Command[] onCommands;\n    private Command[] offCommands;\n\n    public RemoteControl() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i &lt; 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n    }\n\n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n\n    public void onButtonPushed(int slot) {\n        onCommands[slot].execute();\n    }\n\n    public void offButtonPushed(int slot) {\n        offCommands[slot].execute();\n    }\n\n    public String toString() {\n        StringBuffer stringBuff = new StringBuffer();\n        stringBuff.append(\"\\n------ Remote Control -------\\n\");\n        for (int i = 0; i &lt; onCommands.length; i++) {\n            stringBuff.append(\"[slot \" + i + \"] \" + onCommands[i].getClass().getName()\n                + \"    \" + offCommands[i].getClass().getName() + \"\\n\");\n        }\n        return stringBuff.toString();\n    }\n}\n\n// NoCommand - Null Object Pattern to avoid null checks\nclass NoCommand implements Command {\n    @Override\n    public void execute() {\n        // Do nothing\n    }\n}\n\n// Client code\nRemoteControl remoteControl = new RemoteControl();\n\nLight livingRoomLight = new Light(\"Living Room\");\nLight kitchenLight = new Light(\"Kitchen\");\nStereo stereo = new Stereo(\"Living Room\");\n\nLightOnCommand livingRoomLightOn = new LightOnCommand(livingRoomLight);\nLightOffCommand livingRoomLightOff = new LightOffCommand(livingRoomLight);\nLightOnCommand kitchenLightOn = new LightOnCommand(kitchenLight);\nLightOffCommand kitchenLightOff = new LightOffCommand(kitchenLight);\n\nStereoOnWithCDCommand stereoOnWithCD = new StereoOnWithCDCommand(stereo);\nStereoOffCommand stereoOff = new StereoOffCommand(stereo);\n\n// Set individual commands\nremoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);\nremoteControl.setCommand(1, kitchenLightOn, kitchenLightOff);\nremoteControl.setCommand(2, stereoOnWithCD, stereoOff);\n\n// Create macro commands for \"Party Mode\" and \"Party's Over\"\nCommand[] partyOn = { livingRoomLightOn, kitchenLightOn, stereoOnWithCD };\nCommand[] partyOff = { livingRoomLightOff, kitchenLightOff, stereoOff };\n\nMacroCommand partyOnMacro = new MacroCommand(partyOn);\nMacroCommand partyOffMacro = new MacroCommand(partyOff);\n\n// Set macro commands\nremoteControl.setCommand(3, partyOnMacro, partyOffMacro);\n\nSystem.out.println(remoteControl);\n\n// Using individual commands\nSystem.out.println(\"--- Pushing individual buttons ---\");\nremoteControl.onButtonPushed(0);  // Living room light on\nremoteControl.offButtonPushed(0); // Living room light off\nremoteControl.onButtonPushed(1);  // Kitchen light on\nremoteControl.offButtonPushed(1); // Kitchen light off\nremoteControl.onButtonPushed(2);  // Stereo on with CD\nremoteControl.offButtonPushed(2); // Stereo off\n\n// Using macro commands\nSystem.out.println(\"--- Pushing macro buttons ---\");\nSystem.out.println(\"--- Party mode ON ---\");\nremoteControl.onButtonPushed(3);  // All party devices on\nSystem.out.println(\"--- Party mode OFF ---\");\nremoteControl.offButtonPushed(3); // All party devices off\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#command-queue-and-logging","title":"Command Queue and Logging","text":"<pre><code>// Command interface\ninterface Command {\n    void execute();\n    String getName();\n}\n\n// Receiver class\nclass DatabaseOperations {\n    public void insert(String data) {\n        System.out.println(\"Inserting data: \" + data);\n    }\n\n    public void update(String data) {\n        System.out.println(\"Updating data: \" + data);\n    }\n\n    public void delete(String data) {\n        System.out.println(\"Deleting data: \" + data);\n    }\n}\n\n// Concrete commands\nclass InsertCommand implements Command {\n    private DatabaseOperations database;\n    private String data;\n\n    public InsertCommand(DatabaseOperations database, String data) {\n        this.database = database;\n        this.data = data;\n    }\n\n    @Override\n    public void execute() {\n        database.insert(data);\n    }\n\n    @Override\n    public String getName() {\n        return \"Insert Command\";\n    }\n}\n\nclass UpdateCommand implements Command {\n    private DatabaseOperations database;\n    private String data;\n\n    public UpdateCommand(DatabaseOperations database, String data) {\n        this.database = database;\n        this.data = data;\n    }\n\n    @Override\n    public void execute() {\n        database.update(data);\n    }\n\n    @Override\n    public String getName() {\n        return \"Update Command\";\n    }\n}\n\nclass DeleteCommand implements Command {\n    private DatabaseOperations database;\n    private String data;\n\n    public DeleteCommand(DatabaseOperations database, String data) {\n        this.database = database;\n        this.data = data;\n    }\n\n    @Override\n    public void execute() {\n        database.delete(data);\n    }\n\n    @Override\n    public String getName() {\n        return \"Delete Command\";\n    }\n}\n\n// Command Queue\nclass CommandQueue {\n    private Queue&lt;Command&gt; queue = new LinkedList&lt;&gt;();\n    private List&lt;String&gt; commandLog = new ArrayList&lt;&gt;();\n\n    public void addCommand(Command command) {\n        queue.add(command);\n        commandLog.add(\"Command added to queue: \" + command.getName());\n    }\n\n    public void processCommands() {\n        Command command;\n        while ((command = queue.poll()) != null) {\n            commandLog.add(\"Executing command: \" + command.getName());\n            command.execute();\n        }\n    }\n\n    public void printCommandLog() {\n        System.out.println(\"=== Command Log ===\");\n        for (String log : commandLog) {\n            System.out.println(log);\n        }\n        System.out.println(\"===================\");\n    }\n}\n\n// Usage\nDatabaseOperations database = new DatabaseOperations();\nCommandQueue commandQueue = new CommandQueue();\n\n// Create commands\nCommand insertCmd = new InsertCommand(database, \"User{id=1, name='John'}\");\nCommand updateCmd = new UpdateCommand(database, \"User{id=1, name='John Doe'}\");\nCommand deleteCmd = new DeleteCommand(database, \"User{id=1}\");\n\n// Queue commands\ncommandQueue.addCommand(insertCmd);\ncommandQueue.addCommand(updateCmd);\ncommandQueue.addCommand(deleteCmd);\n\n// Process all commands\ncommandQueue.processCommands();\n\n// Print command log\ncommandQueue.printCommandLog();\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-command-pattern","title":"When to Use the Command Pattern","text":"<ul> <li>When you want to parameterize objects with operations</li> <li>When you want to queue, specify, or execute requests at different times</li> <li>When you want to support undoable operations</li> <li>When you want to structure a system around high-level operations built on primitive operations</li> <li>When you need to implement callbacks</li> <li>When you want to create a history of commands executed</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_1","title":"Advantages","text":"<ul> <li>Decouples the object that invokes the operation from the one that knows how to perform it</li> <li>Allows creating composite commands (macros)</li> <li>Makes it easy to add new commands without changing existing code</li> <li>Supports undo/redo operations</li> <li>Allows storing command history for logging and debugging</li> <li>Enables deferred execution of commands</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>Increases the number of classes for each individual command</li> <li>May lead to an excessive number of command classes</li> <li>Complicates the code if there are many commands with complex execution logic</li> <li>Not suitable for simple operations where the command pattern overhead is not justified</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#interpreter-pattern","title":"Interpreter Pattern","text":"<p>The Interpreter pattern is used to define a grammatical representation of a language. It's used to interpret sentences in the language.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_2","title":"Intent","text":"<ul> <li>Define a grammatical representation of a language</li> <li>Interpret sentences in the language</li> <li>Structure a system around a language</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_2","title":"Implementation","text":"<pre><code>// Expression interface\ninterface Expression {\n    boolean interpret(String context);\n}\n\n// Concrete expressions\nclass TerminalExpression implements Expression {\n    private String data;\n\n    public TerminalExpression(String data) {\n        this.data = data;\n    }\n\n    @Override\n    public boolean interpret(String context) {\n        return context.contains(data);\n    }\n}\n\nclass OrExpression implements Expression {\n    private Expression expr1;\n    private Expression expr2;\n\n    public OrExpression(Expression expr1, Expression expr2) {\n        this.expr1 = expr1;\n        this.expr2 = expr2;\n    }\n\n    @Override\n    public boolean interpret(String context) {\n        return expr1.interpret(context) || expr2.interpret(context);\n    }\n}\n\nclass AndExpression implements Expression {\n    private Expression expr1;\n    private Expression expr2;\n\n    public AndExpression(Expression expr1, Expression expr2) {\n        this.expr1 = expr1;\n        this.expr2 = expr2;\n    }\n\n    @Override\n    public boolean interpret(String context) {\n        return expr1.interpret(context) &amp;&amp; expr2.interpret(context);\n    }\n}\n\n// Usage\nExpression isMale = getMaleExpression();\nExpression isMarriedWoman = getMarriedWomanExpression();\n\nSystem.out.println(\"John is male? \" + isMale.interpret(\"John\"));\nSystem.out.println(\"Julie is a married woman? \" + isMarriedWoman.interpret(\"Married Julie\"));\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-interpreter-pattern","title":"When to Use the Interpreter Pattern","text":"<ul> <li>When you want to define a grammar and interpret sentences in the language</li> <li>When you want to structure a system around a language</li> <li>When you want to implement a domain-specific language</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_2","title":"Advantages","text":"<ul> <li>Increases flexibility in adding new expressions</li> <li>Increases flexibility in adding new types of expressions</li> <li>Increases flexibility in adding new types of interpreters</li> <li>Increases flexibility in adding new types of clients</li> <li>Increases flexibility in adding new types of expressions</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_2","title":"Disadvantages","text":"<ul> <li>Increases the number of classes for each individual expression</li> <li>May lead to an excessive number of expression classes</li> <li>Complicates the code if there are many expressions with complex execution logic</li> <li>Not suitable for simple operations where the interpreter pattern overhead is not justified</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#iterator-pattern","title":"Iterator Pattern","text":"<p>The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_3","title":"Intent","text":"<ul> <li>Provide a way to access elements of a collection sequentially without exposing the underlying representation</li> <li>Allow traversing different collections in a standard way</li> <li>Separate the collection's traversal mechanism from its implementation</li> <li>Enable multiple traversals of the same collection simultaneously</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_3","title":"Implementation","text":"<pre><code>import java.util.ArrayList;\nimport java.util.List;\n\n// Iterator interface\ninterface Iterator&lt;T&gt; {\n    boolean hasNext();\n    T next();\n}\n\n// Collection interface\ninterface Collection&lt;T&gt; {\n    Iterator&lt;T&gt; createIterator();\n}\n\n// Concrete Iterator\nclass ConcreteIterator&lt;T&gt; implements Iterator&lt;T&gt; {\n    private List&lt;T&gt; items;\n    private int position = 0;\n\n    public ConcreteIterator(List&lt;T&gt; items) {\n        this.items = items;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return position &lt; items.size();\n    }\n\n    @Override\n    public T next() {\n        if (!hasNext()) {\n            return null;\n        }\n        return items.get(position++);\n    }\n}\n\n// Concrete Collection\nclass ConcreteCollection&lt;T&gt; implements Collection&lt;T&gt; {\n    private List&lt;T&gt; items = new ArrayList&lt;&gt;();\n\n    public void addItem(T item) {\n        items.add(item);\n    }\n\n    @Override\n    public Iterator&lt;T&gt; createIterator() {\n        return new ConcreteIterator&lt;&gt;(items);\n    }\n}\n\n// Client code\nCollection&lt;String&gt; collection = new ConcreteCollection&lt;&gt;();\ncollection.addItem(\"Item 1\");\ncollection.addItem(\"Item 2\");\ncollection.addItem(\"Item 3\");\n\nIterator&lt;String&gt; iterator = collection.createIterator();\nwhile (iterator.hasNext()) {\n    String item = iterator.next();\n    System.out.println(item);\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#custom-collection-example","title":"Custom Collection Example","text":"<pre><code>// Book class\nclass Book {\n    private String title;\n    private String author;\n\n    public Book(String title, String author) {\n        this.title = title;\n        this.author = author;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book: \" + title + \" by \" + author;\n    }\n}\n\n// Iterator interface\ninterface BookIterator {\n    boolean hasNext();\n    Book next();\n}\n\n// Collection interface\ninterface BookCollection {\n    BookIterator createIterator();\n}\n\n// Concrete collection - Library\nclass Library implements BookCollection {\n    private Book[] books;\n\n    public Library(Book[] books) {\n        this.books = books;\n    }\n\n    @Override\n    public BookIterator createIterator() {\n        return new LibraryIterator(books);\n    }\n\n    // Concrete iterator\n    private class LibraryIterator implements BookIterator {\n        private Book[] books;\n        private int position = 0;\n\n        public LibraryIterator(Book[] books) {\n            this.books = books;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return position &lt; books.length &amp;&amp; books[position] != null;\n        }\n\n        @Override\n        public Book next() {\n            if (!hasNext()) {\n                return null;\n            }\n            return books[position++];\n        }\n    }\n}\n\n// Another concrete collection - BookShelf\nclass BookShelf implements BookCollection {\n    private List&lt;Book&gt; books = new ArrayList&lt;&gt;();\n\n    public void addBook(Book book) {\n        books.add(book);\n    }\n\n    @Override\n    public BookIterator createIterator() {\n        return new BookShelfIterator();\n    }\n\n    // Concrete iterator\n    private class BookShelfIterator implements BookIterator {\n        private int position = 0;\n\n        @Override\n        public boolean hasNext() {\n            return position &lt; books.size();\n        }\n\n        @Override\n        public Book next() {\n            if (!hasNext()) {\n                return null;\n            }\n            return books.get(position++);\n        }\n    }\n}\n\n// Client code\nBook[] libraryBooks = new Book[3];\nlibraryBooks[0] = new Book(\"Design Patterns\", \"Gang of Four\");\nlibraryBooks[1] = new Book(\"Clean Code\", \"Robert C. Martin\");\nlibraryBooks[2] = new Book(\"Refactoring\", \"Martin Fowler\");\n\nLibrary library = new Library(libraryBooks);\nBookIterator libraryIterator = library.createIterator();\n\nSystem.out.println(\"=== Library Books ===\");\nwhile (libraryIterator.hasNext()) {\n    Book book = libraryIterator.next();\n    System.out.println(book);\n}\n\nBookShelf bookShelf = new BookShelf();\nbookShelf.addBook(new Book(\"The Pragmatic Programmer\", \"Andrew Hunt\"));\nbookShelf.addBook(new Book(\"Head First Design Patterns\", \"Eric Freeman\"));\n\nBookIterator bookShelfIterator = bookShelf.createIterator();\n\nSystem.out.println(\"\\n=== Bookshelf Books ===\");\nwhile (bookShelfIterator.hasNext()) {\n    Book book = bookShelfIterator.next();\n    System.out.println(book);\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#javas-built-in-iterators","title":"Java's Built-in Iterators","text":"<p>Java's Collection Framework implements the Iterator pattern:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n// Using Java's built-in iterator\nList&lt;String&gt; items = new ArrayList&lt;&gt;();\nitems.add(\"Item A\");\nitems.add(\"Item B\");\nitems.add(\"Item C\");\n\n// Get the iterator\nIterator&lt;String&gt; iterator = items.iterator();\n\n// Traverse using the iterator\nwhile (iterator.hasNext()) {\n    String item = iterator.next();\n    System.out.println(item);\n}\n\n// Java's for-each loop uses iterators behind the scenes\nfor (String item : items) {\n    System.out.println(item);\n}\n\n// The iterator can also remove elements during traversal\niterator = items.iterator();\nwhile (iterator.hasNext()) {\n    String item = iterator.next();\n    if (item.equals(\"Item B\")) {\n        iterator.remove();\n    }\n}\n\nSystem.out.println(\"After removal: \" + items);\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#internal-iterator-vs-external-iterator","title":"Internal Iterator vs. External Iterator","text":"<pre><code>// External Iterator (Traditional)\nList&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nIterator&lt;Integer&gt; iterator = numbers.iterator();\n\nint sum = 0;\nwhile (iterator.hasNext()) {\n    sum += iterator.next();\n}\nSystem.out.println(\"Sum using external iterator: \" + sum);\n\n// Internal Iterator (Java 8+)\nint sum2 = numbers.stream().mapToInt(Integer::intValue).sum();\nSystem.out.println(\"Sum using internal iterator: \" + sum2);\n\n// Another internal iterator example with forEach\nList&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nnames.forEach(name -&gt; System.out.println(\"Hello, \" + name));\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-iterator-pattern","title":"When to Use the Iterator Pattern","text":"<ul> <li>When you want to access a collection's contents without exposing its internal structure</li> <li>When you want to support multiple traversals of a collection</li> <li>When you want to provide a uniform interface for traversing different collection types</li> <li>When you want to separate traversal behavior from the collection's implementation</li> <li>When you need different traversal algorithms for the same collection</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_3","title":"Advantages","text":"<ul> <li>Simplifies the interface of a collection</li> <li>Supports variations in traversal of a collection</li> <li>Provides a uniform way to traverse different collections</li> <li>Allows multiple iterators on the same collection to be active simultaneously</li> <li>Separates the traversal algorithm from the collection implementation</li> <li>Follows the Single Responsibility Principle by separating collection and traversal logic</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_3","title":"Disadvantages","text":"<ul> <li>Can complicate the code for simple collections</li> <li>May not be as efficient as direct access for some collections</li> <li>Can be an overkill for simple, single-purpose data structures</li> <li>Iterator can get out of sync if the collection is modified during iteration</li> <li>Implementing iterators for complex collections can be challenging</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#mediator-pattern","title":"Mediator Pattern","text":"<p>The Mediator pattern is used to reduce communication complexity between multiple objects. It's used to centralize communication between objects.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_4","title":"Intent","text":"<ul> <li>Reduce communication complexity between multiple objects</li> <li>Centralize communication between objects</li> <li>Structure a system around a set of objects</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_4","title":"Implementation","text":"<pre><code>// Mediator interface\ninterface Mediator {\n    void send(String message, Colleague colleague);\n}\n\n// Colleague interface\ninterface Colleague {\n    void send(String message);\n    void receive(String message);\n}\n\n// Concrete mediator\nclass ConcreteMediator implements Mediator {\n    private List&lt;Colleague&gt; colleagues = new ArrayList&lt;&gt;();\n\n    public void addColleague(Colleague colleague) {\n        colleagues.add(colleague);\n    }\n\n    @Override\n    public void send(String message, Colleague colleague) {\n        for (Colleague c : colleagues) {\n            if (c != colleague) {\n                c.receive(message);\n            }\n        }\n    }\n}\n\n// Concrete colleagues\nclass ConcreteColleague implements Colleague {\n    private Mediator mediator;\n\n    public ConcreteColleague(Mediator mediator) {\n        this.mediator = mediator;\n    }\n\n    @Override\n    public void send(String message) {\n        mediator.send(message, this);\n    }\n\n    @Override\n    public void receive(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n}\n\n// Usage\nMediator mediator = new ConcreteMediator();\nColleague colleague1 = new ConcreteColleague(mediator);\nColleague colleague2 = new ConcreteColleague(mediator);\nColleague colleague3 = new ConcreteColleague(mediator);\n\nmediator.addColleague(colleague1);\nmediator.addColleague(colleague2);\nmediator.addColleague(colleague3);\n\ncolleague1.send(\"Hello from colleague 1\");\ncolleague2.send(\"Hello from colleague 2\");\ncolleague3.send(\"Hello from colleague 3\");\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-mediator-pattern","title":"When to Use the Mediator Pattern","text":"<ul> <li>When you want to reduce communication complexity between multiple objects</li> <li>When you want to centralize communication between objects</li> <li>When you want to structure a system around a set of objects</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_4","title":"Advantages","text":"<ul> <li>Increases flexibility in adding new types of colleagues</li> <li>Increases flexibility in adding new types of mediators</li> <li>Increases flexibility in adding new types of clients</li> <li>Increases flexibility in adding new types of messages</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_4","title":"Disadvantages","text":"<ul> <li>Increases the number of classes for each individual colleague</li> <li>May lead to an excessive number of colleague classes</li> <li>Complicates the code if there are many colleagues with complex execution logic</li> <li>Not suitable for simple operations where the mediator pattern overhead is not justified</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#memento-pattern","title":"Memento Pattern","text":"<p>The Memento pattern is used to restore an object to its previous state. It's used to implement undoable operations.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_5","title":"Intent","text":"<ul> <li>Restore an object to its previous state</li> <li>Implement undoable operations</li> <li>Structure a system around a set of objects</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_5","title":"Implementation","text":"<pre><code>// Memento interface\ninterface Memento {\n    void restore();\n}\n\n// Originator interface\ninterface Originator {\n    Memento createMemento();\n}\n\n// Concrete originator\nclass ConcreteOriginator implements Originator {\n    private String state;\n\n    public void setState(String state) {\n        this.state = state;\n    }\n\n    public String getState() {\n        return state;\n    }\n\n    @Override\n    public Memento createMemento() {\n        return new ConcreteMemento(state);\n    }\n}\n\n// Concrete memento\nclass ConcreteMemento implements Memento {\n    private String state;\n\n    public ConcreteMemento(String state) {\n        this.state = state;\n    }\n\n    @Override\n    public void restore() {\n        // Restore state\n    }\n}\n\n// Caretaker\nclass Caretaker {\n    private List&lt;Memento&gt; mementos = new ArrayList&lt;&gt;();\n\n    public void addMemento(Memento memento) {\n        mementos.add(memento);\n    }\n\n    public Memento getMemento(int index) {\n        return mementos.get(index);\n    }\n}\n\n// Usage\nOriginator originator = new ConcreteOriginator();\noriginator.setState(\"State 1\");\n\nMemento memento = originator.createMemento();\n\nCaretaker caretaker = new Caretaker();\ncaretaker.addMemento(memento);\n\noriginator.setState(\"State 2\");\n\noriginator.restore(caretaker.getMemento(0));\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-memento-pattern","title":"When to Use the Memento Pattern","text":"<ul> <li>When you want to restore an object to its previous state</li> <li>When you want to implement undoable operations</li> <li>When you want to structure a system around a set of objects</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_5","title":"Advantages","text":"<ul> <li>Increases flexibility in adding new types of originators</li> <li>Increases flexibility in adding new types of mementos</li> <li>Increases flexibility in adding new types of caretakers</li> <li>Increases flexibility in adding new types of states</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_5","title":"Disadvantages","text":"<ul> <li>Increases the number of classes for each individual memento</li> <li>May lead to an excessive number of memento classes</li> <li>Complicates the code if there are many mementos with complex execution logic</li> <li>Not suitable for simple operations where the memento pattern overhead is not justified</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#observer-pattern","title":"Observer Pattern","text":"<p>The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_6","title":"Intent","text":"<ul> <li>Define a one-to-many dependency between objects</li> <li>Notify and update all dependent objects automatically when the subject changes state</li> <li>Keep objects loosely coupled</li> <li>Support broadcast communication</li> <li>Provide a mechanism for event handling</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_6","title":"Implementation","text":"<pre><code>import java.util.ArrayList;\nimport java.util.List;\n\n// Subject interface\ninterface Subject {\n    void registerObserver(Observer observer);\n    void removeObserver(Observer observer);\n    void notifyObservers();\n}\n\n// Observer interface\ninterface Observer {\n    void update(float temperature, float humidity, float pressure);\n}\n\n// Display interface\ninterface DisplayElement {\n    void display();\n}\n\n// Concrete Subject\nclass WeatherData implements Subject {\n    private List&lt;Observer&gt; observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData() {\n        observers = new ArrayList&lt;&gt;();\n    }\n\n    @Override\n    public void registerObserver(Observer observer) {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObserver(Observer observer) {\n        int index = observers.indexOf(observer);\n        if (index &gt;= 0) {\n            observers.remove(index);\n        }\n    }\n\n    @Override\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(temperature, humidity, pressure);\n        }\n    }\n\n    public void measurementsChanged() {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n}\n\n// Concrete Observer\nclass CurrentConditionsDisplay implements Observer, DisplayElement {\n    private float temperature;\n    private float humidity;\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature \n            + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\n\nclass StatisticsDisplay implements Observer, DisplayElement {\n    private float maxTemp = 0.0f;\n    private float minTemp = 200.0f;\n    private float tempSum = 0.0f;\n    private int numReadings = 0;\n    private Subject weatherData;\n\n    public StatisticsDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure) {\n        tempSum += temperature;\n        numReadings++;\n\n        if (temperature &gt; maxTemp) {\n            maxTemp = temperature;\n        }\n\n        if (temperature &lt; minTemp) {\n            minTemp = temperature;\n        }\n\n        display();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Avg/Max/Min temperature = \" + (tempSum / numReadings)\n            + \"/\" + maxTemp + \"/\" + minTemp);\n    }\n}\n\n// Client code\nWeatherData weatherData = new WeatherData();\n\nCurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);\nStatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n\nweatherData.setMeasurements(80, 65, 30.4f);\nweatherData.setMeasurements(82, 70, 29.2f);\nweatherData.setMeasurements(78, 90, 29.2f);\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#push-vs-pull-model","title":"Push vs. Pull Model","text":""},{"location":"design-patterns/design-patterns-behavioral/#push-model-previous-example","title":"Push Model (previous example):","text":"<p>The subject pushes all data to observers.</p>"},{"location":"design-patterns/design-patterns-behavioral/#pull-model","title":"Pull Model:","text":"<p>Observers pull only the data they need from the subject.</p> <pre><code>// Subject interface\ninterface Subject {\n    void registerObserver(Observer observer);\n    void removeObserver(Observer observer);\n    void notifyObservers();\n    // Methods for observers to pull data as needed\n    float getTemperature();\n    float getHumidity();\n    float getPressure();\n}\n\n// Observer interface\ninterface Observer {\n    void update();  // No parameters - observers will pull data\n}\n\n// Concrete Subject\nclass WeatherData implements Subject {\n    private List&lt;Observer&gt; observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData() {\n        observers = new ArrayList&lt;&gt;();\n    }\n\n    @Override\n    public void registerObserver(Observer observer) {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObserver(Observer observer) {\n        int index = observers.indexOf(observer);\n        if (index &gt;= 0) {\n            observers.remove(index);\n        }\n    }\n\n    @Override\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update();  // Just notify, let observers pull data\n        }\n    }\n\n    @Override\n    public float getTemperature() {\n        return temperature;\n    }\n\n    @Override\n    public float getHumidity() {\n        return humidity;\n    }\n\n    @Override\n    public float getPressure() {\n        return pressure;\n    }\n\n    public void measurementsChanged() {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n}\n\n// Concrete Observer with Pull model\nclass CurrentConditionsDisplay implements Observer, DisplayElement {\n    private float temperature;\n    private float humidity;\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void update() {\n        // Pull only the data we need\n        this.temperature = weatherData.getTemperature();\n        this.humidity = weatherData.getHumidity();\n        display();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature \n            + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\n\n// Only pull temperature for this display\nclass TemperatureDisplay implements Observer, DisplayElement {\n    private float temperature;\n    private Subject weatherData;\n\n    public TemperatureDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void update() {\n        // Only pull temperature - we don't need other data\n        this.temperature = weatherData.getTemperature();\n        display();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current temperature: \" + temperature + \"F degrees\");\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#javas-built-in-observer-pattern","title":"Java's Built-in Observer Pattern","text":"<p>Java includes built-in support for the Observer pattern through <code>java.util.Observable</code> (Subject) and <code>java.util.Observer</code> (Observer) - note that these are now deprecated since Java 9.</p> <pre><code>import java.util.Observable;\nimport java.util.Observer;\n\n// Using Java's built-in Observable\nclass WeatherData extends Observable {\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData() { }\n\n    public void measurementsChanged() {\n        setChanged();  // Indicate state has changed\n        notifyObservers();  // Notify all observers\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n\n    public float getTemperature() {\n        return temperature;\n    }\n\n    public float getHumidity() {\n        return humidity;\n    }\n\n    public float getPressure() {\n        return pressure;\n    }\n}\n\n// Observer using Java's built-in Observer interface\nclass CurrentConditionsDisplay implements Observer, DisplayElement {\n    private float temperature;\n    private float humidity;\n    private Observable observable;\n\n    public CurrentConditionsDisplay(Observable observable) {\n        this.observable = observable;\n        observable.addObserver(this);\n    }\n\n    @Override\n    public void update(Observable obs, Object arg) {\n        if (obs instanceof WeatherData) {\n            WeatherData weatherData = (WeatherData) obs;\n            this.temperature = weatherData.getTemperature();\n            this.humidity = weatherData.getHumidity();\n            display();\n        }\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature \n            + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\n\n// Note: Both Observable and Observer are now deprecated as of Java 9\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#event-listeners-in-java","title":"Event Listeners in Java","text":"<p>Modern Java applications often use event listeners, which implement the Observer pattern:</p> <pre><code>import java.awt.Button;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n// Button is the subject, ActionListener is the observer\nButton button = new Button(\"Click Me\");\n\n// Adding an observer using anonymous class\nbutton.addActionListener(new ActionListener() {\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        System.out.println(\"Button clicked!\");\n    }\n});\n\n// Using lambda (Java 8+)\nbutton.addActionListener(e -&gt; System.out.println(\"Button clicked!\"));\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#custom-event-system-example","title":"Custom Event System Example","text":"<pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n// Event class\nclass Event {\n    private String type;\n    private Object source;\n    private Map&lt;String, Object&gt; data;\n\n    public Event(String type, Object source) {\n        this.type = type;\n        this.source = source;\n        this.data = new HashMap&lt;&gt;();\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public Object getSource() {\n        return source;\n    }\n\n    public void setData(String key, Object value) {\n        data.put(key, value);\n    }\n\n    public Object getData(String key) {\n        return data.get(key);\n    }\n\n    @Override\n    public String toString() {\n        return \"Event{type='\" + type + \"', source=\" + source + \", data=\" + data + '}';\n    }\n}\n\n// Event Listener interface\ninterface EventListener {\n    void onEvent(Event event);\n}\n\n// Event Publisher interface\ninterface EventPublisher {\n    void addListener(String eventType, EventListener listener);\n    void removeListener(String eventType, EventListener listener);\n    void notifyListeners(Event event);\n}\n\n// Concrete Event Publisher\nclass EventManager implements EventPublisher {\n    private Map&lt;String, List&lt;EventListener&gt;&gt; listeners = new HashMap&lt;&gt;();\n\n    @Override\n    public void addListener(String eventType, EventListener listener) {\n        listeners.computeIfAbsent(eventType, k -&gt; new ArrayList&lt;&gt;()).add(listener);\n    }\n\n    @Override\n    public void removeListener(String eventType, EventListener listener) {\n        if (listeners.containsKey(eventType)) {\n            listeners.get(eventType).remove(listener);\n        }\n    }\n\n    @Override\n    public void notifyListeners(Event event) {\n        if (listeners.containsKey(event.getType())) {\n            for (EventListener listener : listeners.get(event.getType())) {\n                listener.onEvent(event);\n            }\n        }\n    }\n}\n\n// Example user class that publishes events\nclass User {\n    private String name;\n    private EventPublisher eventPublisher;\n\n    public User(String name, EventPublisher eventPublisher) {\n        this.name = name;\n        this.eventPublisher = eventPublisher;\n    }\n\n    public void login() {\n        System.out.println(name + \" logged in\");\n        Event loginEvent = new Event(\"login\", this);\n        loginEvent.setData(\"username\", name);\n        loginEvent.setData(\"time\", System.currentTimeMillis());\n        eventPublisher.notifyListeners(loginEvent);\n    }\n\n    public void logout() {\n        System.out.println(name + \" logged out\");\n        Event logoutEvent = new Event(\"logout\", this);\n        logoutEvent.setData(\"username\", name);\n        logoutEvent.setData(\"time\", System.currentTimeMillis());\n        eventPublisher.notifyListeners(logoutEvent);\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\n// Event listeners\nclass SecurityMonitor implements EventListener {\n    @Override\n    public void onEvent(Event event) {\n        String username = (String) event.getData(\"username\");\n        long time = (long) event.getData(\"time\");\n\n        System.out.println(\"Security: \" + username + \" \" + event.getType() + \n                          \" at \" + new java.util.Date(time));\n    }\n}\n\nclass UserActivityLogger implements EventListener {\n    @Override\n    public void onEvent(Event event) {\n        String username = (String) event.getData(\"username\");\n        System.out.println(\"Logging: \" + event.getType() + \" event for user \" + username);\n    }\n}\n\n// Usage\nEventManager eventManager = new EventManager();\n\n// Create listeners\nSecurityMonitor securityMonitor = new SecurityMonitor();\nUserActivityLogger activityLogger = new UserActivityLogger();\n\n// Register listeners for different events\neventManager.addListener(\"login\", securityMonitor);\neventManager.addListener(\"logout\", securityMonitor);\neventManager.addListener(\"login\", activityLogger);\n\n// Create a user that publishes events\nUser user = new User(\"John\", eventManager);\n\n// Trigger events\nuser.login();\nuser.logout();\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-observer-pattern","title":"When to Use the Observer Pattern","text":"<ul> <li>When a change to one object requires changing others, and you don't know how many objects need to change</li> <li>When an object should be able to notify others without making assumptions about who they are</li> <li>When you need one-to-many dependencies between objects without tight coupling</li> <li>When you need to implement a reactive system</li> <li>When you're building an event handling system</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_6","title":"Advantages","text":"<ul> <li>Supports loose coupling between the subject and observers</li> <li>Allows sending data to multiple objects with minimal effort</li> <li>Enables dynamic relationships between objects at runtime</li> <li>Makes it easy to add new observers without modifying the subject</li> <li>Follows the Open/Closed Principle</li> <li>Establishes relationships between objects at runtime</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_6","title":"Disadvantages","text":"<ul> <li>Observers are notified in random order</li> <li>If not implemented carefully, can lead to memory leaks (observers need to be properly deregistered)</li> <li>Can cause unexpected updates when cascading changes occur</li> <li>May create performance issues with many observers or complex dependency relationships</li> <li>Can become hard to debug or understand due to indirect relationships</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#state-pattern","title":"State Pattern","text":"<p>The State pattern is used to allow an object to change its behavior when its state changes. It's used to implement state machines.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_7","title":"Intent","text":"<ul> <li>Allow an object to change its behavior when its state changes</li> <li>Implement state machines</li> <li>Structure a system around a set of objects</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_7","title":"Implementation","text":"<pre><code>// State interface\ninterface State {\n    void handle();\n}\n\n// Concrete states\nclass ConcreteStateA implements State {\n    @Override\n    public void handle() {\n        System.out.println(\"Handling state A\");\n    }\n}\n\nclass ConcreteStateB implements State {\n    @Override\n    public void handle() {\n        System.out.println(\"Handling state B\");\n    }\n}\n\n// Context\nclass Context {\n    private State state;\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void handle() {\n        state.handle();\n    }\n}\n\n// Usage\nContext context = new Context();\ncontext.setState(new ConcreteStateA());\ncontext.handle();\n\ncontext.setState(new ConcreteStateB());\ncontext.handle();\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-state-pattern","title":"When to Use the State Pattern","text":"<ul> <li>When you want to allow an object to change its behavior when its state changes</li> <li>When you want to implement state machines</li> <li>When you want to structure a system around a set of objects</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_7","title":"Advantages","text":"<ul> <li>Increases flexibility in adding new types of states</li> <li>Increases flexibility in adding new types of contexts</li> <li>Increases flexibility in adding new types of clients</li> <li>Increases flexibility in adding new types of behaviors</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_7","title":"Disadvantages","text":"<ul> <li>Increases the number of classes for each individual state</li> <li>May lead to an excessive number of state classes</li> <li>Complicates the code if there are many states with complex execution logic</li> <li>Not suitable for simple operations where the state pattern overhead is not justified</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#strategy-pattern","title":"Strategy Pattern","text":"<p>The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from clients that use it.</p>"},{"location":"design-patterns/design-patterns-behavioral/#intent_8","title":"Intent","text":"<ul> <li>Define a family of algorithms, encapsulate each one, and make them interchangeable</li> <li>Let the algorithm vary independently from clients that use it</li> <li>Capture the abstraction in an interface, bury implementation details in derived classes</li> <li>Enable selecting algorithms at runtime</li> <li>Provide different implementations of the same behavior</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#implementation_8","title":"Implementation","text":"<pre><code>// Strategy interface\ninterface PaymentStrategy {\n    void pay(int amount);\n}\n\n// Concrete Strategies\nclass CreditCardStrategy implements PaymentStrategy {\n    private String name;\n    private String cardNumber;\n    private String cvv;\n    private String expirationDate;\n\n    public CreditCardStrategy(String name, String cardNumber, String cvv, String expirationDate) {\n        this.name = name;\n        this.cardNumber = cardNumber;\n        this.cvv = cvv;\n        this.expirationDate = expirationDate;\n    }\n\n    @Override\n    public void pay(int amount) {\n        System.out.println(amount + \" paid with credit card\");\n    }\n}\n\nclass PayPalStrategy implements PaymentStrategy {\n    private String email;\n    private String password;\n\n    public PayPalStrategy(String email, String password) {\n        this.email = email;\n        this.password = password;\n    }\n\n    @Override\n    public void pay(int amount) {\n        System.out.println(amount + \" paid with PayPal\");\n    }\n}\n\nclass CashStrategy implements PaymentStrategy {\n    @Override\n    public void pay(int amount) {\n        System.out.println(amount + \" paid with cash\");\n    }\n}\n\n// Context\nclass ShoppingCart {\n    private PaymentStrategy paymentStrategy;\n\n    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {\n        this.paymentStrategy = paymentStrategy;\n    }\n\n    public void checkout(int amount) {\n        paymentStrategy.pay(amount);\n    }\n}\n\n// Client code\nShoppingCart cart = new ShoppingCart();\n\n// Pay with credit card\ncart.setPaymentStrategy(new CreditCardStrategy(\"John Doe\", \"1234567890123456\", \"123\", \"12/25\"));\ncart.checkout(100);\n\n// Pay with PayPal\ncart.setPaymentStrategy(new PayPalStrategy(\"john@example.com\", \"password\"));\ncart.checkout(200);\n\n// Pay with cash\ncart.setPaymentStrategy(new CashStrategy());\ncart.checkout(50);\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#duck-example-from-head-first-design-patterns","title":"Duck Example (From \"Head First Design Patterns\")","text":"<pre><code>// Behavior interfaces\ninterface FlyBehavior {\n    void fly();\n}\n\ninterface QuackBehavior {\n    void quack();\n}\n\n// Fly behavior implementations\nclass FlyWithWings implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println(\"I'm flying with wings!\");\n    }\n}\n\nclass FlyNoWay implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println(\"I can't fly!\");\n    }\n}\n\nclass FlyRocketPowered implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println(\"I'm flying with a rocket!\");\n    }\n}\n\n// Quack behavior implementations\nclass Quack implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println(\"Quack!\");\n    }\n}\n\nclass Squeak implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println(\"Squeak!\");\n    }\n}\n\nclass MuteQuack implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println(\"&lt;&lt; Silence &gt;&gt;\");\n    }\n}\n\n// Abstract Duck class (Context)\nabstract class Duck {\n    protected FlyBehavior flyBehavior;\n    protected QuackBehavior quackBehavior;\n\n    public Duck() {}\n\n    public void setFlyBehavior(FlyBehavior flyBehavior) {\n        this.flyBehavior = flyBehavior;\n    }\n\n    public void setQuackBehavior(QuackBehavior quackBehavior) {\n        this.quackBehavior = quackBehavior;\n    }\n\n    public void performFly() {\n        flyBehavior.fly();\n    }\n\n    public void performQuack() {\n        quackBehavior.quack();\n    }\n\n    public void swim() {\n        System.out.println(\"All ducks float, even decoys!\");\n    }\n\n    public abstract void display();\n}\n\n// Concrete Duck classes\nclass MallardDuck extends Duck {\n    public MallardDuck() {\n        flyBehavior = new FlyWithWings();\n        quackBehavior = new Quack();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"I'm a mallard duck\");\n    }\n}\n\nclass RubberDuck extends Duck {\n    public RubberDuck() {\n        flyBehavior = new FlyNoWay();\n        quackBehavior = new Squeak();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"I'm a rubber duck\");\n    }\n}\n\nclass DecoyDuck extends Duck {\n    public DecoyDuck() {\n        flyBehavior = new FlyNoWay();\n        quackBehavior = new MuteQuack();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"I'm a decoy duck\");\n    }\n}\n\nclass ModelDuck extends Duck {\n    public ModelDuck() {\n        flyBehavior = new FlyNoWay();\n        quackBehavior = new Quack();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"I'm a model duck\");\n    }\n}\n\n// Usage\nDuck mallard = new MallardDuck();\nmallard.display();\nmallard.performQuack();\nmallard.performFly();\n\nDuck model = new ModelDuck();\nmodel.display();\nmodel.performFly();\n// Change behavior at runtime\nmodel.setFlyBehavior(new FlyRocketPowered());\nmodel.performFly();\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#sorting-strategy-example","title":"Sorting Strategy Example","text":"<pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n// Strategy interface\ninterface SortingStrategy&lt;T&gt; {\n    void sort(List&lt;T&gt; items);\n}\n\n// Concrete strategies\nclass BubbleSortStrategy&lt;T extends Comparable&lt;T&gt;&gt; implements SortingStrategy&lt;T&gt; {\n    @Override\n    public void sort(List&lt;T&gt; items) {\n        System.out.println(\"Bubble sort\");\n        int n = items.size();\n        for (int i = 0; i &lt; n - 1; i++) {\n            for (int j = 0; j &lt; n - i - 1; j++) {\n                if (items.get(j).compareTo(items.get(j + 1)) &gt; 0) {\n                    // Swap elements\n                    T temp = items.get(j);\n                    items.set(j, items.get(j + 1));\n                    items.set(j + 1, temp);\n                }\n            }\n        }\n    }\n}\n\nclass QuickSortStrategy&lt;T extends Comparable&lt;T&gt;&gt; implements SortingStrategy&lt;T&gt; {\n    @Override\n    public void sort(List&lt;T&gt; items) {\n        System.out.println(\"Quick sort\");\n        // For simplicity, using Java's built-in sort method to simulate quick sort\n        Collections.sort(items);\n    }\n}\n\nclass MergeSortStrategy&lt;T extends Comparable&lt;T&gt;&gt; implements SortingStrategy&lt;T&gt; {\n    @Override\n    public void sort(List&lt;T&gt; items) {\n        System.out.println(\"Merge sort\");\n        // For simplicity, using Java's built-in sort method with a custom comparator\n        Collections.sort(items, Comparator.naturalOrder());\n    }\n}\n\n// Context\nclass Sorter&lt;T extends Comparable&lt;T&gt;&gt; {\n    private SortingStrategy&lt;T&gt; strategy;\n\n    public void setStrategy(SortingStrategy&lt;T&gt; strategy) {\n        this.strategy = strategy;\n    }\n\n    public void sort(List&lt;T&gt; items) {\n        if (strategy == null) {\n            throw new IllegalStateException(\"Sorting strategy not set\");\n        }\n        strategy.sort(items);\n    }\n}\n\n// Usage\nList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();\nnumbers.add(5);\nnumbers.add(1);\nnumbers.add(9);\nnumbers.add(3);\nnumbers.add(7);\n\nSorter&lt;Integer&gt; sorter = new Sorter&lt;&gt;();\n\n// Use bubble sort\nsorter.setStrategy(new BubbleSortStrategy&lt;&gt;());\nsorter.sort(numbers);\nSystem.out.println(\"Bubble sort result: \" + numbers);\n\n// Scramble the list again\nCollections.shuffle(numbers);\nSystem.out.println(\"Shuffled list: \" + numbers);\n\n// Use quick sort\nsorter.setStrategy(new QuickSortStrategy&lt;&gt;());\nsorter.sort(numbers);\nSystem.out.println(\"Quick sort result: \" + numbers);\n\n// Scramble the list again\nCollections.shuffle(numbers);\nSystem.out.println(\"Shuffled list: \" + numbers);\n\n// Use merge sort\nsorter.setStrategy(new MergeSortStrategy&lt;&gt;());\nsorter.sort(numbers);\nSystem.out.println(\"Merge sort result: \" + numbers);\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#strategy-vs-state-pattern","title":"Strategy vs. State Pattern","text":"<p>While the Strategy and State patterns have similar structures, they solve different problems:</p> <pre><code>// Strategy Pattern (Algorithm variation)\ninterface CompressionStrategy {\n    void compress(String filename);\n}\n\nclass ZipCompressionStrategy implements CompressionStrategy {\n    @Override\n    public void compress(String filename) {\n        System.out.println(\"Compressing \" + filename + \" using ZIP compression\");\n    }\n}\n\nclass RarCompressionStrategy implements CompressionStrategy {\n    @Override\n    public void compress(String filename) {\n        System.out.println(\"Compressing \" + filename + \" using RAR compression\");\n    }\n}\n\nclass Compressor {\n    private CompressionStrategy strategy;\n\n    public void setCompressionStrategy(CompressionStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void compress(String filename) {\n        if (strategy == null) {\n            throw new IllegalStateException(\"Compression strategy not set\");\n        }\n        strategy.compress(filename);\n    }\n}\n\n// State Pattern (State transitions)\ninterface State {\n    void handle(Document document);\n}\n\nclass DraftState implements State {\n    @Override\n    public void handle(Document document) {\n        System.out.println(\"Document is in DRAFT state\");\n        document.setState(new ModeratedState());\n    }\n}\n\nclass ModeratedState implements State {\n    @Override\n    public void handle(Document document) {\n        System.out.println(\"Document is in MODERATED state\");\n        document.setState(new PublishedState());\n    }\n}\n\nclass PublishedState implements State {\n    @Override\n    public void handle(Document document) {\n        System.out.println(\"Document is in PUBLISHED state\");\n        // No transition in this example\n    }\n}\n\nclass Document {\n    private State state;\n\n    public Document() {\n        this.state = new DraftState();\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void process() {\n        state.handle(this);\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-behavioral/#when-to-use-the-strategy-pattern","title":"When to Use the Strategy Pattern","text":"<ul> <li>When you want to define a family of algorithms</li> <li>When you need to select an algorithm at runtime</li> <li>When you have multiple variants of an algorithm</li> <li>When an algorithm uses data that clients shouldn't know about</li> <li>When a class defines many behaviors that appear as multiple conditional statements</li> <li>When you want to avoid exposing complex algorithm-specific data structures</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#advantages_8","title":"Advantages","text":"<ul> <li>Provides an alternative to inheritance for extending behavior</li> <li>Encapsulates the implementation details of algorithms</li> <li>Eliminates conditional statements for algorithm selection</li> <li>Allows changing the algorithm at runtime</li> <li>Promotes the Open/Closed Principle</li> <li>Isolates the code and data of specific algorithms from the rest of the code</li> </ul>"},{"location":"design-patterns/design-patterns-behavioral/#disadvantages_8","title":"Disadvantages","text":"<ul> <li>Clients must be aware of different strategies</li> <li>Increases the number of objects in an application</li> <li>Can add complexity if strategies don't vary that much</li> <li>Communication overhead between strategy and context</li> <li>Might introduce unnecessary abstraction for simple algorithms</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/","title":"Design Patterns Best Practices","text":""},{"location":"design-patterns/design-patterns-best-practices/#overview","title":"Overview","text":"<p>This guide covers essential best practices for effectively implementing design patterns in Java applications. It provides guidance on pattern selection, implementation considerations, common pitfalls to avoid, and recommendations for combining patterns to solve complex problems.</p>"},{"location":"design-patterns/design-patterns-best-practices/#prerequisites","title":"Prerequisites","text":"<ul> <li>Understanding of core design patterns (Creational, Structural, Behavioral, J2EE)</li> <li>Experience with Java programming</li> <li>Familiarity with SOLID principles</li> <li>Basic knowledge of software architecture concepts</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Learn to select the appropriate design patterns for specific problems</li> <li>Understand how to implement patterns correctly and efficiently</li> <li>Recognize patterns in existing codebases</li> <li>Avoid common pitfalls in design pattern implementation</li> <li>Apply patterns in combination to solve complex problems</li> <li>Keep up with evolving design pattern practices</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Pattern Selection Guidelines</li> <li>Implementation Best Practices</li> <li>Combining Design Patterns</li> <li>Refactoring to Patterns</li> <li>Testing Pattern Implementations</li> <li>Performance Considerations</li> <li>Documentation Guidelines</li> <li>Modern Alternatives</li> <li>Anti-Patterns to Avoid</li> <li>Evolving Patterns</li> </ol>"},{"location":"design-patterns/design-patterns-best-practices/#pattern-selection-guidelines","title":"Pattern Selection Guidelines","text":""},{"location":"design-patterns/design-patterns-best-practices/#understand-the-problem-first","title":"Understand the Problem First","text":"<p>Before choosing a design pattern, thoroughly understand the problem you're trying to solve:</p> <ul> <li>Clear Requirements: Ensure you have a clear understanding of the functional and non-functional requirements.</li> <li>Current vs. Future Needs: Consider both immediate needs and likely future requirements.</li> <li>Constraints: Understand technical constraints, performance requirements, and scalability needs.</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#selection-criteria","title":"Selection Criteria","text":"<p>When selecting a pattern, consider:</p> <ol> <li>Primary Intent: Does the pattern's primary purpose align with your problem?</li> <li>Applicability: Do your problem characteristics match the pattern's applicability criteria?</li> <li>Consequences: Are the trade-offs introduced by the pattern acceptable?</li> <li>Simplicity: Is this the simplest solution to your problem?</li> <li>Team Familiarity: Is your team familiar with the pattern or can they quickly learn it?</li> </ol>"},{"location":"design-patterns/design-patterns-best-practices/#common-selection-mistakes","title":"Common Selection Mistakes","text":"<ul> <li>Pattern Overuse: Using patterns when simpler solutions would suffice</li> <li>Force-fitting: Trying to make a problem fit a pattern rather than vice versa</li> <li>Premature Abstraction: Applying patterns before understanding the real problem</li> <li>Resume-Driven Development: Using patterns to show off rather than solve problems</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#implementation-best-practices","title":"Implementation Best Practices","text":""},{"location":"design-patterns/design-patterns-best-practices/#follow-solid-principles","title":"Follow SOLID Principles","text":"<p>Design patterns should reinforce, not replace, solid engineering principles:</p> <ul> <li>Single Responsibility: Each class should have a single reason to change</li> <li>Open/Closed: Open for extension, closed for modification</li> <li>Liskov Substitution: Subtypes must be substitutable for their base types</li> <li>Interface Segregation: Clients shouldn't depend on interfaces they don't use</li> <li>Dependency Inversion: Depend on abstractions, not concretions</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#context-awareness","title":"Context Awareness","text":"<ul> <li>Adapt to the Codebase: Implement patterns in a way that fits the existing codebase style</li> <li>Consider Language Features: Use language-specific features to improve pattern implementation</li> <li>Framework Integration: Ensure patterns work well with frameworks in use</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Clear Pattern Indication: Name classes to indicate the pattern being used (e.g., UserFactory, OrderBuilder)</li> <li>Consistent Terminology: Use consistent naming across the codebase for similar pattern implementations</li> <li>Self-Documenting: Names should reflect roles in the pattern</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#implementation-examples-dos-and-donts","title":"Implementation Examples - Do's and Don'ts","text":"<p>Singleton Pattern - Do: <pre><code>public enum Singleton {\n    INSTANCE;\n\n    public void doSomething() {\n        // Implementation\n    }\n}\n</code></pre></p> <p>Singleton Pattern - Don't: <pre><code>public class BadSingleton {\n    private static BadSingleton instance;\n\n    private BadSingleton() {}\n\n    public static BadSingleton getInstance() {\n        if (instance == null) {\n            instance = new BadSingleton(); // Not thread-safe\n        }\n        return instance;\n    }\n}\n</code></pre></p>"},{"location":"design-patterns/design-patterns-best-practices/#combining-design-patterns","title":"Combining Design Patterns","text":"<p>Design patterns are often more powerful when combined. Common effective combinations include:</p>"},{"location":"design-patterns/design-patterns-best-practices/#mvc-observer","title":"MVC + Observer","text":"<p>The Model-View-Controller pattern often uses the Observer pattern to notify Views of Model changes:</p> <pre><code>// Model implements Observable (or uses PropertyChangeSupport)\n// Views implement Observer\n// Controller updates Model, which notifies Views\n</code></pre>"},{"location":"design-patterns/design-patterns-best-practices/#factory-method-strategy","title":"Factory Method + Strategy","text":"<p>Use Factory Method to create Strategy implementations:</p> <pre><code>public class PaymentProcessorFactory {\n    public PaymentStrategy createPaymentStrategy(String type) {\n        if (\"credit\".equals(type)) {\n            return new CreditCardPaymentStrategy();\n        } else if (\"paypal\".equals(type)) {\n            return new PayPalPaymentStrategy();\n        }\n        throw new IllegalArgumentException(\"Unknown payment type\");\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-best-practices/#decorator-composite","title":"Decorator + Composite","text":"<p>Use Decorator to add behavior to Composite structures:</p> <pre><code>// Base component interface\nComponent component = new ConcreteComponent();\n// Add decorators\ncomponent = new SecurityDecorator(component);\ncomponent = new LoggingDecorator(component);\n// Use in composite structure\nCompositeComponent composite = new CompositeComponent();\ncomposite.add(component);\n</code></pre>"},{"location":"design-patterns/design-patterns-best-practices/#additional-effective-combinations","title":"Additional Effective Combinations","text":"<ul> <li>Builder + Factory Method: Factory Method creates Builders for complex objects</li> <li>Adapter + Facade: Facade uses Adapters to integrate different subsystems</li> <li>Chain of Responsibility + Command: Commands travel through a processing chain</li> <li>Proxy + Decorator: Proxy controls access, Decorator adds behavior</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#refactoring-to-patterns","title":"Refactoring to Patterns","text":""},{"location":"design-patterns/design-patterns-best-practices/#recognizing-pattern-opportunities","title":"Recognizing Pattern Opportunities","text":"<p>Look for these code smells that often indicate opportunities for patterns:</p> <ul> <li>Duplicate Code: May indicate need for Template Method or Strategy</li> <li>Large Switch Statements: Often replaceable with Strategy or Command</li> <li>High Coupling: May benefit from Observer or Mediator</li> <li>Complex Object Creation: Consider Factory, Builder, or Prototype</li> <li>Feature Envy: May indicate need for moving behavior via Command or Strategy</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#refactoring-steps","title":"Refactoring Steps","text":"<ol> <li>Identify the Problem: Determine what specific issue needs addressing</li> <li>Select Candidate Pattern: Choose pattern(s) that might solve the problem</li> <li>Test Understanding: Ensure you understand how the pattern addresses the issue</li> <li>Create Tests: Write tests to verify current behavior</li> <li>Refactor Incrementally: Apply the pattern in small, testable steps</li> <li>Verify with Tests: Ensure all tests pass after each step</li> <li>Review: Assess if the pattern solved the original problem</li> </ol>"},{"location":"design-patterns/design-patterns-best-practices/#example-refactoring-to-strategy-pattern","title":"Example: Refactoring to Strategy Pattern","text":"<p>Before: <pre><code>public class PaymentProcessor {\n    public void processPayment(String type, double amount) {\n        if (\"credit\".equals(type)) {\n            // Credit card processing logic\n            System.out.println(\"Processing credit card payment of $\" + amount);\n        } else if (\"paypal\".equals(type)) {\n            // PayPal processing logic\n            System.out.println(\"Processing PayPal payment of $\" + amount);\n        } else if (\"crypto\".equals(type)) {\n            // Cryptocurrency processing logic\n            System.out.println(\"Processing crypto payment of $\" + amount);\n        }\n    }\n}\n</code></pre></p> <p>After: <pre><code>// Strategy interface\npublic interface PaymentStrategy {\n    void process(double amount);\n}\n\n// Concrete strategies\npublic class CreditCardStrategy implements PaymentStrategy {\n    @Override\n    public void process(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n    }\n}\n\npublic class PayPalStrategy implements PaymentStrategy {\n    @Override\n    public void process(double amount) {\n        System.out.println(\"Processing PayPal payment of $\" + amount);\n    }\n}\n\npublic class CryptoStrategy implements PaymentStrategy {\n    @Override\n    public void process(double amount) {\n        System.out.println(\"Processing crypto payment of $\" + amount);\n    }\n}\n\n// Context\npublic class PaymentProcessor {\n    private PaymentStrategy strategy;\n\n    public void setPaymentStrategy(PaymentStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void processPayment(double amount) {\n        if (strategy == null) {\n            throw new IllegalStateException(\"Payment strategy not set\");\n        }\n        strategy.process(amount);\n    }\n}\n</code></pre></p>"},{"location":"design-patterns/design-patterns-best-practices/#testing-pattern-implementations","title":"Testing Pattern Implementations","text":""},{"location":"design-patterns/design-patterns-best-practices/#test-driven-development","title":"Test-Driven Development","text":"<p>Apply TDD when implementing patterns:</p> <ol> <li>Write tests that define expected behavior</li> <li>Implement pattern to satisfy tests</li> <li>Refactor while keeping tests passing</li> </ol>"},{"location":"design-patterns/design-patterns-best-practices/#testing-strategies-by-pattern-type","title":"Testing Strategies by Pattern Type","text":"<p>Creational Patterns: - Test that objects are created with correct initial state - Test that singletons maintain a single instance - Test that factories create the right type of object</p> <p>Structural Patterns: - Test that composed objects work correctly together - Test that adapters correctly translate between interfaces - Test that proxies correctly control access to objects</p> <p>Behavioral Patterns: - Test that the flow of control works as expected - Test that objects communicate correctly - Test that state changes happen appropriately</p>"},{"location":"design-patterns/design-patterns-best-practices/#mocking-and-isolation","title":"Mocking and Isolation","text":"<ul> <li>Use mocks to isolate the pattern being tested</li> <li>Test integration with real dependencies in separate tests</li> <li>Consider testing frameworks like Mockito for Java</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#performance-considerations","title":"Performance Considerations","text":""},{"location":"design-patterns/design-patterns-best-practices/#pattern-performance-impact","title":"Pattern Performance Impact","text":"<p>Design patterns can impact performance in various ways:</p> <ul> <li>Indirection Cost: Patterns often add layers of indirection</li> <li>Object Creation: Some patterns increase the number of objects created</li> <li>Method Calls: Some patterns increase the number of method calls</li> <li>Memory Usage: Some patterns increase memory consumption</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#optimization-guidelines","title":"Optimization Guidelines","text":"<ul> <li>Measure First: Use profiling to identify actual bottlenecks</li> <li>Optimize Hot Spots: Focus optimization on frequently used code paths</li> <li>Consider Alternatives: Use simpler patterns when performance is critical</li> <li>Caching: Add caching to expensive pattern operations</li> <li>Lazy Initialization: Initialize components only when needed</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#common-performance-issues","title":"Common Performance Issues","text":"<p>Factory Method vs. Direct Creation: - Factory Method adds method call overhead - Factory Method allows for optimization through caching or object pooling</p> <p>Proxy Overhead: - Dynamic proxies (like in Spring) can be slower than direct calls - Consider static proxies for performance-critical code</p> <p>Observer Pattern: - Large numbers of observers can cause notification bottlenecks - Consider batch notifications or update throttling</p>"},{"location":"design-patterns/design-patterns-best-practices/#documentation-guidelines","title":"Documentation Guidelines","text":""},{"location":"design-patterns/design-patterns-best-practices/#pattern-documentation","title":"Pattern Documentation","text":"<p>When documenting pattern usage in code:</p> <ol> <li>Identify the Pattern: Clearly state which pattern is being used</li> <li>Explain Intent: Document why the pattern was chosen</li> <li>Describe Structure: Outline how classes participate in the pattern</li> <li>Highlight Variations: Note any customizations or variations</li> <li>List Alternatives: Mention alternatives considered and why they were rejected</li> </ol>"},{"location":"design-patterns/design-patterns-best-practices/#example-documentation","title":"Example Documentation","text":"<pre><code>/**\n * OrderProcessor uses the Strategy pattern to support different processing algorithms.\n * \n * Intent: Allow the processing algorithm to vary independently from clients that use it.\n * \n * Structure:\n * - OrderProcessor: Context class that uses a processing strategy\n * - OrderProcessingStrategy: Strategy interface\n * - BatchOrderStrategy, RealTimeOrderStrategy: Concrete strategies\n * \n * This implementation allows for easy addition of new processing strategies\n * without modifying the OrderProcessor class.\n * \n * Alternative considered: Template Method pattern, rejected because we needed\n * to switch strategies at runtime.\n */\npublic class OrderProcessor {\n    // Implementation\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-best-practices/#modern-alternatives","title":"Modern Alternatives","text":""},{"location":"design-patterns/design-patterns-best-practices/#functional-approaches","title":"Functional Approaches","text":"<p>Modern Java's functional features can replace some traditional patterns:</p> <p>Strategy Pattern with Lambdas: <pre><code>// Traditional\ninterface Validator {\n    boolean validate(String input);\n}\n\nclass EmailValidator implements Validator {\n    @Override\n    public boolean validate(String input) {\n        return input.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n    }\n}\n\n// Functional\nFunction&lt;String, Boolean&gt; emailValidator = \n    input -&gt; input.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n</code></pre></p> <p>Command Pattern with Method References: <pre><code>// Traditional\ninterface Command {\n    void execute();\n}\n\nclass SaveCommand implements Command {\n    private Document doc;\n    public SaveCommand(Document doc) {\n        this.doc = doc;\n    }\n    @Override\n    public void execute() {\n        doc.save();\n    }\n}\n\n// Functional\nDocument doc = new Document();\nRunnable saveCommand = doc::save;\n</code></pre></p>"},{"location":"design-patterns/design-patterns-best-practices/#reactive-programming","title":"Reactive Programming","text":"<p>Reactive programming can replace some traditional patterns:</p> <ul> <li>Observer Pattern \u2192 Reactive Streams (RxJava, Project Reactor)</li> <li>Iterator Pattern \u2192 Observable/Flowable Sequences</li> <li>Chain of Responsibility \u2192 Operators Chain</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#dependency-injection-frameworks","title":"Dependency Injection Frameworks","text":"<p>Modern DI frameworks reduce the need for certain patterns:</p> <ul> <li>Factory Pattern \u2192 Container-managed instantiation</li> <li>Singleton Pattern \u2192 Scoped beans</li> <li>Service Locator \u2192 Injection points</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":""},{"location":"design-patterns/design-patterns-best-practices/#common-design-anti-patterns","title":"Common Design Anti-patterns","text":"<ol> <li>God Object: Class that knows or does too much</li> <li>Golden Hammer: Overusing a familiar pattern for every problem</li> <li>Object Orgy: Insufficient encapsulation and excessive object coupling</li> <li>Spaghetti Code: Tangled, unstructured code with unclear flow</li> <li>Premature Optimization: Optimizing before profiling real bottlenecks</li> </ol>"},{"location":"design-patterns/design-patterns-best-practices/#pattern-specific-anti-patterns","title":"Pattern-Specific Anti-patterns","text":"<p>Singleton Abuse: - Using singletons for simple global state - Creating too many singletons in an application - Using singletons to avoid proper dependency management</p> <p>Factory Overuse: - Creating factories for simple object creation - Implementing factory hierarchies that are more complex than the objects they create - Using abstract factories when simple factories would suffice</p> <p>Observer Overload: - Creating circular observer relationships - Adding too many observers without consideration for performance - Using observers where simple method calls would work</p>"},{"location":"design-patterns/design-patterns-best-practices/#evolving-patterns","title":"Evolving Patterns","text":""},{"location":"design-patterns/design-patterns-best-practices/#adapting-classic-patterns","title":"Adapting Classic Patterns","text":"<p>Classic patterns often need adaptation for modern contexts:</p> <ul> <li>Cloud-Native Environments: Consider elasticity, resilience, and distributed state</li> <li>Microservices Architecture: Adapt patterns for service boundaries and eventual consistency</li> <li>Container-Based Deployment: Consider immutability and infrastructure-as-code implications</li> </ul>"},{"location":"design-patterns/design-patterns-best-practices/#emerging-patterns","title":"Emerging Patterns","text":"<p>New patterns continue to emerge to address modern challenges:</p> <ol> <li>Circuit Breaker: Prevent cascade failures in distributed systems</li> <li>Saga: Manage distributed transactions across microservices</li> <li>CQRS: Separate command and query responsibilities</li> <li>Event Sourcing: Store state as a sequence of events</li> <li>Sidecar: Deploy supporting services alongside primary services</li> </ol>"},{"location":"design-patterns/design-patterns-best-practices/#staying-current","title":"Staying Current","text":"<p>To stay current with evolving patterns:</p> <ul> <li>Follow Industry Thought Leaders: Read blogs and books from pattern experts</li> <li>Participate in Communities: Join discussions in programming communities</li> <li>Review Open Source Projects: Study pattern usage in successful projects</li> <li>Practice Continuous Learning: Regularly update your pattern knowledge</li> <li>Apply Critical Thinking: Evaluate patterns based on their actual benefits </li> </ul>"},{"location":"design-patterns/design-patterns-creational/","title":"Creational Design Patterns","text":""},{"location":"design-patterns/design-patterns-creational/#overview","title":"Overview","text":"<p>Creational design patterns abstract the instantiation process, making a system independent of how its objects are created, composed, and represented. These patterns help make a system independent of how its objects are created, composed, and represented. This guide covers the essential creational design patterns in Java, their implementation, use cases, advantages, and potential drawbacks.</p>"},{"location":"design-patterns/design-patterns-creational/#prerequisites","title":"Prerequisites","text":"<ul> <li>Solid understanding of Java programming</li> <li>Familiarity with object-oriented programming concepts</li> <li>Basic knowledge of SOLID principles</li> <li>Understanding of class inheritance and interfaces</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the purpose and benefits of creational design patterns</li> <li>Learn when and how to implement different creational patterns</li> <li>Recognize appropriate use cases for each pattern</li> <li>Implement creational patterns in Java applications</li> <li>Understand the trade-offs between different creational patterns</li> <li>Apply best practices when implementing creational patterns</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Creational Patterns</li> <li>Singleton Pattern</li> <li>Factory Method Pattern</li> <li>Abstract Factory Pattern</li> <li>Builder Pattern</li> <li>Prototype Pattern</li> <li>Object Pool Pattern</li> <li>Best Practices</li> <li>Common Pitfalls</li> <li>Comparing Creational Patterns</li> </ol>"},{"location":"design-patterns/design-patterns-creational/#introduction-to-creational-patterns","title":"Introduction to Creational Patterns","text":"<p>Creational design patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by controlling the object creation process.</p>"},{"location":"design-patterns/design-patterns-creational/#why-use-creational-patterns","title":"Why Use Creational Patterns?","text":"<ol> <li>Flexibility: They provide flexibility in deciding which objects need to be created for a given case.</li> <li>Decoupling: They promote decoupling the system from how its objects are created, composed, and represented.</li> <li>Encapsulation: They encapsulate knowledge about which concrete classes the system uses.</li> <li>Hide Complexity: They hide the complexities of creating objects.</li> </ol>"},{"location":"design-patterns/design-patterns-creational/#when-to-use-creational-patterns","title":"When to Use Creational Patterns","text":"<ul> <li>When a system should be independent of how its products are created, composed, and represented</li> <li>When a class wants its subclasses to specify the objects it creates</li> <li>When you want to encapsulate object creation logic</li> <li>When you want to hide the complexity of creating complex objects</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#singleton-pattern","title":"Singleton Pattern","text":"<p>The Singleton pattern ensures a class has only one instance and provides a global point of access to it.</p>"},{"location":"design-patterns/design-patterns-creational/#intent","title":"Intent","text":"<ul> <li>Ensure a class has only one instance</li> <li>Provide a global point of access to it</li> <li>Control concurrent access to a shared resource</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#implementation","title":"Implementation","text":"<pre><code>// Basic implementation\npublic class Singleton {\n    private static Singleton instance;\n\n    // Private constructor prevents instantiation from other classes\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n\n    // Business methods\n    public void doSomething() {\n        System.out.println(\"Singleton is doing something\");\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#thread-safe-implementation","title":"Thread-Safe Implementation","text":"<pre><code>// Thread-safe implementation with double-checked locking\npublic class ThreadSafeSingleton {\n    private static volatile ThreadSafeSingleton instance;\n\n    private ThreadSafeSingleton() {\n    }\n\n    public static ThreadSafeSingleton getInstance() {\n        if (instance == null) {\n            synchronized (ThreadSafeSingleton.class) {\n                if (instance == null) {\n                    instance = new ThreadSafeSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#enum-singleton-java-5","title":"Enum Singleton (Java 5+)","text":"<pre><code>// Using enum (thread-safe by default, handles serialization)\npublic enum EnumSingleton {\n    INSTANCE;\n\n    public void doSomething() {\n        System.out.println(\"EnumSingleton is doing something\");\n    }\n}\n\n// Usage:\nEnumSingleton.INSTANCE.doSomething();\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#initialization-on-demand-holder-idiom","title":"Initialization on Demand Holder Idiom","text":"<pre><code>public class LazyInitializationSingleton {\n\n    private LazyInitializationSingleton() {\n    }\n\n    // Inner static class - not loaded until first access\n    private static class SingletonHolder {\n        private static final LazyInitializationSingleton INSTANCE = new LazyInitializationSingleton();\n    }\n\n    public static LazyInitializationSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#when-to-use-the-singleton-pattern","title":"When to Use the Singleton Pattern","text":"<ul> <li>When there must be exactly one instance of a class, and it must be accessible from a well-known access point</li> <li>When you need stricter control over global variables</li> <li>When a shared resource needs controlled access (e.g., a connection pool or registry)</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#advantages","title":"Advantages","text":"<ul> <li>Controlled access to sole instance</li> <li>Reduced namespace usage</li> <li>Can be refined through inheritance</li> <li>Can be configured with variable number of instances</li> <li>More flexible than static methods</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#disadvantages","title":"Disadvantages","text":"<ul> <li>Makes unit testing difficult</li> <li>Violates the Single Responsibility Principle</li> <li>May make the code more complex if not needed</li> <li>Special handling required for multi-threaded environments</li> <li>Can be difficult to subclass</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#factory-method-pattern","title":"Factory Method Pattern","text":"<p>The Factory Method pattern defines an interface for creating an object but lets subclasses decide which class to instantiate.</p>"},{"location":"design-patterns/design-patterns-creational/#intent_1","title":"Intent","text":"<ul> <li>Define an interface for creating an object, but let subclasses decide which class to instantiate</li> <li>Allow a class to defer instantiation to subclasses</li> <li>Create objects without specifying the exact class of object to be created</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#implementation_1","title":"Implementation","text":"<pre><code>// Product interface\ninterface Product {\n    void operation();\n}\n\n// Concrete products\nclass ConcreteProductA implements Product {\n    @Override\n    public void operation() {\n        System.out.println(\"Operation of ConcreteProductA\");\n    }\n}\n\nclass ConcreteProductB implements Product {\n    @Override\n    public void operation() {\n        System.out.println(\"Operation of ConcreteProductB\");\n    }\n}\n\n// Creator abstract class\nabstract class Creator {\n    // Factory method\n    public abstract Product createProduct();\n\n    // Operation that uses the factory method\n    public void someOperation() {\n        Product product = createProduct();\n        product.operation();\n    }\n}\n\n// Concrete creators\nclass ConcreteCreatorA extends Creator {\n    @Override\n    public Product createProduct() {\n        return new ConcreteProductA();\n    }\n}\n\nclass ConcreteCreatorB extends Creator {\n    @Override\n    public Product createProduct() {\n        return new ConcreteProductB();\n    }\n}\n\n// Client code\nCreator creator = new ConcreteCreatorA();\ncreator.someOperation(); // Outputs: Operation of ConcreteProductA\n\ncreator = new ConcreteCreatorB();\ncreator.someOperation(); // Outputs: Operation of ConcreteProductB\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#parameterized-factory-method","title":"Parameterized Factory Method","text":"<pre><code>enum ProductType {\n    TYPE_A, TYPE_B\n}\n\nclass SimpleFactory {\n    public static Product createProduct(ProductType type) {\n        switch (type) {\n            case TYPE_A:\n                return new ConcreteProductA();\n            case TYPE_B:\n                return new ConcreteProductB();\n            default:\n                throw new IllegalArgumentException(\"Invalid product type\");\n        }\n    }\n}\n\n// Usage\nProduct productA = SimpleFactory.createProduct(ProductType.TYPE_A);\nproductA.operation();\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#when-to-use-the-factory-method-pattern","title":"When to Use the Factory Method Pattern","text":"<ul> <li>When a class can't anticipate the class of objects it must create</li> <li>When a class wants its subclasses to specify the objects it creates</li> <li>When classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#advantages_1","title":"Advantages","text":"<ul> <li>Provides hooks for subclasses to extend a class's internal object creation</li> <li>Connects parallel class hierarchies</li> <li>Decouples the implementation of an object from its use</li> <li>Follows the \"Open/Closed Principle\"</li> <li>Promotes loose coupling</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>May lead to large number of small classes</li> <li>Complexity may increase as the pattern requires creating new subclasses</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#abstract-factory-pattern","title":"Abstract Factory Pattern","text":"<p>The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.</p>"},{"location":"design-patterns/design-patterns-creational/#intent_2","title":"Intent","text":"<ul> <li>Provide an interface for creating families of related or dependent objects without specifying their concrete classes</li> <li>Create a system that is independent of how its products are created, composed, and represented</li> <li>Support the creation of products that must work together</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#implementation_2","title":"Implementation","text":"<pre><code>// Abstract products\ninterface Button {\n    void render();\n    void onClick();\n}\n\ninterface Checkbox {\n    void render();\n    void toggle();\n}\n\n// Concrete products for Windows\nclass WindowsButton implements Button {\n    @Override\n    public void render() {\n        System.out.println(\"Render Windows button\");\n    }\n\n    @Override\n    public void onClick() {\n        System.out.println(\"Windows button clicked\");\n    }\n}\n\nclass WindowsCheckbox implements Checkbox {\n    @Override\n    public void render() {\n        System.out.println(\"Render Windows checkbox\");\n    }\n\n    @Override\n    public void toggle() {\n        System.out.println(\"Windows checkbox toggled\");\n    }\n}\n\n// Concrete products for macOS\nclass MacOSButton implements Button {\n    @Override\n    public void render() {\n        System.out.println(\"Render macOS button\");\n    }\n\n    @Override\n    public void onClick() {\n        System.out.println(\"macOS button clicked\");\n    }\n}\n\nclass MacOSCheckbox implements Checkbox {\n    @Override\n    public void render() {\n        System.out.println(\"Render macOS checkbox\");\n    }\n\n    @Override\n    public void toggle() {\n        System.out.println(\"macOS checkbox toggled\");\n    }\n}\n\n// Abstract factory\ninterface GUIFactory {\n    Button createButton();\n    Checkbox createCheckbox();\n}\n\n// Concrete factories\nclass WindowsFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new WindowsButton();\n    }\n\n    @Override\n    public Checkbox createCheckbox() {\n        return new WindowsCheckbox();\n    }\n}\n\nclass MacOSFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new MacOSButton();\n    }\n\n    @Override\n    public Checkbox createCheckbox() {\n        return new MacOSCheckbox();\n    }\n}\n\n// Client code\nclass Application {\n    private Button button;\n    private Checkbox checkbox;\n\n    public Application(GUIFactory factory) {\n        button = factory.createButton();\n        checkbox = factory.createCheckbox();\n    }\n\n    public void render() {\n        button.render();\n        checkbox.render();\n    }\n}\n\n// Usage\nGUIFactory factory = new WindowsFactory();\nApplication app = new Application(factory);\napp.render(); // Renders Windows UI components\n\nfactory = new MacOSFactory();\napp = new Application(factory);\napp.render(); // Renders macOS UI components\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#when-to-use-the-abstract-factory-pattern","title":"When to Use the Abstract Factory Pattern","text":"<ul> <li>When a system should be independent of how its products are created, composed, and represented</li> <li>When a system should be configured with one of multiple families of products</li> <li>When a family of related product objects is designed to be used together, and you need to enforce this constraint</li> <li>When you want to provide a class library of products, and you want to reveal just their interfaces, not their implementations</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#advantages_2","title":"Advantages","text":"<ul> <li>Isolates concrete classes from the client</li> <li>Makes exchanging product families easy</li> <li>Promotes consistency among products</li> <li>Follows the \"Open/Closed Principle\"</li> <li>Supports the Dependency Inversion Principle</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#disadvantages_2","title":"Disadvantages","text":"<ul> <li>Adding new products requires changing the abstract factory interface and all implementations</li> <li>Complexity may increase as the pattern requires many interfaces and classes</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#builder-pattern","title":"Builder Pattern","text":"<p>The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.</p>"},{"location":"design-patterns/design-patterns-creational/#intent_3","title":"Intent","text":"<ul> <li>Separate the construction of a complex object from its representation</li> <li>Allow the same construction process to create different representations</li> <li>Provide a clear step-by-step creation of objects</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#implementation_3","title":"Implementation","text":"<pre><code>// Product\nclass Pizza {\n    private String dough;\n    private String sauce;\n    private String topping;\n\n    public void setDough(String dough) {\n        this.dough = dough;\n    }\n\n    public void setSauce(String sauce) {\n        this.sauce = sauce;\n    }\n\n    public void setTopping(String topping) {\n        this.topping = topping;\n    }\n\n    @Override\n    public String toString() {\n        return \"Pizza with \" + dough + \" dough, \" + sauce + \" sauce, and \" + topping + \" topping.\";\n    }\n}\n\n// Builder interface\ninterface PizzaBuilder {\n    void buildDough();\n    void buildSauce();\n    void buildTopping();\n    Pizza getPizza();\n}\n\n// Concrete builders\nclass HawaiianPizzaBuilder implements PizzaBuilder {\n    private Pizza pizza;\n\n    public HawaiianPizzaBuilder() {\n        this.pizza = new Pizza();\n    }\n\n    @Override\n    public void buildDough() {\n        pizza.setDough(\"thin\");\n    }\n\n    @Override\n    public void buildSauce() {\n        pizza.setSauce(\"mild\");\n    }\n\n    @Override\n    public void buildTopping() {\n        pizza.setTopping(\"ham and pineapple\");\n    }\n\n    @Override\n    public Pizza getPizza() {\n        return pizza;\n    }\n}\n\nclass SpicyPizzaBuilder implements PizzaBuilder {\n    private Pizza pizza;\n\n    public SpicyPizzaBuilder() {\n        this.pizza = new Pizza();\n    }\n\n    @Override\n    public void buildDough() {\n        pizza.setDough(\"thick\");\n    }\n\n    @Override\n    public void buildSauce() {\n        pizza.setSauce(\"hot\");\n    }\n\n    @Override\n    public void buildTopping() {\n        pizza.setTopping(\"pepperoni and jalape\u00f1os\");\n    }\n\n    @Override\n    public Pizza getPizza() {\n        return pizza;\n    }\n}\n\n// Director\nclass Waiter {\n    private PizzaBuilder pizzaBuilder;\n\n    public void setPizzaBuilder(PizzaBuilder pb) {\n        this.pizzaBuilder = pb;\n    }\n\n    public Pizza getPizza() {\n        return pizzaBuilder.getPizza();\n    }\n\n    public void constructPizza() {\n        pizzaBuilder.buildDough();\n        pizzaBuilder.buildSauce();\n        pizzaBuilder.buildTopping();\n    }\n}\n\n// Client code\nWaiter waiter = new Waiter();\nPizzaBuilder hawaiianBuilder = new HawaiianPizzaBuilder();\n\nwaiter.setPizzaBuilder(hawaiianBuilder);\nwaiter.constructPizza();\n\nPizza pizza = waiter.getPizza();\nSystem.out.println(pizza); // Outputs: Pizza with thin dough, mild sauce, and ham and pineapple topping.\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#modern-builder-pattern-fluent-builder","title":"Modern Builder Pattern (Fluent Builder)","text":"<pre><code>// Modern builder pattern with fluent interface\nclass User {\n    // Required parameters\n    private final String firstName;\n    private final String lastName;\n\n    // Optional parameters\n    private final int age;\n    private final String phone;\n    private final String address;\n\n    private User(UserBuilder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.age = builder.age;\n        this.phone = builder.phone;\n        this.address = builder.address;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User: \" + firstName + \" \" + lastName + \", \" + age + \" years old, phone: \" +\n               phone + \", address: \" + address;\n    }\n\n    // Builder class\n    public static class UserBuilder {\n        // Required parameters\n        private final String firstName;\n        private final String lastName;\n\n        // Optional parameters - initialized with default values\n        private int age = 0;\n        private String phone = \"\";\n        private String address = \"\";\n\n        public UserBuilder(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n\n        public UserBuilder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n\n        public UserBuilder address(String address) {\n            this.address = address;\n            return this;\n        }\n\n        public User build() {\n            return new User(this);\n        }\n    }\n}\n\n// Usage\nUser user = new User.UserBuilder(\"John\", \"Doe\")\n    .age(30)\n    .phone(\"1234567890\")\n    .address(\"123 Street, City\")\n    .build();\n\nSystem.out.println(user);\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#when-to-use-the-builder-pattern","title":"When to Use the Builder Pattern","text":"<ul> <li>When the algorithm for creating a complex object should be independent of the parts that make up the object and how they're assembled</li> <li>When the construction process must allow different representations for the object that's constructed</li> <li>When you need to build complex objects step by step</li> <li>When you need to create immutable objects with many optional parameters</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#advantages_3","title":"Advantages","text":"<ul> <li>Clear separation between object construction and representation</li> <li>Provides better control over the construction process</li> <li>Supports creating immutable objects</li> <li>Creates complex objects step by step</li> <li>Enables the creation of different representations of an object</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#disadvantages_3","title":"Disadvantages","text":"<ul> <li>Code complexity increases due to additional classes and interfaces</li> <li>Creates additional overhead for simple objects</li> <li>The builder must be mutable while the final object may be immutable</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#prototype-pattern","title":"Prototype Pattern","text":"<p>The Prototype pattern is used to create new objects by copying an existing object, known as the prototype.</p>"},{"location":"design-patterns/design-patterns-creational/#intent_4","title":"Intent","text":"<ul> <li>Specify the kinds of objects to create using a prototypical instance</li> <li>Create new objects by copying this prototype</li> <li>Reduce the need for subclassing</li> <li>Hide the complexity of creating new instances from the client</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#implementation_4","title":"Implementation","text":"<pre><code>// Prototype interface\ninterface Prototype extends Cloneable {\n    Prototype clone();\n}\n\n// Concrete prototype\nclass ConcretePrototype implements Prototype {\n    private String field;\n\n    public ConcretePrototype(String field) {\n        this.field = field;\n    }\n\n    public void setField(String field) {\n        this.field = field;\n    }\n\n    public String getField() {\n        return field;\n    }\n\n    @Override\n    public Prototype clone() {\n        try {\n            return (Prototype) super.clone();\n        } catch (CloneNotSupportedException e) {\n            // This shouldn't happen since we implement Cloneable\n            return null;\n        }\n    }\n}\n\n// Client code\nConcretePrototype original = new ConcretePrototype(\"Original Value\");\nConcretePrototype copy = (ConcretePrototype) original.clone();\n\nSystem.out.println(original.getField()); // Outputs: Original Value\nSystem.out.println(copy.getField());     // Outputs: Original Value\n\ncopy.setField(\"Modified Value\");\nSystem.out.println(original.getField()); // Outputs: Original Value\nSystem.out.println(copy.getField());     // Outputs: Modified Value\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#deep-vs-shallow-cloning","title":"Deep vs. Shallow Cloning","text":"<pre><code>// Example of a class with references that requires deep cloning\nclass Address implements Cloneable {\n    private String street;\n    private String city;\n\n    public Address(String street, String city) {\n        this.street = street;\n        this.city = city;\n    }\n\n    public void setStreet(String street) {\n        this.street = street;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n\nclass Person implements Cloneable {\n    private String name;\n    private Address address;\n\n    public Person(String name, Address address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    // Shallow copy\n    public Person shallowCopy() throws CloneNotSupportedException {\n        return (Person) super.clone();\n    }\n\n    // Deep copy\n    public Person deepCopy() throws CloneNotSupportedException {\n        Person cloned = (Person) super.clone();\n        cloned.address = (Address) this.address.clone();\n        return cloned;\n    }\n}\n\n// Testing deep vs. shallow copy\nPerson original = new Person(\"John\", new Address(\"123 Street\", \"New York\"));\n\n// Shallow copy\nPerson shallowCopy = original.shallowCopy();\n\n// Deep copy\nPerson deepCopy = original.deepCopy();\n\n// Change address in shallow copy\nshallowCopy.getAddress().setCity(\"Boston\");\n\n// Print original address city\nSystem.out.println(original.getAddress().getCity()); // Outputs: Boston (changed because of shallow copy)\n\n// Change address in deep copy\ndeepCopy.getAddress().setCity(\"Chicago\");\n\n// Print original address city\nSystem.out.println(original.getAddress().getCity()); // Outputs: Boston (unchanged because deep copy doesn't affect original)\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#prototype-registry","title":"Prototype Registry","text":"<pre><code>// Prototype registry for storing and retrieving prototypes\nclass PrototypeRegistry {\n    private Map&lt;String, Prototype&gt; prototypes = new HashMap&lt;&gt;();\n\n    public void addPrototype(String key, Prototype prototype) {\n        prototypes.put(key, prototype);\n    }\n\n    public Prototype getPrototype(String key) {\n        return prototypes.get(key).clone();\n    }\n}\n\n// Usage\nPrototypeRegistry registry = new PrototypeRegistry();\n\nConcretePrototype prototypeA = new ConcretePrototype(\"Prototype A\");\nregistry.addPrototype(\"A\", prototypeA);\n\nConcretePrototype prototypeB = new ConcretePrototype(\"Prototype B\");\nregistry.addPrototype(\"B\", prototypeB);\n\nConcretePrototype cloneA = (ConcretePrototype) registry.getPrototype(\"A\");\nSystem.out.println(cloneA.getField()); // Outputs: Prototype A\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#when-to-use-the-prototype-pattern","title":"When to Use the Prototype Pattern","text":"<ul> <li>When the classes to instantiate are specified at run-time</li> <li>When avoiding the inherent cost of creating a new object in the standard way (e.g., when it's prohibitively expensive)</li> <li>When objects have few variations in state</li> <li>When composing objects requires complex processes</li> <li>When the client application needs to be unaware of object creation and representation</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#advantages_4","title":"Advantages","text":"<ul> <li>Reduces the need for subclassing</li> <li>Hides complexities of creating objects</li> <li>Clients can work with application-specific classes without modification</li> <li>Add and remove products at run-time</li> <li>Specify new objects by varying values</li> <li>Can reduce the number of classes needed</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#disadvantages_4","title":"Disadvantages","text":"<ul> <li>Each subclass of Prototype must implement the clone operation</li> <li>Implementing clone can be difficult when the objects have circular references</li> <li>Deep copying complex objects can be challenging and error-prone</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#object-pool-pattern","title":"Object Pool Pattern","text":"<p>The Object Pool pattern recycles and reuses expensive objects rather than creating and destroying them on demand.</p>"},{"location":"design-patterns/design-patterns-creational/#intent_5","title":"Intent","text":"<ul> <li>Improve performance and memory usage by reusing objects</li> <li>Reduce the overhead of initialization and destruction</li> <li>Provide a mechanism to limit the number of instantiated objects</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#implementation_5","title":"Implementation","text":"<pre><code>import java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.function.Supplier;\n\nclass ObjectPool&lt;T&gt; {\n    private BlockingQueue&lt;T&gt; pool;\n    private Supplier&lt;T&gt; objectFactory;\n\n    public ObjectPool(int size, Supplier&lt;T&gt; objectFactory) {\n        this.objectFactory = objectFactory;\n        this.pool = new LinkedBlockingQueue&lt;&gt;(size);\n\n        // Initialize the pool with objects\n        for (int i = 0; i &lt; size; i++) {\n            pool.add(objectFactory.get());\n        }\n    }\n\n    public T borrowObject() throws InterruptedException {\n        return pool.take();\n    }\n\n    public void returnObject(T object) throws InterruptedException {\n        pool.put(object);\n    }\n\n    public int getSize() {\n        return pool.size();\n    }\n}\n\n// Example resource class\nclass DatabaseConnection {\n    private String connectionId;\n\n    public DatabaseConnection(String connectionId) {\n        this.connectionId = connectionId;\n        // Simulate expensive resource initialization\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        System.out.println(\"Connection created: \" + connectionId);\n    }\n\n    public String getConnectionId() {\n        return connectionId;\n    }\n\n    public void executeQuery(String query) {\n        System.out.println(\"Executing query: \" + query + \" using connection: \" + connectionId);\n    }\n\n    public void close() {\n        // Cleanup resources\n        System.out.println(\"Connection closed: \" + connectionId);\n    }\n}\n\n// Usage\nint poolSize = 5;\nAtomicInteger counter = new AtomicInteger();\n\nObjectPool&lt;DatabaseConnection&gt; connectionPool = new ObjectPool&lt;&gt;(poolSize, \n    () -&gt; new DatabaseConnection(\"Connection-\" + counter.incrementAndGet()));\n\n// Using the pool\ntry {\n    DatabaseConnection connection = connectionPool.borrowObject();\n    connection.executeQuery(\"SELECT * FROM users\");\n    connectionPool.returnObject(connection);\n\n    // Borrow again\n    connection = connectionPool.borrowObject();\n    connection.executeQuery(\"SELECT * FROM products\");\n    connectionPool.returnObject(connection);\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#generic-object-pool-with-auto-return","title":"Generic Object Pool with Auto-Return","text":"<pre><code>import java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nclass AutoReturnObjectPool&lt;T&gt; {\n    private BlockingQueue&lt;T&gt; pool;\n    private Supplier&lt;T&gt; objectFactory;\n    private Consumer&lt;T&gt; objectReset;\n\n    public AutoReturnObjectPool(int size, Supplier&lt;T&gt; objectFactory, Consumer&lt;T&gt; objectReset) {\n        this.objectFactory = objectFactory;\n        this.objectReset = objectReset;\n        this.pool = new LinkedBlockingQueue&lt;&gt;(size);\n\n        // Initialize the pool with objects\n        for (int i = 0; i &lt; size; i++) {\n            pool.add(objectFactory.get());\n        }\n    }\n\n    public void executeWithObject(Consumer&lt;T&gt; action) throws InterruptedException {\n        T object = pool.take();\n        try {\n            action.accept(object);\n        } finally {\n            objectReset.accept(object);\n            pool.put(object);\n        }\n    }\n}\n\n// Usage\nAutoReturnObjectPool&lt;DatabaseConnection&gt; connectionPool = new AutoReturnObjectPool&lt;&gt;(\n    5,\n    () -&gt; new DatabaseConnection(\"Connection-\" + counter.incrementAndGet()),\n    connection -&gt; { /* Reset connection state if needed */ }\n);\n\n// Using the pool with auto-return\ntry {\n    connectionPool.executeWithObject(connection -&gt; {\n        connection.executeQuery(\"SELECT * FROM users\");\n    });\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#when-to-use-the-object-pool-pattern","title":"When to Use the Object Pool Pattern","text":"<ul> <li>When objects are expensive to create (database connections, thread pools, etc.)</li> <li>When you need to limit the number of objects created (e.g., manage licensing limitations)</li> <li>When object initialization is resource-intensive but the object is needed only temporarily</li> <li>When the rate of object creation and destruction is high</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#advantages_5","title":"Advantages","text":"<ul> <li>Improves performance by reusing objects</li> <li>Reduces garbage collection overhead</li> <li>Controls resource usage by limiting the number of objects</li> <li>Allows objects to be pre-initialized</li> <li>Predictable memory usage</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#disadvantages_5","title":"Disadvantages","text":"<ul> <li>Increases complexity</li> <li>Can lead to resource leaks if objects aren't properly returned to the pool</li> <li>May result in stale objects if not properly managed</li> <li>Not suitable for lightweight objects</li> <li>Can cause threading issues if not implemented correctly</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#best-practices","title":"Best Practices","text":""},{"location":"design-patterns/design-patterns-creational/#general-best-practices-for-creational-patterns","title":"General Best Practices for Creational Patterns","text":"<ol> <li> <p>Choose the Right Pattern: Select the appropriate pattern based on your specific requirements and constraints.</p> </li> <li> <p>Keep It Simple: Don't over-engineer solutions. Use the simplest pattern that meets your needs.</p> </li> <li> <p>Encapsulate What Varies: Identify what aspects of your application might change, and encapsulate them.</p> </li> <li> <p>Program to Interfaces: Define interfaces or abstract classes for creators and products.</p> </li> <li> <p>Use Composition Over Inheritance: Whenever possible, prefer composition over inheritance for more flexible designs.</p> </li> <li> <p>Follow SOLID Principles: Ensure your implementations follow SOLID principles, especially Single Responsibility and Open/Closed principles.</p> </li> <li> <p>Consider Performance: For performance-critical applications, be mindful of the overhead introduced by certain patterns.</p> </li> <li> <p>Document Your Patterns: Make it clear to other developers which patterns you're using and why.</p> </li> </ol>"},{"location":"design-patterns/design-patterns-creational/#singleton-best-practices","title":"Singleton Best Practices","text":"<ul> <li>Consider using enum singletons in Java for simplicity and thread safety</li> <li>Be careful with lazy initialization in multi-threaded environments</li> <li>If using double-checked locking, ensure the instance field is volatile</li> <li>Consider using dependency injection instead of singletons for better testability</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#factory-method-best-practices","title":"Factory Method Best Practices","text":"<ul> <li>Define a clear factory method interface</li> <li>Keep the factory method focused on object creation</li> <li>Consider using parameterized factory methods for flexibility</li> <li>Use static factory methods for simple cases</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#abstract-factory-best-practices","title":"Abstract Factory Best Practices","text":"<ul> <li>Keep product families coherent and related</li> <li>Design for extensibility when adding new products</li> <li>Create comprehensive interfaces for both factories and products</li> <li>Consider using factory methods within your abstract factories</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#builder-best-practices","title":"Builder Best Practices","text":"<ul> <li>Use the fluent interface pattern for a cleaner API</li> <li>Consider making the product immutable</li> <li>Validate parameters in the build method</li> <li>Consider using a director class for complex construction processes</li> <li>Use static inner builder classes for convenience and encapsulation</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#prototype-best-practices","title":"Prototype Best Practices","text":"<ul> <li>Implement a proper deep copy mechanism for complex objects</li> <li>Consider serialization for deep copying when appropriate</li> <li>Provide a common cloning interface</li> <li>Use a prototype registry or manager for organizing and accessing prototypes</li> </ul>"},{"location":"design-patterns/design-patterns-creational/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"design-patterns/design-patterns-creational/#overusing-patterns","title":"Overusing Patterns","text":"<p>One of the most common mistakes is using design patterns when they're not needed, leading to unnecessary complexity.</p> <pre><code>// Unnecessary use of Singleton pattern for simple utility methods\npublic class MathUtils {\n    private static MathUtils instance;\n\n    private MathUtils() {}\n\n    public static MathUtils getInstance() {\n        if (instance == null) {\n            instance = new MathUtils();\n        }\n        return instance;\n    }\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n}\n\n// Better approach - use static methods\npublic class MathUtils {\n    private MathUtils() {} // Prevent instantiation\n\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#ignoring-thread-safety","title":"Ignoring Thread Safety","text":"<p>Not considering concurrency issues can lead to bugs in multi-threaded environments.</p> <pre><code>// Incorrect Singleton in multi-threaded environment\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (instance == null) { // Multiple threads might pass this check simultaneously\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// Correct thread-safe implementation\npublic class Singleton {\n    private static volatile Singleton instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#not-considering-object-lifecycle","title":"Not Considering Object Lifecycle","text":"<p>Failing to properly manage object lifecycles can lead to memory leaks or excessive resource consumption.</p> <pre><code>// Resource leaks in object pool\npublic void processItems(List&lt;Item&gt; items) {\n    DatabaseConnection connection = connectionPool.borrowObject();\n\n    for (Item item : items) {\n        try {\n            // Process item using connection\n        } catch (Exception e) {\n            // If an exception occurs, the connection is never returned!\n            logger.error(\"Error processing item\", e);\n        }\n    }\n\n    connectionPool.returnObject(connection);\n}\n\n// Better approach - ensure the resource is always returned\npublic void processItems(List&lt;Item&gt; items) {\n    DatabaseConnection connection = null;\n    try {\n        connection = connectionPool.borrowObject();\n\n        for (Item item : items) {\n            try {\n                // Process item using connection\n            } catch (Exception e) {\n                logger.error(\"Error processing item\", e);\n                // Continue processing other items\n            }\n        }\n    } finally {\n        if (connection != null) {\n            connectionPool.returnObject(connection);\n        }\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#complexity-creep","title":"Complexity Creep","text":"<p>Adding unnecessary complexity as the system evolves.</p> <pre><code>// Over-engineered factory\ninterface ProductFactory {\n    Product createProduct();\n    void registerProduct(Product product);\n    void validateProduct(Product product);\n    void initializeProduct(Product product);\n    // ... more methods that don't belong in a factory\n}\n\n// Better approach - keep factories focused\ninterface ProductFactory {\n    Product createProduct();\n}\n\n// Separate concerns into different classes\ninterface ProductRegistry {\n    void registerProduct(Product product);\n}\n\ninterface ProductValidator {\n    boolean validateProduct(Product product);\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-creational/#comparing-creational-patterns","title":"Comparing Creational Patterns","text":""},{"location":"design-patterns/design-patterns-creational/#when-to-choose-which-pattern","title":"When to Choose Which Pattern","text":"Pattern When to Use Singleton When you need exactly one instance of a class system-wide Factory Method When you want subclasses to decide which concrete classes to instantiate Abstract Factory When your system needs to use multiple related object families Builder When you need to create complex objects step by step with many optional parameters Prototype When creating new objects by copying existing ones is more efficient Object Pool When creating objects is expensive and you need to reuse them"},{"location":"design-patterns/design-patterns-creational/#comparison-of-key-characteristics","title":"Comparison of Key Characteristics","text":"Pattern Complexity Flexibility Use Case Focus Singleton Low Low Resource Management Factory Method Medium Medium Subclass Instantiation Abstract Factory High High Product Families Builder Medium High Complex Object Construction Prototype Low Medium Object Copying Object Pool Medium Low Object Reuse"},{"location":"design-patterns/design-patterns-creational/#pattern-combinations","title":"Pattern Combinations","text":"<p>Creational patterns can be combined for more powerful solutions:</p> <ol> <li>Builder + Singleton: A singleton builder that constructs complex objects.</li> <li>Factory Method + Prototype: A factory that returns clones of prototype objects.</li> <li>Abstract Factory + Builder: An abstract factory that uses builders to create complex objects.</li> <li>Object Pool + Factory Method: A factory method that draws objects from a pool.</li> </ol>"},{"location":"design-patterns/design-patterns-creational/#summary","title":"Summary","text":"<p>Creational design patterns provide solutions to object creation problems, making systems more flexible, maintainable, and decoupled:</p> <ul> <li>Singleton Pattern: Ensures a class has only one instance with global access.</li> <li>Factory Method Pattern: Lets subclasses decide which class to instantiate.</li> <li>Abstract Factory Pattern: Creates families of related objects without specifying concrete classes.</li> <li>Builder Pattern: Separates complex object construction from its representation.</li> <li>Prototype Pattern: Creates new objects by copying existing ones.</li> <li>Object Pool Pattern: Recycles and reuses objects to improve performance.</li> </ul> <p>Each pattern has its specific use cases, advantages, and disadvantages. The key to effective use of creational patterns is understanding when to apply them and how to combine them to solve specific design problems.</p> <p>By mastering these patterns, you'll be able to create more flexible, maintainable, and extensible code that follows good object-oriented design principles.</p>"},{"location":"design-patterns/design-patterns-creational/#further-reading","title":"Further Reading","text":"<ul> <li>\"Design Patterns: Elements of Reusable Object-Oriented Software\" by Gamma, Helm, Johnson, and Vlissides</li> <li>\"Head First Design Patterns\" by Eric Freeman and Elisabeth Robson</li> <li>\"Effective Java\" by Joshua Bloch</li> <li>\"Clean Code\" by Robert C. Martin</li> <li>Refactoring Guru - Design Patterns</li> <li>SourceMaking - Design Patterns</li> <li>Java Design Patterns </li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/","title":"J2EE Design Patterns","text":""},{"location":"design-patterns/design-patterns-j2ee/#overview","title":"Overview","text":"<p>J2EE (Java 2 Platform, Enterprise Edition) design patterns address common challenges in enterprise application development. These patterns provide solutions for developing robust, scalable, and maintainable enterprise applications. This guide covers essential J2EE design patterns, their implementation, use cases, advantages, and potential drawbacks in the context of modern enterprise Java development.</p>"},{"location":"design-patterns/design-patterns-j2ee/#prerequisites","title":"Prerequisites","text":"<ul> <li>Solid understanding of Java programming</li> <li>Familiarity with enterprise application concepts</li> <li>Knowledge of servlets, JSP, and EJB technologies</li> <li>Basic understanding of web application architecture</li> <li>Experience with Spring or Jakarta EE frameworks</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the purpose and benefits of J2EE design patterns</li> <li>Learn when and how to implement different J2EE patterns</li> <li>Recognize appropriate use cases for each pattern</li> <li>Implement J2EE patterns in enterprise applications</li> <li>Understand the trade-offs between different J2EE patterns</li> <li>Apply best practices when implementing J2EE patterns</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to J2EE Patterns</li> <li>MVC Pattern</li> <li>Business Delegate Pattern</li> <li>Service Locator Pattern</li> <li>Session Facade Pattern</li> <li>Data Access Object Pattern</li> <li>Front Controller Pattern</li> <li>Intercepting Filter Pattern</li> <li>Transfer Object Pattern</li> <li>Composite Entity Pattern</li> <li>Best Practices</li> <li>Common Pitfalls</li> <li>Modern Alternatives</li> </ol>"},{"location":"design-patterns/design-patterns-j2ee/#introduction-to-j2ee-patterns","title":"Introduction to J2EE Patterns","text":"<p>J2EE design patterns are used to solve common problems in enterprise Java applications. These patterns can be categorized into three main types: - Presentation tier patterns - Business tier patterns - Integration tier patterns</p>"},{"location":"design-patterns/design-patterns-j2ee/#why-use-j2ee-patterns","title":"Why Use J2EE Patterns?","text":"<ol> <li>Scalability: They help create applications that can scale to handle enterprise workloads.</li> <li>Maintainability: They promote clean code organization and separation of concerns.</li> <li>Reusability: They encourage reuse of proven solutions to common problems.</li> <li>Flexibility: They allow for easier system evolution and adaptation to changing requirements.</li> </ol>"},{"location":"design-patterns/design-patterns-j2ee/#when-to-use-j2ee-patterns","title":"When to Use J2EE Patterns","text":"<ul> <li>When building enterprise-scale applications</li> <li>When you need to ensure separation of concerns</li> <li>When you want to optimize performance in a distributed environment</li> <li>When you need to simplify complex enterprise architectures</li> <li>When you want to follow industry best practices in enterprise development</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#mvc-pattern","title":"MVC Pattern","text":"<p>Model-View-Controller (MVC) is a fundamental pattern for organizing code in web applications, separating the application into three interconnected components.</p>"},{"location":"design-patterns/design-patterns-j2ee/#intent","title":"Intent","text":"<ul> <li>Separate the application into three main components: Model, View, and Controller</li> <li>Ensure a clean separation of concerns</li> <li>Improve code organization, reusability, and maintainability</li> <li>Allow parallel development of different application aspects</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#implementation","title":"Implementation","text":"<pre><code>// Model - represents the data\npublic class UserModel {\n    private String username;\n    private String email;\n\n    public UserModel(String username, String email) {\n        this.username = username;\n        this.email = email;\n    }\n\n    // Getters and setters\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n}\n\n// View - displays the data\npublic class UserView {\n    public void displayUserDetails(String username, String email) {\n        System.out.println(\"User Details:\");\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Email: \" + email);\n    }\n}\n\n// Controller - handles the user input and updates model and view\npublic class UserController {\n    private UserModel model;\n    private UserView view;\n\n    public UserController(UserModel model, UserView view) {\n        this.model = model;\n        this.view = view;\n    }\n\n    public void setUsername(String username) {\n        model.setUsername(username);\n    }\n\n    public String getUsername() {\n        return model.getUsername();\n    }\n\n    public void setEmail(String email) {\n        model.setEmail(email);\n    }\n\n    public String getEmail() {\n        return model.getEmail();\n    }\n\n    public void updateView() {\n        view.displayUserDetails(model.getUsername(), model.getEmail());\n    }\n}\n\n// Client code\nUserModel model = new UserModel(\"john_doe\", \"john@example.com\");\nUserView view = new UserView();\nUserController controller = new UserController(model, view);\n\ncontroller.updateView(); // Display initial user details\n\n// Update model data through controller\ncontroller.setUsername(\"jane_doe\");\ncontroller.setEmail(\"jane@example.com\");\n\ncontroller.updateView(); // Display updated user details\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#spring-mvc-implementation","title":"Spring MVC Implementation","text":"<pre><code>// Model\n@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String username;\n    private String email;\n\n    // Getters and setters\n}\n\n// Controller\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/{id}\")\n    public String getUser(@PathVariable Long id, Model model) {\n        User user = userService.findById(id);\n        model.addAttribute(\"user\", user);\n        return \"user-details\"; // View name\n    }\n\n    @PostMapping\n    public String createUser(@ModelAttribute User user) {\n        userService.save(user);\n        return \"redirect:/users\";\n    }\n}\n\n// View (Thymeleaf template)\n// user-details.html\n// &lt;!DOCTYPE html&gt;\n// &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n// &lt;head&gt;\n//     &lt;title&gt;User Details&lt;/title&gt;\n// &lt;/head&gt;\n// &lt;body&gt;\n//     &lt;h1&gt;User Details&lt;/h1&gt;\n//     &lt;p th:text=\"'Username: ' + ${user.username}\"&gt;&lt;/p&gt;\n//     &lt;p th:text=\"'Email: ' + ${user.email}\"&gt;&lt;/p&gt;\n// &lt;/body&gt;\n// &lt;/html&gt;\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#when-to-use-the-mvc-pattern","title":"When to Use the MVC Pattern","text":"<ul> <li>When building web applications that need clear separation of concerns</li> <li>When multiple developers need to work on different aspects of the application</li> <li>When you want to improve code organization and maintainability</li> <li>When you need to support multiple views of the same data</li> <li>When using frameworks that implement MVC (Spring MVC, Struts, etc.)</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#advantages","title":"Advantages","text":"<ul> <li>Separation of concerns leads to more maintainable code</li> <li>Makes it easier to test individual components</li> <li>Allows parallel development of model, view, and controller</li> <li>Supports multiple views for the same model</li> <li>Follows established best practices for web application design</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#disadvantages","title":"Disadvantages","text":"<ul> <li>Can add complexity for smaller applications</li> <li>May require more code than simpler designs</li> <li>Can lead to tight coupling if not implemented correctly</li> <li>Navigation flow can be complex in large applications</li> <li>Learning curve for developers new to the pattern</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#business-delegate-pattern","title":"Business Delegate Pattern","text":"<p>The Business Delegate pattern decouples presentation and business tiers, hiding the implementation details of business services.</p>"},{"location":"design-patterns/design-patterns-j2ee/#intent_1","title":"Intent","text":"<ul> <li>Reduce coupling between presentation-tier clients and business services</li> <li>Hide the implementation details of business services including lookup and access details</li> <li>Translate network exceptions into business exceptions</li> <li>Provide a client-side abstraction for remote business services</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#implementation_1","title":"Implementation","text":"<pre><code>// Service interface\npublic interface OrderService {\n    void placeOrder(Order order);\n    Order getOrder(String orderId);\n    List&lt;Order&gt; getAllOrders();\n}\n\n// Service implementation\npublic class OrderServiceImpl implements OrderService {\n    @Override\n    public void placeOrder(Order order) {\n        System.out.println(\"Order placed: \" + order.getOrderId());\n        // Implementation details\n    }\n\n    @Override\n    public Order getOrder(String orderId) {\n        System.out.println(\"Fetching order: \" + orderId);\n        // Implementation details\n        return new Order(orderId);\n    }\n\n    @Override\n    public List&lt;Order&gt; getAllOrders() {\n        System.out.println(\"Fetching all orders\");\n        // Implementation details\n        return new ArrayList&lt;&gt;();\n    }\n}\n\n// Business delegate\npublic class OrderBusinessDelegate {\n    private OrderService orderService;\n\n    public OrderBusinessDelegate() {\n        // Could use a service locator here\n        this.orderService = new OrderServiceImpl();\n    }\n\n    public void placeOrder(Order order) {\n        try {\n            orderService.placeOrder(order);\n        } catch (Exception e) {\n            // Translate to business exception\n            throw new OrderProcessingException(\"Failed to place order\", e);\n        }\n    }\n\n    public Order getOrder(String orderId) {\n        try {\n            return orderService.getOrder(orderId);\n        } catch (Exception e) {\n            // Translate to business exception\n            throw new OrderProcessingException(\"Failed to fetch order\", e);\n        }\n    }\n\n    public List&lt;Order&gt; getAllOrders() {\n        try {\n            return orderService.getAllOrders();\n        } catch (Exception e) {\n            // Translate to business exception\n            throw new OrderProcessingException(\"Failed to fetch orders\", e);\n        }\n    }\n}\n\n// Order class\npublic class Order {\n    private String orderId;\n    private String customerName;\n    private double amount;\n\n    public Order(String orderId) {\n        this.orderId = orderId;\n    }\n\n    // Getters and setters\n    public String getOrderId() {\n        return orderId;\n    }\n\n    // Additional getters and setters\n}\n\n// Business exception\npublic class OrderProcessingException extends RuntimeException {\n    public OrderProcessingException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\n// Client code\nOrderBusinessDelegate delegate = new OrderBusinessDelegate();\nOrder order = new Order(\"ORD-001\");\ndelegate.placeOrder(order);\n\nOrder fetchedOrder = delegate.getOrder(\"ORD-001\");\nList&lt;Order&gt; allOrders = delegate.getAllOrders();\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#when-to-use-the-business-delegate-pattern","title":"When to Use the Business Delegate Pattern","text":"<ul> <li>When you need to decouple presentation tier from business services</li> <li>When you want to hide the complexity of remote service lookup and access</li> <li>When you need to translate system exceptions into business exceptions</li> <li>When building enterprise applications with multiple tiers</li> <li>When you want to minimize the impact of service API changes on client code</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#advantages_1","title":"Advantages","text":"<ul> <li>Reduces coupling between presentation and business tiers</li> <li>Hides service implementation details from clients</li> <li>Provides a simpler API for presentation-tier components</li> <li>Centralizes error handling and translation</li> <li>Makes the client code more robust against service changes</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>Adds an extra layer to the architecture</li> <li>Can introduce unnecessary complexity in simpler applications</li> <li>May become a bottleneck if not designed correctly</li> <li>Additional maintenance overhead</li> <li>May hide too many details from the client</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#service-locator-pattern","title":"Service Locator Pattern","text":"<p>The Service Locator pattern provides a centralized registry for services, eliminating the need for clients to have direct knowledge of how to obtain service references.</p>"},{"location":"design-patterns/design-patterns-j2ee/#intent_2","title":"Intent","text":"<ul> <li>Encapsulate the processes involved in obtaining a service with a strong abstraction layer</li> <li>Centralize service object lookups to facilitate decoupling</li> <li>Provide a simple interface for clients to obtain various services</li> <li>Cache services for better performance</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#implementation_2","title":"Implementation","text":"<pre><code>// Service interface\npublic interface MessagingService {\n    void sendMessage(String message);\n}\n\n// Service implementations\npublic class EmailService implements MessagingService {\n    @Override\n    public void sendMessage(String message) {\n        System.out.println(\"Sending email: \" + message);\n    }\n}\n\npublic class SMSService implements MessagingService {\n    @Override\n    public void sendMessage(String message) {\n        System.out.println(\"Sending SMS: \" + message);\n    }\n}\n\n// Service locator\npublic class ServiceLocator {\n    private static Map&lt;String, Object&gt; serviceCache = new HashMap&lt;&gt;();\n\n    public static MessagingService getMessagingService(String serviceType) {\n        // Check in cache\n        MessagingService service = (MessagingService) serviceCache.get(serviceType);\n\n        if (service != null) {\n            return service;\n        }\n\n        // If not in cache, create new instance\n        if (\"EMAIL\".equals(serviceType)) {\n            service = new EmailService();\n        } else if (\"SMS\".equals(serviceType)) {\n            service = new SMSService();\n        } else {\n            throw new IllegalArgumentException(\"Unknown service type: \" + serviceType);\n        }\n\n        // Add to cache\n        serviceCache.put(serviceType, service);\n\n        return service;\n    }\n}\n\n// Client code\nMessagingService emailService = ServiceLocator.getMessagingService(\"EMAIL\");\nemailService.sendMessage(\"Hello, this is an email message\");\n\nMessagingService smsService = ServiceLocator.getMessagingService(\"SMS\");\nsmsService.sendMessage(\"Hello, this is an SMS message\");\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#jndi-example","title":"JNDI Example","text":"<pre><code>// Service locator with JNDI\npublic class JNDIServiceLocator {\n    private InitialContext context;\n    private Map&lt;String, Object&gt; cache;\n\n    private static JNDIServiceLocator instance;\n\n    private JNDIServiceLocator() {\n        try {\n            this.context = new InitialContext();\n            this.cache = new HashMap&lt;&gt;();\n        } catch (NamingException e) {\n            throw new RuntimeException(\"Failed to initialize JNDI context\", e);\n        }\n    }\n\n    public static synchronized JNDIServiceLocator getInstance() {\n        if (instance == null) {\n            instance = new JNDIServiceLocator();\n        }\n        return instance;\n    }\n\n    public Object lookup(String jndiName) {\n        Object service = cache.get(jndiName);\n\n        if (service != null) {\n            return service;\n        }\n\n        try {\n            service = context.lookup(jndiName);\n            cache.put(jndiName, service);\n            return service;\n        } catch (NamingException e) {\n            throw new ServiceLookupException(\"Failed to lookup service: \" + jndiName, e);\n        }\n    }\n}\n\n// Usage\nDataSource dataSource = (DataSource) JNDIServiceLocator.getInstance().lookup(\"java:comp/env/jdbc/myDB\");\nConnection connection = dataSource.getConnection();\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#when-to-use-the-service-locator-pattern","title":"When to Use the Service Locator Pattern","text":"<ul> <li>When you need a centralized point for service lookup</li> <li>When you want to decouple service consumers from service implementations</li> <li>When you need to cache service references for performance</li> <li>When working with JNDI or other lookup mechanisms</li> <li>When you need to hide the complexity of service instantiation</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#advantages_2","title":"Advantages","text":"<ul> <li>Centralizes service lookup logic</li> <li>Improves performance through caching</li> <li>Decouples clients from service lookup mechanisms</li> <li>Simplifies client code</li> <li>Can be extended to support different types of services</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#disadvantages_2","title":"Disadvantages","text":"<ul> <li>Can hide dependencies (service locator anti-pattern)</li> <li>May make testing more difficult</li> <li>Violates Inversion of Control (IoC) principles</li> <li>Makes it harder to track which services are actually used</li> <li>Dependency Injection is often a better alternative in modern applications</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#data-access-object-pattern","title":"Data Access Object Pattern","text":"<p>The Data Access Object (DAO) pattern isolates the application/business layer from the persistence layer, providing an abstract interface to the database or other persistence mechanism.</p>"},{"location":"design-patterns/design-patterns-j2ee/#intent_3","title":"Intent","text":"<ul> <li>Abstract and encapsulate data access mechanisms</li> <li>Provide a uniform data access API regardless of the persistence mechanism</li> <li>Hide the complexity of data access operations</li> <li>Facilitate the use of different data sources</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#implementation_3","title":"Implementation","text":"<pre><code>// Data model\npublic class User {\n    private Long id;\n    private String username;\n    private String email;\n\n    // Constructors\n    public User() {}\n\n    public User(Long id, String username, String email) {\n        this.id = id;\n        this.username = username;\n        this.email = email;\n    }\n\n    // Getters and setters\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n}\n\n// DAO interface\npublic interface UserDao {\n    User findById(Long id);\n    List&lt;User&gt; findAll();\n    void save(User user);\n    void update(User user);\n    void delete(Long id);\n}\n\n// JDBC implementation\npublic class UserDaoJdbcImpl implements UserDao {\n    private Connection connection;\n\n    public UserDaoJdbcImpl() {\n        // Initialize connection\n        try {\n            this.connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"username\", \"password\");\n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to connect to database\", e);\n        }\n    }\n\n    @Override\n    public User findById(Long id) {\n        try {\n            PreparedStatement stmt = connection.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\n            stmt.setLong(1, id);\n            ResultSet rs = stmt.executeQuery();\n\n            if (rs.next()) {\n                User user = new User();\n                user.setId(rs.getLong(\"id\"));\n                user.setUsername(rs.getString(\"username\"));\n                user.setEmail(rs.getString(\"email\"));\n                return user;\n            }\n\n            return null;\n        } catch (SQLException e) {\n            throw new DataAccessException(\"Failed to find user by ID\", e);\n        }\n    }\n\n    @Override\n    public List&lt;User&gt; findAll() {\n        List&lt;User&gt; users = new ArrayList&lt;&gt;();\n\n        try {\n            Statement stmt = connection.createStatement();\n            ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\");\n\n            while (rs.next()) {\n                User user = new User();\n                user.setId(rs.getLong(\"id\"));\n                user.setUsername(rs.getString(\"username\"));\n                user.setEmail(rs.getString(\"email\"));\n                users.add(user);\n            }\n\n            return users;\n        } catch (SQLException e) {\n            throw new DataAccessException(\"Failed to find all users\", e);\n        }\n    }\n\n    @Override\n    public void save(User user) {\n        try {\n            PreparedStatement stmt = connection.prepareStatement(\"INSERT INTO users (username, email) VALUES (?, ?)\");\n            stmt.setString(1, user.getUsername());\n            stmt.setString(2, user.getEmail());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw new DataAccessException(\"Failed to save user\", e);\n        }\n    }\n\n    @Override\n    public void update(User user) {\n        try {\n            PreparedStatement stmt = connection.prepareStatement(\"UPDATE users SET username = ?, email = ? WHERE id = ?\");\n            stmt.setString(1, user.getUsername());\n            stmt.setString(2, user.getEmail());\n            stmt.setLong(3, user.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw new DataAccessException(\"Failed to update user\", e);\n        }\n    }\n\n    @Override\n    public void delete(Long id) {\n        try {\n            PreparedStatement stmt = connection.prepareStatement(\"DELETE FROM users WHERE id = ?\");\n            stmt.setLong(1, id);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw new DataAccessException(\"Failed to delete user\", e);\n        }\n    }\n}\n\n// Custom exception\npublic class DataAccessException extends RuntimeException {\n    public DataAccessException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\n// Client code\nUserDao userDao = new UserDaoJdbcImpl();\n\n// Create a new user\nUser newUser = new User();\nnewUser.setUsername(\"john_doe\");\nnewUser.setEmail(\"john@example.com\");\nuserDao.save(newUser);\n\n// Find a user\nUser user = userDao.findById(1L);\n\n// Update a user\nuser.setEmail(\"new_email@example.com\");\nuserDao.update(user);\n\n// Find all users\nList&lt;User&gt; allUsers = userDao.findAll();\n\n// Delete a user\nuserDao.delete(1L);\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#spring-data-jpa-example","title":"Spring Data JPA Example","text":"<pre><code>// Entity\n@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String username;\n    private String email;\n\n    // Getters and setters\n}\n\n// Repository interface\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    List&lt;User&gt; findByUsername(String username);\n    List&lt;User&gt; findByEmail(String email);\n\n    @Query(\"SELECT u FROM User u WHERE u.username LIKE %:keyword% OR u.email LIKE %:keyword%\")\n    List&lt;User&gt; search(@Param(\"keyword\") String keyword);\n}\n\n// Service layer\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    public User findById(Long id) {\n        return userRepository.findById(id)\n                .orElseThrow(() -&gt; new EntityNotFoundException(\"User not found with id: \" + id));\n    }\n\n    public List&lt;User&gt; findAll() {\n        return userRepository.findAll();\n    }\n\n    public User save(User user) {\n        return userRepository.save(user);\n    }\n\n    public void delete(Long id) {\n        userRepository.deleteById(id);\n    }\n}\n\n// Client code (Controller)\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;User&gt; getUserById(@PathVariable Long id) {\n        User user = userService.findById(id);\n        return ResponseEntity.ok(user);\n    }\n\n    @GetMapping\n    public List&lt;User&gt; getAllUsers() {\n        return userService.findAll();\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {\n        User savedUser = userService.save(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#when-to-use-the-dao-pattern","title":"When to Use the DAO Pattern","text":"<ul> <li>When you need to abstract the data access layer from the business logic</li> <li>When you want to switch between different data sources with minimal impact</li> <li>When you need to implement complex persistence logic</li> <li>When working with relational databases, NoSQL databases, or other persistence mechanisms</li> <li>When you want to centralize data access code</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#advantages_3","title":"Advantages","text":"<ul> <li>Separates data access logic from business logic</li> <li>Provides a clean interface to data access operations</li> <li>Makes it easier to switch between different data sources</li> <li>Improves testability of both business and data access logic</li> <li>Centralizes data access code for better maintenance</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#disadvantages_3","title":"Disadvantages","text":"<ul> <li>Can add complexity in simple applications</li> <li>May lead to many similar DAO implementations</li> <li>Can be redundant when using ORMs like Hibernate or JPA</li> <li>Needs careful design to avoid becoming a mere pass-through layer</li> <li>May introduce performance overhead if not implemented carefully</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#front-controller-pattern","title":"Front Controller Pattern","text":"<p>The Front Controller pattern provides a centralized entry point for handling requests in a web application.</p>"},{"location":"design-patterns/design-patterns-j2ee/#intent_4","title":"Intent","text":"<ul> <li>Provide a centralized request handling mechanism</li> <li>Manage request preprocessing, dispatching, and postprocessing</li> <li>Enforce consistent handling of all requests</li> <li>Centralize cross-cutting concerns like security and logging</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#implementation_4","title":"Implementation","text":"<pre><code>// Front controller servlet\n@WebServlet(\"/*\")\npublic class FrontControllerServlet extends HttpServlet {\n    private RequestDispatcher dispatcher;\n\n    public void init() {\n        dispatcher = new RequestDispatcher();\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        process(request, response);\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        process(request, response);\n    }\n\n    private void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Preprocess the request\n        String path = request.getRequestURI().substring(request.getContextPath().length());\n\n        // Log request\n        System.out.println(\"Request received: \" + path);\n\n        // Authenticate user (example)\n        if (!authenticate(request)) {\n            response.sendRedirect(request.getContextPath() + \"/login\");\n            return;\n        }\n\n        // Dispatch the request\n        dispatcher.dispatch(request, response, path);\n\n        // Postprocess the response\n        System.out.println(\"Request processed: \" + path);\n    }\n\n    private boolean authenticate(HttpServletRequest request) {\n        // Authentication logic\n        HttpSession session = request.getSession(false);\n        return session != null &amp;&amp; session.getAttribute(\"user\") != null;\n    }\n}\n\n// Request dispatcher\npublic class RequestDispatcher {\n    private Map&lt;String, Controller&gt; controllerMap;\n\n    public RequestDispatcher() {\n        controllerMap = new HashMap&lt;&gt;();\n        // Register controllers\n        controllerMap.put(\"/users\", new UserController());\n        controllerMap.put(\"/products\", new ProductController());\n        controllerMap.put(\"/orders\", new OrderController());\n        // Default controller\n        controllerMap.put(\"/\", new HomeController());\n    }\n\n    public void dispatch(HttpServletRequest request, HttpServletResponse response, String path) throws ServletException, IOException {\n        // Find the appropriate controller\n        Controller controller = null;\n\n        for (Map.Entry&lt;String, Controller&gt; entry : controllerMap.entrySet()) {\n            if (path.startsWith(entry.getKey())) {\n                controller = entry.getValue();\n                break;\n            }\n        }\n\n        if (controller == null) {\n            // Use default controller or show 404\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n\n        // Execute the controller\n        String view = controller.execute(request, response);\n\n        // Forward to the view\n        if (view != null) {\n            request.getRequestDispatcher(\"/WEB-INF/views/\" + view + \".jsp\").forward(request, response);\n        }\n    }\n}\n\n// Controller interface\npublic interface Controller {\n    String execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;\n}\n\n// Sample controller implementations\npublic class HomeController implements Controller {\n    @Override\n    public String execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        return \"home\";\n    }\n}\n\npublic class UserController implements Controller {\n    @Override\n    public String execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String action = request.getParameter(\"action\");\n\n        if (\"list\".equals(action)) {\n            // Get user list\n            request.setAttribute(\"users\", getUserList());\n            return \"user-list\";\n        } else if (\"view\".equals(action)) {\n            // Get user details\n            String id = request.getParameter(\"id\");\n            request.setAttribute(\"user\", getUserById(id));\n            return \"user-details\";\n        }\n\n        return \"user-list\";\n    }\n\n    private List&lt;String&gt; getUserList() {\n        // Sample data\n        return Arrays.asList(\"User 1\", \"User 2\", \"User 3\");\n    }\n\n    private String getUserById(String id) {\n        return \"User \" + id;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#spring-mvc-implementation_1","title":"Spring MVC Implementation","text":"<pre><code>// Spring MVC Front Controller is DispatcherServlet (configured in web.xml or via Java config)\n\n// Controller\n@Controller\npublic class UserController {\n    @GetMapping(\"/users\")\n    public String listUsers(Model model) {\n        model.addAttribute(\"users\", getUserList());\n        return \"user-list\";\n    }\n\n    @GetMapping(\"/users/{id}\")\n    public String viewUser(@PathVariable String id, Model model) {\n        model.addAttribute(\"user\", getUserById(id));\n        return \"user-details\";\n    }\n\n    private List&lt;String&gt; getUserList() {\n        // Sample data\n        return Arrays.asList(\"User 1\", \"User 2\", \"User 3\");\n    }\n\n    private String getUserById(String id) {\n        return \"User \" + id;\n    }\n}\n\n// Configuration\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.example.controllers\")\npublic class WebConfig implements WebMvcConfigurer {\n    @Bean\n    public ViewResolver viewResolver() {\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB-INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        return resolver;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-j2ee/#when-to-use-the-front-controller-pattern","title":"When to Use the Front Controller Pattern","text":"<ul> <li>When building web applications that need centralized request handling</li> <li>When you need consistent preprocessing of requests (e.g., security, logging)</li> <li>When you want to avoid code duplication across multiple servlets</li> <li>When implementing MVC architecture in a web application</li> <li>When using frameworks like Spring MVC that implement this pattern</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#advantages_4","title":"Advantages","text":"<ul> <li>Centralizes control logic for request handling</li> <li>Provides a single point for cross-cutting concerns</li> <li>Enforces consistent request handling</li> <li>Simplifies security implementation</li> <li>Facilitates clear separation of concerns in web applications</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#disadvantages_4","title":"Disadvantages","text":"<ul> <li>May become a bottleneck if not designed properly</li> <li>Can add complexity for simple applications</li> <li>Can become bloated if too many responsibilities are added</li> <li>Requires careful design to maintain scalability</li> <li>May introduce a learning curve for developers</li> </ul>"},{"location":"design-patterns/design-patterns-j2ee/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Understand the Problem Domain: Choose patterns that match your specific requirements and context.</p> </li> <li> <p>Avoid Overengineering: Don't use patterns just for the sake of using them. Apply them only when they add value.</p> </li> <li> <p>Combine Patterns Effectively: Many J2EE applications use multiple patterns together to solve complex problems.</p> </li> <li> <p>Consider Modern Alternatives: </p> </li> <li>Dependency Injection (DI) can replace Service Locator</li> <li>ORM frameworks can simplify the DAO pattern</li> <li> <p>RESTful services can replace some traditional J2EE patterns</p> </li> <li> <p>Documentation: Document why and how patterns are implemented in your application.</p> </li> <li> <p>Testing: Create comprehensive tests for components implementing patterns.</p> </li> <li> <p>Keep It Simple: Choose the simplest pattern that solves the problem.</p> </li> <li> <p>Consistent Implementation: Apply patterns consistently throughout the application.</p> </li> <li> <p>Consider Performance: Some patterns add overhead that may affect performance.</p> </li> <li> <p>Maintainability First: Prioritize code that is maintainable over clever implementations.</p> </li> </ol>"},{"location":"design-patterns/design-patterns-j2ee/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Pattern Overuse: Applying patterns where they're not needed increases complexity without benefits.</p> </li> <li> <p>Ignoring Modern Alternatives: Some J2EE patterns have been superseded by newer approaches.</p> </li> <li> <p>Rigid Implementation: Implementing patterns too rigidly without adapting to specific project needs.</p> </li> <li> <p>Excessive Layering: Creating too many layers can lead to \"analysis paralysis\" and over-complicated code.</p> </li> <li> <p>Premature Optimization: Implementing complex patterns for performance before it's proven necessary.</p> </li> <li> <p>Poor Documentation: Not documenting why patterns were chosen and how they're implemented.</p> </li> <li> <p>Sacrificing Simplicity: Making code complex by using patterns when simpler solutions would work.</p> </li> <li> <p>Ignoring Framework Support: Modern frameworks often provide built-in support for common patterns.</p> </li> <li> <p>Not Understanding Pattern Consequences: Each pattern has trade-offs that must be understood.</p> </li> <li> <p>Outdated Patterns: Using patterns that are no longer considered best practice.</p> </li> </ol>"},{"location":"design-patterns/design-patterns-j2ee/#modern-alternatives","title":"Modern Alternatives","text":"<ol> <li>Dependency Injection (DI) instead of Service Locator:</li> <li>Spring and CDI provide sophisticated DI capabilities</li> <li>More testable and maintainable code</li> <li> <p>Makes dependencies explicit</p> </li> <li> <p>Spring Data JPA instead of custom DAOs:</p> </li> <li>Eliminates boilerplate DAO code</li> <li>Provides repositories with powerful query methods</li> <li> <p>Offers transaction management out of the box</p> </li> <li> <p>Microservices instead of monolithic architectures:</p> </li> <li>More scalable and maintainable</li> <li>Allows for independent deployment</li> <li> <p>Better fault isolation</p> </li> <li> <p>API Gateways instead of Front Controller:</p> </li> <li>More suitable for microservices architecture</li> <li>Provides additional capabilities like rate limiting and analytics</li> <li> <p>Examples: Spring Cloud Gateway, Netflix Zuul</p> </li> <li> <p>RESTful services instead of Session Facade:</p> </li> <li>More scalable and stateless</li> <li>Better for distributed systems</li> <li> <p>Easier to consume by various clients</p> </li> <li> <p>GraphQL instead of Transfer Objects:</p> </li> <li>Clients can request exactly what they need</li> <li>Reduces over-fetching and under-fetching</li> <li> <p>More flexible than fixed DTOs</p> </li> <li> <p>Reactive programming instead of traditional request/response:</p> </li> <li>Better handling of asynchronous operations</li> <li>More efficient resource utilization</li> <li> <p>Examples: Spring WebFlux, RxJava</p> </li> <li> <p>Container orchestration instead of custom clustering:</p> </li> <li>Kubernetes provides advanced deployment, scaling, and management</li> <li>More robust and feature-rich</li> <li> <p>Industry standard approach</p> </li> <li> <p>Configuration services instead of property files:</p> </li> <li>Centralized configuration management</li> <li>Dynamic configuration updates</li> <li> <p>Examples: Spring Cloud Config Server, Consul</p> </li> <li> <p>Cloud-native patterns:</p> <ul> <li>Circuit Breaker, Bulkhead, Sidecar</li> <li>More resilient distributed systems</li> <li>Examples: Resilience4j, Istio </li> </ul> </li> </ol>"},{"location":"design-patterns/design-patterns-principles/","title":"Software Development Principles","text":""},{"location":"design-patterns/design-patterns-principles/#table-of-contents","title":"Table of Contents","text":"<ol> <li>SOLID Principles</li> <li>ACID Properties</li> <li>12-Factor Methodology</li> <li>Real-World Scenarios</li> </ol>"},{"location":"design-patterns/design-patterns-principles/#solid-principles","title":"SOLID Principles","text":""},{"location":"design-patterns/design-patterns-principles/#overview","title":"Overview","text":"<p>SOLID is an acronym for five design principles intended to make object-oriented designs more understandable, flexible, and maintainable.</p>"},{"location":"design-patterns/design-patterns-principles/#1-single-responsibility-principle-srp","title":"1. Single Responsibility Principle (SRP)","text":"<p>A class should have only one reason to change.</p> <pre><code>// Bad Example\nclass UserManager {\n    public void saveUser(User user) {\n        // Save user to database\n    }\n\n    public void sendEmail(User user) {\n        // Send email to user\n    }\n}\n\n// Good Example\nclass UserRepository {\n    public void saveUser(User user) {\n        // Save user to database\n    }\n}\n\nclass EmailService {\n    public void sendEmail(User user) {\n        // Send email to user\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#2-openclosed-principle-ocp","title":"2. Open/Closed Principle (OCP)","text":"<p>Software entities should be open for extension but closed for modification.</p> <pre><code>// Bad Example\nclass Rectangle {\n    public double width;\n    public double height;\n}\n\nclass AreaCalculator {\n    public double calculateArea(Rectangle rectangle) {\n        return rectangle.width * rectangle.height;\n    }\n    // Need to modify this class for each new shape\n}\n\n// Good Example\ninterface Shape {\n    double calculateArea();\n}\n\nclass Rectangle implements Shape {\n    private double width;\n    private double height;\n\n    @Override\n    public double calculateArea() {\n        return width * height;\n    }\n}\n\nclass Circle implements Shape {\n    private double radius;\n\n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#3-liskov-substitution-principle-lsp","title":"3. Liskov Substitution Principle (LSP)","text":"<p>Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.</p> <pre><code>// Bad Example\nclass Bird {\n    public void fly() {\n        // Flying implementation\n    }\n}\n\nclass Penguin extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Penguins can't fly\");\n    }\n}\n\n// Good Example\ninterface FlyingBird {\n    void fly();\n}\n\ninterface SwimmingBird {\n    void swim();\n}\n\nclass Sparrow implements FlyingBird {\n    @Override\n    public void fly() {\n        // Flying implementation\n    }\n}\n\nclass Penguin implements SwimmingBird {\n    @Override\n    public void swim() {\n        // Swimming implementation\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#4-interface-segregation-principle-isp","title":"4. Interface Segregation Principle (ISP)","text":"<p>Clients should not be forced to depend on interfaces they do not use.</p> <pre><code>// Bad Example\ninterface Worker {\n    void work();\n    void eat();\n    void sleep();\n}\n\n// Good Example\ninterface Workable {\n    void work();\n}\n\ninterface Eatable {\n    void eat();\n}\n\ninterface Sleepable {\n    void sleep();\n}\n\nclass Human implements Workable, Eatable, Sleepable {\n    @Override\n    public void work() {\n        // Working implementation\n    }\n\n    @Override\n    public void eat() {\n        // Eating implementation\n    }\n\n    @Override\n    public void sleep() {\n        // Sleeping implementation\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#5-dependency-inversion-principle-dip","title":"5. Dependency Inversion Principle (DIP)","text":"<p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p> <pre><code>// Bad Example\nclass EmailNotifier {\n    public void sendEmail(String message) {\n        // Send email implementation\n    }\n}\n\nclass NotificationService {\n    private EmailNotifier emailNotifier = new EmailNotifier();\n\n    public void notify(String message) {\n        emailNotifier.sendEmail(message);\n    }\n}\n\n// Good Example\ninterface NotificationSender {\n    void send(String message);\n}\n\nclass EmailNotifier implements NotificationSender {\n    @Override\n    public void send(String message) {\n        // Send email implementation\n    }\n}\n\nclass SMSNotifier implements NotificationSender {\n    @Override\n    public void send(String message) {\n        // Send SMS implementation\n    }\n}\n\nclass NotificationService {\n    private NotificationSender notificationSender;\n\n    public NotificationService(NotificationSender notificationSender) {\n        this.notificationSender = notificationSender;\n    }\n\n    public void notify(String message) {\n        notificationSender.send(message);\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#acid-properties","title":"ACID Properties","text":""},{"location":"design-patterns/design-patterns-principles/#overview_1","title":"Overview","text":"<p>ACID is an acronym that stands for Atomicity, Consistency, Isolation, and Durability. These properties ensure reliable processing of database transactions.</p>"},{"location":"design-patterns/design-patterns-principles/#1-atomicity","title":"1. Atomicity","text":"<p>A transaction must be treated as a single, indivisible unit of work. Either all operations complete successfully or none of them do.</p> <pre><code>@Transactional\npublic void transferMoney(Account from, Account to, BigDecimal amount) {\n    try {\n        from.withdraw(amount);\n        to.deposit(amount);\n    } catch (Exception e) {\n        // Transaction will be rolled back automatically\n        throw new TransactionException(\"Transfer failed\", e);\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#2-consistency","title":"2. Consistency","text":"<p>A transaction must bring the database from one valid state to another valid state, maintaining all invariants.</p> <pre><code>@Entity\npublic class BankAccount {\n    @Id\n    private Long id;\n    private BigDecimal balance;\n\n    @PreUpdate\n    public void validateBalance() {\n        if (balance.compareTo(BigDecimal.ZERO) &lt; 0) {\n            throw new IllegalStateException(\"Balance cannot be negative\");\n        }\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#3-isolation","title":"3. Isolation","text":"<p>Concurrent transactions must not affect each other. Each transaction should appear to execute in isolation.</p> <pre><code>@Transactional(isolation = Isolation.SERIALIZABLE)\npublic void updateBalance(Long accountId, BigDecimal amount) {\n    Account account = accountRepository.findById(accountId)\n        .orElseThrow(() -&gt; new AccountNotFoundException(accountId));\n    account.setBalance(account.getBalance().add(amount));\n    accountRepository.save(account);\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#4-durability","title":"4. Durability","text":"<p>Once a transaction is committed, its changes must persist even in the case of system failures.</p> <pre><code>@Service\npublic class TransactionService {\n    @Autowired\n    private TransactionRepository transactionRepository;\n\n    @Transactional\n    public void processTransaction(Transaction transaction) {\n        // Process transaction\n        transactionRepository.save(transaction);\n        // After successful commit, changes are permanent\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#12-factor-methodology","title":"12-Factor Methodology","text":""},{"location":"design-patterns/design-patterns-principles/#overview_2","title":"Overview","text":"<p>The 12-Factor methodology is a set of best practices for building modern, scalable, maintainable software-as-a-service applications.</p>"},{"location":"design-patterns/design-patterns-principles/#1-codebase","title":"1. Codebase","text":"<p>One codebase tracked in revision control, many deploys.</p> <pre><code>// Example project structure\nmy-application/\n  \u251c\u2500\u2500 .git/\n  \u251c\u2500\u2500 src/\n  \u251c\u2500\u2500 config/\n  \u251c\u2500\u2500 Dockerfile\n  \u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#2-dependencies","title":"2. Dependencies","text":"<p>Explicitly declare and isolate dependencies.</p> <pre><code>&lt;!-- pom.xml --&gt;\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;version&gt;2.7.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#3-config","title":"3. Config","text":"<p>Store config in the environment.</p> <pre><code>@Configuration\npublic class AppConfig {\n    @Value(\"${DATABASE_URL}\")\n    private String databaseUrl;\n\n    @Value(\"${API_KEY}\")\n    private String apiKey;\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#4-backing-services","title":"4. Backing Services","text":"<p>Treat backing services as attached resources.</p> <pre><code>@Configuration\npublic class DatabaseConfig {\n    @Bean\n    public DataSource dataSource() {\n        return DataSourceBuilder.create()\n            .url(System.getenv(\"DATABASE_URL\"))\n            .username(System.getenv(\"DATABASE_USER\"))\n            .password(System.getenv(\"DATABASE_PASSWORD\"))\n            .build();\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#5-build-release-run","title":"5. Build, Release, Run","text":"<p>Strictly separate build and run stages.</p> <pre><code># Dockerfile\nFROM maven:3.8.4-openjdk-17 AS build\nCOPY . .\nRUN mvn clean package\n\nFROM openjdk:17-jdk-slim\nCOPY --from=build /target/app.jar app.jar\nCMD [\"java\", \"-jar\", \"app.jar\"]\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#6-processes","title":"6. Processes","text":"<p>Execute the app as one or more stateless processes.</p> <pre><code>@RestController\n@SessionAttributes // Avoid using session state\npublic class StatelessController {\n    @GetMapping(\"/api/data\")\n    public ResponseEntity&lt;?&gt; getData(@RequestParam String id) {\n        // Process request without storing state\n        return ResponseEntity.ok(processData(id));\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#7-port-binding","title":"7. Port Binding","text":"<p>Export services via port binding.</p> <pre><code>@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n// application.properties\nserver.port=${PORT:8080}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#8-concurrency","title":"8. Concurrency","text":"<p>Scale out via the process model.</p> <pre><code>@EnableAsync\n@Configuration\npublic class AsyncConfig {\n    @Bean\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(2);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(500);\n        return executor;\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#9-disposability","title":"9. Disposability","text":"<p>Maximize robustness with fast startup and graceful shutdown.</p> <pre><code>@Component\npublic class GracefulShutdown {\n    @PreDestroy\n    public void onShutdown() {\n        // Clean up resources\n        // Close connections\n        // Finish processing\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#10-devprod-parity","title":"10. Dev/Prod Parity","text":"<p>Keep development, staging, and production as similar as possible.</p> <pre><code>@Profile(\"dev\")\n@Configuration\npublic class DevConfig {\n    // Development-specific configuration\n}\n\n@Profile(\"prod\")\n@Configuration\npublic class ProdConfig {\n    // Production-specific configuration\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#11-logs","title":"11. Logs","text":"<p>Treat logs as event streams.</p> <pre><code>@Slf4j\n@Service\npublic class LoggingService {\n    public void logEvent(String event) {\n        log.info(\"Event occurred: {}\", event);\n        // Logs are written to stdout/stderr\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#12-admin-processes","title":"12. Admin Processes","text":"<p>Run admin/management tasks as one-off processes.</p> <pre><code>@Component\npublic class DatabaseMigration {\n    @Scheduled(fixedRate = 86400000) // Run once per day\n    public void performMigration() {\n        // Execute database migration\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#real-world-scenarios","title":"Real-World Scenarios","text":""},{"location":"design-patterns/design-patterns-principles/#solid-principles-in-action","title":"SOLID Principles in Action","text":""},{"location":"design-patterns/design-patterns-principles/#1-single-responsibility-principle-srp_1","title":"1. Single Responsibility Principle (SRP)","text":"<p>Scenario: E-commerce Order Processing <pre><code>// Bad Design: OrderProcessor handling multiple responsibilities\npublic class OrderProcessor {\n    public void processOrder(Order order) {\n        // Validate order\n        validateOrder(order);\n\n        // Calculate total\n        calculateTotal(order);\n\n        // Process payment\n        processPayment(order);\n\n        // Update inventory\n        updateInventory(order);\n\n        // Send confirmation email\n        sendConfirmationEmail(order);\n\n        // Generate invoice\n        generateInvoice(order);\n    }\n}\n\n// Good Design: Separate classes for each responsibility\npublic class OrderValidator {\n    public void validateOrder(Order order) {\n        // Validate order details, stock availability, etc.\n    }\n}\n\npublic class PaymentProcessor {\n    public void processPayment(Order order) {\n        // Handle payment processing\n    }\n}\n\npublic class InventoryManager {\n    public void updateInventory(Order order) {\n        // Update product inventory\n    }\n}\n\npublic class EmailService {\n    public void sendConfirmationEmail(Order order) {\n        // Send order confirmation\n    }\n}\n\npublic class InvoiceGenerator {\n    public void generateInvoice(Order order) {\n        // Generate invoice\n    }\n}\n\n// Orchestrator\npublic class OrderService {\n    private final OrderValidator validator;\n    private final PaymentProcessor paymentProcessor;\n    private final InventoryManager inventoryManager;\n    private final EmailService emailService;\n    private final InvoiceGenerator invoiceGenerator;\n\n    public void processOrder(Order order) {\n        validator.validateOrder(order);\n        paymentProcessor.processPayment(order);\n        inventoryManager.updateInventory(order);\n        emailService.sendConfirmationEmail(order);\n        invoiceGenerator.generateInvoice(order);\n    }\n}\n</code></pre></p>"},{"location":"design-patterns/design-patterns-principles/#2-openclosed-principle-ocp_1","title":"2. Open/Closed Principle (OCP)","text":"<p>Scenario: Payment Gateway Integration <pre><code>// Bad Design: Modifying existing code for new payment methods\npublic class PaymentProcessor {\n    public void processPayment(String type, double amount) {\n        if (type.equals(\"CREDIT_CARD\")) {\n            processCreditCard(amount);\n        } else if (type.equals(\"PAYPAL\")) {\n            processPayPal(amount);\n        }\n        // Need to modify this class for each new payment method\n    }\n}\n\n// Good Design: Extensible payment processing\npublic interface PaymentMethod {\n    void processPayment(double amount);\n}\n\npublic class CreditCardPayment implements PaymentMethod {\n    @Override\n    public void processPayment(double amount) {\n        // Process credit card payment\n    }\n}\n\npublic class PayPalPayment implements PaymentMethod {\n    @Override\n    public void processPayment(double amount) {\n        // Process PayPal payment\n    }\n}\n\npublic class CryptoPayment implements PaymentMethod {\n    @Override\n    public void processPayment(double amount) {\n        // Process cryptocurrency payment\n    }\n}\n\npublic class PaymentProcessor {\n    public void processPayment(PaymentMethod paymentMethod, double amount) {\n        paymentMethod.processPayment(amount);\n    }\n}\n</code></pre></p>"},{"location":"design-patterns/design-patterns-principles/#3-liskov-substitution-principle-lsp_1","title":"3. Liskov Substitution Principle (LSP)","text":"<p>Scenario: Document Processing System <pre><code>// Bad Design: Breaking LSP\npublic abstract class Document {\n    abstract void save();\n    abstract void print();\n}\n\npublic class PDFDocument extends Document {\n    @Override\n    void save() {\n        // Save PDF\n    }\n\n    @Override\n    void print() {\n        // Print PDF\n    }\n}\n\npublic class ReadOnlyDocument extends Document {\n    @Override\n    void save() {\n        throw new UnsupportedOperationException(\"Cannot save read-only document\");\n    }\n\n    @Override\n    void print() {\n        // Print document\n    }\n}\n\n// Good Design: Proper abstraction\npublic interface Printable {\n    void print();\n}\n\npublic interface Saveable {\n    void save();\n}\n\npublic class PDFDocument implements Printable, Saveable {\n    @Override\n    public void print() {\n        // Print PDF\n    }\n\n    @Override\n    public void save() {\n        // Save PDF\n    }\n}\n\npublic class ReadOnlyDocument implements Printable {\n    @Override\n    public void print() {\n        // Print document\n    }\n}\n</code></pre></p>"},{"location":"design-patterns/design-patterns-principles/#acid-properties-in-action","title":"ACID Properties in Action","text":""},{"location":"design-patterns/design-patterns-principles/#real-world-banking-scenario","title":"Real-World Banking Scenario","text":"<pre><code>@Service\n@Transactional\npublic class BankingService {\n    @Autowired\n    private AccountRepository accountRepository;\n\n    @Autowired\n    private TransactionRepository transactionRepository;\n\n    // Atomicity Example: Fund Transfer\n    public void transferFunds(Long fromAccountId, Long toAccountId, BigDecimal amount) {\n        Account fromAccount = accountRepository.findById(fromAccountId)\n            .orElseThrow(() -&gt; new AccountNotFoundException(fromAccountId));\n        Account toAccount = accountRepository.findById(toAccountId)\n            .orElseThrow(() -&gt; new AccountNotFoundException(toAccountId));\n\n        // Both operations must succeed or both must fail\n        fromAccount.withdraw(amount);\n        toAccount.deposit(amount);\n\n        accountRepository.save(fromAccount);\n        accountRepository.save(toAccount);\n\n        // Record transaction\n        Transaction transaction = new Transaction(fromAccount, toAccount, amount);\n        transactionRepository.save(transaction);\n    }\n\n    // Consistency Example: Account Balance Check\n    @PreUpdate\n    @PrePersist\n    public void validateAccountState(Account account) {\n        if (account.getBalance().compareTo(BigDecimal.ZERO) &lt; 0 &amp;&amp; \n            !account.isOverdraftAllowed()) {\n            throw new InsufficientFundsException(\"Negative balance not allowed\");\n        }\n    }\n\n    // Isolation Example: Concurrent Withdrawals\n    @Transactional(isolation = Isolation.SERIALIZABLE)\n    public void processLargeWithdrawal(Long accountId, BigDecimal amount) {\n        Account account = accountRepository.findById(accountId)\n            .orElseThrow(() -&gt; new AccountNotFoundException(accountId));\n\n        if (account.getBalance().compareTo(amount) &lt; 0) {\n            throw new InsufficientFundsException(\"Insufficient funds\");\n        }\n\n        account.withdraw(amount);\n        accountRepository.save(account);\n    }\n\n    // Durability Example: Transaction Logging\n    public void logTransaction(Transaction transaction) {\n        // First, persist to database\n        transactionRepository.save(transaction);\n\n        // Then, write to audit log\n        auditLogger.logTransaction(transaction);\n\n        // Finally, notify monitoring system\n        monitoringService.notifyTransactionProcessed(transaction);\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#12-factor-methodology-in-action","title":"12-Factor Methodology in Action","text":""},{"location":"design-patterns/design-patterns-principles/#real-world-microservice-example","title":"Real-World Microservice Example","text":"<pre><code>// 1. Codebase - Version-controlled microservice\n@SpringBootApplication\npublic class PaymentServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentServiceApplication.class, args);\n    }\n}\n\n// 2. Dependencies - Explicit dependencies in build file\n// build.gradle\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web:2.7.0'\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa:2.7.0'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client:3.1.0'\n}\n\n// 3. Config - Environment-based configuration\n@Configuration\npublic class PaymentConfig {\n    @Value(\"${STRIPE_API_KEY}\")\n    private String stripeApiKey;\n\n    @Value(\"${PAYMENT_PROCESSING_TIMEOUT}\")\n    private int processingTimeout;\n\n    @Bean\n    public Stripe stripeClient() {\n        return new Stripe(stripeApiKey);\n    }\n}\n\n// 4. Backing Services - Database and external service configuration\n@Configuration\npublic class DatabaseConfig {\n    @Bean\n    public DataSource dataSource() {\n        return DataSourceBuilder.create()\n            .url(System.getenv(\"DATABASE_URL\"))\n            .username(System.getenv(\"DATABASE_USER\"))\n            .password(System.getenv(\"DATABASE_PASSWORD\"))\n            .build();\n    }\n}\n\n// 5. Build, Release, Run - Containerized deployment\n// Dockerfile\nFROM gradle:7.4.2-jdk17 AS build\nCOPY --chown=gradle:gradle . /home/gradle/src\nWORKDIR /home/gradle/src\nRUN gradle build --no-daemon\n\nFROM openjdk:17-slim\nCOPY --from=build /home/gradle/src/build/libs/*.jar app.jar\nENTRYPOINT [\"java\", \"-jar\", \"/app.jar\"]\n\n// 6. Processes - Stateless service\n@RestController\n@RequestMapping(\"/api/payments\")\npublic class PaymentController {\n    @Autowired\n    private PaymentService paymentService;\n\n    @PostMapping\n    public ResponseEntity&lt;PaymentResponse&gt; processPayment(\n            @RequestBody PaymentRequest request) {\n        return ResponseEntity.ok(paymentService.processPayment(request));\n    }\n}\n\n// 7. Port Binding - Self-contained service\nserver.port=${PORT:8080}\nspring.application.name=payment-service\n\n// 8. Concurrency - Scalable processing\n@Service\npublic class PaymentProcessor {\n    @Async\n    public CompletableFuture&lt;PaymentResult&gt; processPaymentAsync(\n            Payment payment) {\n        return CompletableFuture.supplyAsync(() -&gt; {\n            // Process payment\n            return new PaymentResult();\n        });\n    }\n}\n\n// 9. Disposability - Graceful shutdown\n@Component\npublic class PaymentServiceShutdown {\n    @PreDestroy\n    public void onShutdown() {\n        // Complete pending transactions\n        // Close database connections\n        // Clean up resources\n    }\n}\n\n// 10. Dev/Prod Parity - Environment-specific configurations\n@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    @Bean\n    public PaymentGateway paymentGateway() {\n        return new MockPaymentGateway();\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfig {\n    @Bean\n    public PaymentGateway paymentGateway() {\n        return new StripePaymentGateway();\n    }\n}\n\n// 11. Logs - Centralized logging\n@Aspect\n@Component\npublic class PaymentLogging {\n    private static final Logger logger = \n        LoggerFactory.getLogger(PaymentLogging.class);\n\n    @Around(\"execution(* com.example.payment.service.*.*(..))\")\n    public Object logPaymentOperation(ProceedingJoinPoint joinPoint) \n            throws Throwable {\n        logger.info(\"Payment operation started: {}\", \n            joinPoint.getSignature().getName());\n        try {\n            Object result = joinPoint.proceed();\n            logger.info(\"Payment operation completed successfully\");\n            return result;\n        } catch (Exception e) {\n            logger.error(\"Payment operation failed\", e);\n            throw e;\n        }\n    }\n}\n\n// 12. Admin Processes - Maintenance tasks\n@Component\npublic class PaymentMaintenanceTasks {\n    @Scheduled(cron = \"0 0 2 * * *\") // Run at 2 AM daily\n    public void cleanupFailedPayments() {\n        // Clean up failed payments\n    }\n\n    @Scheduled(cron = \"0 0 0 * * 0\") // Run weekly\n    public void generatePaymentReports() {\n        // Generate weekly payment reports\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-principles/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Follow SOLID principles for maintainable object-oriented design</li> <li>Ensure ACID properties in database transactions</li> <li>Apply 12-factor methodology for modern application development</li> <li>Use appropriate tools and frameworks that support these principles</li> <li>Regularly review and refactor code to maintain adherence to these principles</li> <li>Document decisions and trade-offs when deviating from these principles</li> <li>Train team members on these principles and their practical applications </li> </ol>"},{"location":"design-patterns/design-patterns-structural/","title":"Structural Design Patterns","text":""},{"location":"design-patterns/design-patterns-structural/#overview","title":"Overview","text":"<p>Structural design patterns are concerned with how classes and objects are composed to form larger structures. They help ensure that when parts of a system change, the entire system doesn't need to change. This guide covers essential structural design patterns in Java, their implementation, use cases, advantages, and potential drawbacks.</p>"},{"location":"design-patterns/design-patterns-structural/#prerequisites","title":"Prerequisites","text":"<ul> <li>Solid understanding of Java programming</li> <li>Familiarity with object-oriented programming concepts</li> <li>Basic knowledge of SOLID principles</li> <li>Understanding of class inheritance and interfaces</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the purpose and benefits of structural design patterns</li> <li>Learn when and how to implement different structural patterns</li> <li>Recognize appropriate use cases for each pattern</li> <li>Implement structural patterns in Java applications</li> <li>Understand the trade-offs between different structural patterns</li> <li>Apply best practices when implementing structural patterns</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Structural Patterns</li> <li>Adapter Pattern</li> <li>Bridge Pattern</li> <li>Composite Pattern</li> <li>Decorator Pattern</li> <li>Facade Pattern</li> <li>Flyweight Pattern</li> <li>Proxy Pattern</li> <li>Best Practices</li> <li>Common Pitfalls</li> <li>Comparing Structural Patterns</li> </ol>"},{"location":"design-patterns/design-patterns-structural/#introduction-to-structural-patterns","title":"Introduction to Structural Patterns","text":"<p>Structural design patterns deal with object composition, creating relationships between objects to form larger structures. They help to ensure that if one part of a system changes, the entire system doesn't need to change along with it.</p>"},{"location":"design-patterns/design-patterns-structural/#why-use-structural-patterns","title":"Why Use Structural Patterns?","text":"<ol> <li>Flexibility: They provide flexibility in how objects and classes are composed together.</li> <li>Decoupling: They promote loose coupling between different components.</li> <li>Simplification: They simplify complex structures by providing abstractions.</li> <li>Adaptability: They make it easier to adapt objects to work with different interfaces.</li> </ol>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-structural-patterns","title":"When to Use Structural Patterns","text":"<ul> <li>When you need to organize objects into larger structures</li> <li>When you need to make incompatible interfaces work together</li> <li>When you want to add responsibilities to objects without changing their code</li> <li>When you need to simplify complex subsystems</li> <li>When you want to optimize resource usage with many similar objects</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#adapter-pattern","title":"Adapter Pattern","text":"<p>The Adapter pattern converts the interface of a class into another interface clients expect, allowing classes to work together that couldn't otherwise due to incompatible interfaces.</p>"},{"location":"design-patterns/design-patterns-structural/#intent","title":"Intent","text":"<ul> <li>Convert the interface of a class into another interface clients expect</li> <li>Allow classes to work together that couldn't otherwise due to incompatible interfaces</li> <li>Make existing classes work with others without modifying their source code</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#implementation","title":"Implementation","text":""},{"location":"design-patterns/design-patterns-structural/#object-adapter-composition","title":"Object Adapter (Composition)","text":"<pre><code>// Target interface that the client expects to use\ninterface MediaPlayer {\n    void play(String audioType, String fileName);\n}\n\n// Adaptee interface - the interface that needs adapting\ninterface AdvancedMediaPlayer {\n    void playVlc(String fileName);\n    void playMp4(String fileName);\n}\n\n// Concrete Adaptee implementations\nclass VlcPlayer implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        System.out.println(\"Playing vlc file: \" + fileName);\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        // Do nothing\n    }\n}\n\nclass Mp4Player implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        // Do nothing\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        System.out.println(\"Playing mp4 file: \" + fileName);\n    }\n}\n\n// Adapter using composition\nclass MediaAdapter implements MediaPlayer {\n    private AdvancedMediaPlayer advancedMediaPlayer;\n\n    public MediaAdapter(String audioType) {\n        if (audioType.equalsIgnoreCase(\"vlc\")) {\n            advancedMediaPlayer = new VlcPlayer();\n        } else if (audioType.equalsIgnoreCase(\"mp4\")) {\n            advancedMediaPlayer = new Mp4Player();\n        }\n    }\n\n    @Override\n    public void play(String audioType, String fileName) {\n        if (audioType.equalsIgnoreCase(\"vlc\")) {\n            advancedMediaPlayer.playVlc(fileName);\n        } else if (audioType.equalsIgnoreCase(\"mp4\")) {\n            advancedMediaPlayer.playMp4(fileName);\n        }\n    }\n}\n\n// Client\nclass AudioPlayer implements MediaPlayer {\n    private MediaAdapter mediaAdapter;\n\n    @Override\n    public void play(String audioType, String fileName) {\n        // Built-in support for mp3 files\n        if (audioType.equalsIgnoreCase(\"mp3\")) {\n            System.out.println(\"Playing mp3 file: \" + fileName);\n        }\n        // MediaAdapter provides support for other formats\n        else if (audioType.equalsIgnoreCase(\"vlc\") || audioType.equalsIgnoreCase(\"mp4\")) {\n            mediaAdapter = new MediaAdapter(audioType);\n            mediaAdapter.play(audioType, fileName);\n        } else {\n            System.out.println(\"Invalid media. \" + audioType + \" format not supported\");\n        }\n    }\n}\n\n// Usage\nMediaPlayer player = new AudioPlayer();\nplayer.play(\"mp3\", \"song.mp3\");    // Playing mp3 file: song.mp3\nplayer.play(\"vlc\", \"movie.vlc\");   // Playing vlc file: movie.vlc\nplayer.play(\"mp4\", \"video.mp4\");   // Playing mp4 file: video.mp4\nplayer.play(\"avi\", \"video.avi\");   // Invalid media. avi format not supported\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#class-adapter-inheritance","title":"Class Adapter (Inheritance)","text":"<pre><code>// Target\ninterface Target {\n    void request();\n}\n\n// Adaptee\nclass Adaptee {\n    public void specificRequest() {\n        System.out.println(\"Specific request from Adaptee\");\n    }\n}\n\n// Class Adapter using inheritance\nclass ClassAdapter extends Adaptee implements Target {\n    @Override\n    public void request() {\n        specificRequest();\n    }\n}\n\n// Usage\nTarget target = new ClassAdapter();\ntarget.request(); // Outputs: Specific request from Adaptee\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#real-world-example-legacy-system-integration","title":"Real-World Example: Legacy System Integration","text":"<pre><code>// Legacy database system\nclass LegacyDatabase {\n    public void connect() {\n        System.out.println(\"Connected to legacy database\");\n    }\n\n    public void executeQuery(String rawSql) {\n        System.out.println(\"Executing raw SQL: \" + rawSql);\n    }\n\n    public void disconnect() {\n        System.out.println(\"Disconnected from legacy database\");\n    }\n}\n\n// Modern database interface expected by the application\ninterface ModernDatabase {\n    void openConnection();\n    void queryData(String tableName, String[] columns, String condition);\n    void closeConnection();\n}\n\n// Adapter for the legacy database system\nclass DatabaseAdapter implements ModernDatabase {\n    private LegacyDatabase legacyDb = new LegacyDatabase();\n\n    @Override\n    public void openConnection() {\n        legacyDb.connect();\n    }\n\n    @Override\n    public void queryData(String tableName, String[] columns, String condition) {\n        StringBuilder sql = new StringBuilder(\"SELECT \");\n\n        if (columns.length &gt; 0) {\n            for (int i = 0; i &lt; columns.length; i++) {\n                sql.append(columns[i]);\n                if (i &lt; columns.length - 1) {\n                    sql.append(\", \");\n                }\n            }\n        } else {\n            sql.append(\"*\");\n        }\n\n        sql.append(\" FROM \").append(tableName);\n\n        if (condition != null &amp;&amp; !condition.isEmpty()) {\n            sql.append(\" WHERE \").append(condition);\n        }\n\n        legacyDb.executeQuery(sql.toString());\n    }\n\n    @Override\n    public void closeConnection() {\n        legacyDb.disconnect();\n    }\n}\n\n// Usage\nModernDatabase db = new DatabaseAdapter();\ndb.openConnection();\ndb.queryData(\"users\", new String[]{\"id\", \"name\", \"email\"}, \"active = true\");\ndb.closeConnection();\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#two-way-adapter","title":"Two-Way Adapter","text":"<pre><code>// Interface A\ninterface SquarePeg {\n    void insert();\n}\n\n// Interface B\ninterface RoundPeg {\n    void insertIntoHole();\n}\n\n// Two-way adapter implementing both interfaces\nclass PegAdapter implements SquarePeg, RoundPeg {\n    @Override\n    public void insert() {\n        System.out.println(\"Square peg inserted\");\n        // Can call insertIntoHole() if needed\n    }\n\n    @Override\n    public void insertIntoHole() {\n        System.out.println(\"Round peg inserted into hole\");\n        // Can call insert() if needed\n    }\n}\n\n// Usage\nSquarePeg squarePeg = new PegAdapter();\nsquarePeg.insert();\n\nRoundPeg roundPeg = (RoundPeg) squarePeg; // Same object, different interface\nroundPeg.insertIntoHole();\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-the-adapter-pattern","title":"When to Use the Adapter Pattern","text":"<ul> <li>When you want to use an existing class, but its interface does not match the one you need</li> <li>When you want to create a reusable class that cooperates with classes that don't necessarily have compatible interfaces</li> <li>When you need to use several existing subclasses but don't want to adapt their interfaces by subclassing each one</li> <li>When you want to make your code work with third-party libraries</li> <li>When you want to integrate legacy code with modern code without changing the legacy implementation</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#advantages","title":"Advantages","text":"<ul> <li>Allows incompatible interfaces to work together</li> <li>Promotes reusability of existing code</li> <li>Improves maintainability by separating client code from adapted code</li> <li>Enables interoperability between different systems</li> <li>Single Responsibility Principle: separates interface conversion from the business logic</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#disadvantages","title":"Disadvantages","text":"<ul> <li>Increases complexity by adding an extra layer</li> <li>Sometimes overused when a simple refactoring would be better</li> <li>In class adapters, can only adapt to one class (due to Java's single inheritance)</li> <li>Debugging can be harder due to the extra indirection</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#bridge-pattern","title":"Bridge Pattern","text":"<p>The Bridge pattern decouples an abstraction from its implementation so that the two can vary independently. It involves an interface acting as a bridge between the abstract class and implementation classes.</p>"},{"location":"design-patterns/design-patterns-structural/#intent_1","title":"Intent","text":"<ul> <li>Decouple an abstraction from its implementation so that the two can vary independently</li> <li>Avoid permanent binding between an abstraction and its implementation</li> <li>Allow both the abstraction and its implementation to be extended through inheritance</li> <li>Hide implementation details from clients</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#implementation_1","title":"Implementation","text":"<pre><code>// Implementor interface\ninterface DrawAPI {\n    void drawCircle(double x, double y, double radius);\n}\n\n// Concrete Implementors\nclass RedCircle implements DrawAPI {\n    @Override\n    public void drawCircle(double x, double y, double radius) {\n        System.out.printf(\"Drawing Circle[ color: red, center: (%f, %f), radius: %f ]%n\", x, y, radius);\n    }\n}\n\nclass GreenCircle implements DrawAPI {\n    @Override\n    public void drawCircle(double x, double y, double radius) {\n        System.out.printf(\"Drawing Circle[ color: green, center: (%f, %f), radius: %f ]%n\", x, y, radius);\n    }\n}\n\n// Abstraction\nabstract class Shape {\n    protected DrawAPI drawAPI;\n\n    protected Shape(DrawAPI drawAPI) {\n        this.drawAPI = drawAPI;\n    }\n\n    public abstract void draw();\n}\n\n// Refined Abstraction\nclass Circle extends Shape {\n    private double x, y, radius;\n\n    public Circle(double x, double y, double radius, DrawAPI drawAPI) {\n        super(drawAPI);\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    @Override\n    public void draw() {\n        drawAPI.drawCircle(x, y, radius);\n    }\n}\n\n// Usage\nDrawAPI redCircle = new RedCircle();\nDrawAPI greenCircle = new GreenCircle();\n\nShape redCircleShape = new Circle(100, 100, 10, redCircle);\nShape greenCircleShape = new Circle(200, 200, 15, greenCircle);\n\nredCircleShape.draw();   // Drawing Circle[ color: red, center: (100.000000, 100.000000), radius: 10.000000 ]\ngreenCircleShape.draw(); // Drawing Circle[ color: green, center: (200.000000, 200.000000), radius: 15.000000 ]\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#extended-example-messaging-system","title":"Extended Example: Messaging System","text":"<pre><code>// Implementor interface\ninterface MessageSender {\n    void sendMessage(String message, String recipient);\n}\n\n// Concrete Implementors\nclass EmailSender implements MessageSender {\n    @Override\n    public void sendMessage(String message, String recipient) {\n        System.out.println(\"Sending Email to \" + recipient + \": \" + message);\n    }\n}\n\nclass SMSSender implements MessageSender {\n    @Override\n    public void sendMessage(String message, String recipient) {\n        System.out.println(\"Sending SMS to \" + recipient + \": \" + message);\n    }\n}\n\nclass WhatsAppSender implements MessageSender {\n    @Override\n    public void sendMessage(String message, String recipient) {\n        System.out.println(\"Sending WhatsApp message to \" + recipient + \": \" + message);\n    }\n}\n\n// Abstraction\nabstract class Message {\n    protected MessageSender messageSender;\n\n    protected Message(MessageSender messageSender) {\n        this.messageSender = messageSender;\n    }\n\n    public abstract void send();\n}\n\n// Refined Abstractions\nclass TextMessage extends Message {\n    private String text;\n    private String recipient;\n\n    public TextMessage(String text, String recipient, MessageSender messageSender) {\n        super(messageSender);\n        this.text = text;\n        this.recipient = recipient;\n    }\n\n    @Override\n    public void send() {\n        messageSender.sendMessage(text, recipient);\n    }\n}\n\nclass UrgentMessage extends Message {\n    private String text;\n    private String recipient;\n\n    public UrgentMessage(String text, String recipient, MessageSender messageSender) {\n        super(messageSender);\n        this.text = text;\n        this.recipient = recipient;\n    }\n\n    @Override\n    public void send() {\n        messageSender.sendMessage(\"URGENT: \" + text, recipient);\n    }\n}\n\n// Usage\nMessageSender emailSender = new EmailSender();\nMessageSender smsSender = new SMSSender();\nMessageSender whatsAppSender = new WhatsAppSender();\n\nMessage textEmailMessage = new TextMessage(\"Hello, how are you?\", \"john@example.com\", emailSender);\nMessage urgentSmsMessage = new UrgentMessage(\"Meeting in 10 minutes!\", \"123-456-7890\", smsSender);\nMessage urgentWhatsAppMessage = new UrgentMessage(\"Call me back ASAP\", \"+1-234-567-8901\", whatsAppSender);\n\ntextEmailMessage.send();      // Sending Email to john@example.com: Hello, how are you?\nurgentSmsMessage.send();      // Sending SMS to 123-456-7890: URGENT: Meeting in 10 minutes!\nurgentWhatsAppMessage.send(); // Sending WhatsApp message to +1-234-567-8901: URGENT: Call me back ASAP\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-the-bridge-pattern","title":"When to Use the Bridge Pattern","text":"<ul> <li>When you want to avoid a permanent binding between an abstraction and its implementation</li> <li>When both the abstraction and its implementation should be extensible through subclasses</li> <li>When changes in the implementation should not impact the client code</li> <li>When you have a proliferation of classes resulting from a coupled interface and numerous implementations</li> <li>When you want to share an implementation among multiple objects</li> <li>When you want to hide implementation details completely from clients</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#advantages_1","title":"Advantages","text":"<ul> <li>Decouples interface from implementation</li> <li>Improves extensibility (you can extend the abstraction and implementation hierarchies independently)</li> <li>Hides implementation details from clients</li> <li>Allows for dynamic switching of implementations at runtime</li> <li>Follows Open/Closed Principle by allowing new abstractions and implementations to be added separately</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>Increases complexity due to additional indirection</li> <li>Can be overkill for simple applications</li> <li>Requires designing the proper abstractions up front</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#composite-pattern","title":"Composite Pattern","text":"<p>The Composite pattern composes objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly.</p>"},{"location":"design-patterns/design-patterns-structural/#intent_2","title":"Intent","text":"<ul> <li>Compose objects into tree structures to represent part-whole hierarchies</li> <li>Allow clients to treat individual objects and compositions of objects uniformly</li> <li>Make it easy to add new kinds of components</li> <li>Create recursive tree structures with composite and leaf nodes</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#implementation_2","title":"Implementation","text":"<pre><code>// Component interface\ninterface Component {\n    void operation();\n    void add(Component component);\n    void remove(Component component);\n    Component getChild(int index);\n}\n\n// Leaf class\nclass Leaf implements Component {\n    private String name;\n\n    public Leaf(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void operation() {\n        System.out.println(\"Leaf \" + name + \": operation\");\n    }\n\n    @Override\n    public void add(Component component) {\n        // Leaf nodes cannot have children\n        throw new UnsupportedOperationException(\"Cannot add to a leaf\");\n    }\n\n    @Override\n    public void remove(Component component) {\n        // Leaf nodes cannot have children\n        throw new UnsupportedOperationException(\"Cannot remove from a leaf\");\n    }\n\n    @Override\n    public Component getChild(int index) {\n        // Leaf nodes cannot have children\n        throw new UnsupportedOperationException(\"Cannot get child from a leaf\");\n    }\n}\n\n// Composite class\nclass Composite implements Component {\n    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();\n    private String name;\n\n    public Composite(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void operation() {\n        System.out.println(\"Composite \" + name + \": operation\");\n        // Operation on all children\n        for (Component component : children) {\n            component.operation();\n        }\n    }\n\n    @Override\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    @Override\n    public Component getChild(int index) {\n        return children.get(index);\n    }\n}\n\n// Usage\nComponent leaf1 = new Leaf(\"A\");\nComponent leaf2 = new Leaf(\"B\");\nComponent leaf3 = new Leaf(\"C\");\n\nComponent composite1 = new Composite(\"X\");\ncomposite1.add(leaf1);\ncomposite1.add(leaf2);\n\nComponent composite2 = new Composite(\"Y\");\ncomposite2.add(leaf3);\ncomposite2.add(composite1);\n\n// Treat composite and leaf uniformly\ncomposite2.operation();\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#file-system-example","title":"File System Example","text":"<pre><code>// Component\nabstract class FileSystemComponent {\n    protected String name;\n    protected int size;\n\n    public FileSystemComponent(String name, int size) {\n        this.name = name;\n        this.size = size;\n    }\n\n    public abstract int getSize();\n    public abstract void printStructure(String indent);\n\n    public String getName() {\n        return name;\n    }\n}\n\n// Leaf\nclass File extends FileSystemComponent {\n    public File(String name, int size) {\n        super(name, size);\n    }\n\n    @Override\n    public int getSize() {\n        return size;\n    }\n\n    @Override\n    public void printStructure(String indent) {\n        System.out.println(indent + \"File: \" + name + \" (\" + size + \" KB)\");\n    }\n}\n\n// Composite\nclass Directory extends FileSystemComponent {\n    private List&lt;FileSystemComponent&gt; children = new ArrayList&lt;&gt;();\n\n    public Directory(String name) {\n        super(name, 0);\n    }\n\n    public void addComponent(FileSystemComponent component) {\n        children.add(component);\n    }\n\n    public void removeComponent(FileSystemComponent component) {\n        children.remove(component);\n    }\n\n    @Override\n    public int getSize() {\n        int totalSize = 0;\n        for (FileSystemComponent component : children) {\n            totalSize += component.getSize();\n        }\n        return totalSize;\n    }\n\n    @Override\n    public void printStructure(String indent) {\n        System.out.println(indent + \"Directory: \" + name + \" (\" + getSize() + \" KB)\");\n        for (FileSystemComponent component : children) {\n            component.printStructure(indent + \"  \");\n        }\n    }\n}\n\n// Usage\nFile file1 = new File(\"file1.txt\", 5);\nFile file2 = new File(\"file2.txt\", 10);\nFile file3 = new File(\"file3.txt\", 7);\nFile file4 = new File(\"file4.txt\", 20);\n\nDirectory dir1 = new Directory(\"docs\");\ndir1.addComponent(file1);\ndir1.addComponent(file2);\n\nDirectory dir2 = new Directory(\"images\");\ndir2.addComponent(file3);\n\nDirectory root = new Directory(\"root\");\nroot.addComponent(dir1);\nroot.addComponent(dir2);\nroot.addComponent(file4);\n\n// Print structure and size\nroot.printStructure(\"\");\nSystem.out.println(\"Total size: \" + root.getSize() + \" KB\");\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#transparency-vs-safety","title":"Transparency vs. Safety","text":"<p>There are two approaches to implementing the Composite pattern:</p>"},{"location":"design-patterns/design-patterns-structural/#transparent-approach-as-shown-above","title":"Transparent Approach (as shown above)","text":"<ul> <li>Component declares all operations (both leaf and composite)</li> <li>Client can treat all objects uniformly</li> <li>Type safety is sacrificed (leaf nodes throw exceptions for composite operations)</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#safe-approach","title":"Safe Approach","text":"<pre><code>// Component interface with only common operations\ninterface Component {\n    void operation();\n}\n\n// Leaf class\nclass Leaf implements Component {\n    private String name;\n\n    public Leaf(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void operation() {\n        System.out.println(\"Leaf \" + name + \": operation\");\n    }\n}\n\n// Composite class with additional methods\nclass Composite implements Component {\n    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();\n    private String name;\n\n    public Composite(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void operation() {\n        System.out.println(\"Composite \" + name + \": operation\");\n        for (Component component : children) {\n            component.operation();\n        }\n    }\n\n    // Composite-specific methods\n    public void add(Component component) {\n        children.add(component);\n    }\n\n    public void remove(Component component) {\n        children.remove(component);\n    }\n\n    public Component getChild(int index) {\n        return children.get(index);\n    }\n}\n\n// Usage requires type checking for Composite operations\nComponent component = getComponent(); // Some method that returns a Component\nif (component instanceof Composite) {\n    Composite composite = (Composite) component;\n    composite.add(new Leaf(\"New Leaf\"));\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-the-composite-pattern","title":"When to Use the Composite Pattern","text":"<ul> <li>When you want to represent part-whole hierarchies of objects</li> <li>When you want clients to be able to ignore the difference between compositions of objects and individual objects</li> <li>When the structure can have any level of complexity</li> <li>When you want the client code to work with all objects in the hierarchy uniformly</li> <li>When you're dealing with tree-structured data</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#advantages_2","title":"Advantages","text":"<ul> <li>Defines class hierarchies containing primitive and complex objects</li> <li>Makes it easier to add new types of components</li> <li>Provides flexibility of structure with manageable components</li> <li>Simplifies client code by allowing it to treat complex and individual objects uniformly</li> <li>Follows the Open/Closed Principle by allowing new components to be added without changing existing code</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#disadvantages_2","title":"Disadvantages","text":"<ul> <li>Can make the design overly general, making it harder to restrict certain components</li> <li>Can be difficult to provide a common interface for classes whose functionality differs widely</li> <li>In the transparent approach, type safety is sacrificed</li> <li>Difficult to restrict components of a particular composite to only particular types</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#decorator-pattern","title":"Decorator Pattern","text":"<p>The Decorator pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p>"},{"location":"design-patterns/design-patterns-structural/#intent_3","title":"Intent","text":"<ul> <li>Add responsibilities to individual objects dynamically and transparently</li> <li>Provide an alternative to subclassing for extending functionality</li> <li>Support the Open/Closed Principle by allowing functionality to be added without modifying existing code</li> <li>Allow responsibilities to be added and removed at runtime</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#implementation_3","title":"Implementation","text":"<pre><code>// Component interface\ninterface Component {\n    void operation();\n}\n\n// Concrete Component\nclass ConcreteComponent implements Component {\n    @Override\n    public void operation() {\n        System.out.println(\"ConcreteComponent: operation\");\n    }\n}\n\n// Decorator base class\nabstract class Decorator implements Component {\n    protected Component component;\n\n    public Decorator(Component component) {\n        this.component = component;\n    }\n\n    @Override\n    public void operation() {\n        component.operation();\n    }\n}\n\n// Concrete Decorators\nclass ConcreteDecoratorA extends Decorator {\n    public ConcreteDecoratorA(Component component) {\n        super(component);\n    }\n\n    @Override\n    public void operation() {\n        super.operation();\n        addedBehavior();\n    }\n\n    private void addedBehavior() {\n        System.out.println(\"ConcreteDecoratorA: addedBehavior\");\n    }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n    public ConcreteDecoratorB(Component component) {\n        super(component);\n    }\n\n    @Override\n    public void operation() {\n        System.out.println(\"ConcreteDecoratorB: before\");\n        super.operation();\n        System.out.println(\"ConcreteDecoratorB: after\");\n    }\n}\n\n// Usage\nComponent component = new ConcreteComponent();\nComponent decoratedA = new ConcreteDecoratorA(component);\nComponent decoratedB = new ConcreteDecoratorB(decoratedA);\n\n// Call operation on the chain of decorators\ndecoratedB.operation();\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#coffee-shop-example","title":"Coffee Shop Example","text":"<pre><code>// Component interface\ninterface Coffee {\n    String getDescription();\n    double getCost();\n}\n\n// Concrete Component\nclass SimpleCoffee implements Coffee {\n    @Override\n    public String getDescription() {\n        return \"Simple Coffee\";\n    }\n\n    @Override\n    public double getCost() {\n        return 2.0;\n    }\n}\n\n// Decorator base class\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee decoratedCoffee;\n\n    public CoffeeDecorator(Coffee coffee) {\n        this.decoratedCoffee = coffee;\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription();\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost();\n    }\n}\n\n// Concrete Decorators\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + \", with milk\";\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.5;\n    }\n}\n\nclass SugarDecorator extends CoffeeDecorator {\n    public SugarDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + \", with sugar\";\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.2;\n    }\n}\n\nclass WhippedCreamDecorator extends CoffeeDecorator {\n    public WhippedCreamDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + \", with whipped cream\";\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 1.0;\n    }\n}\n\n// Usage\nCoffee simpleCoffee = new SimpleCoffee();\nSystem.out.println(simpleCoffee.getDescription() + \": $\" + simpleCoffee.getCost());\n\nCoffee milkCoffee = new MilkDecorator(simpleCoffee);\nSystem.out.println(milkCoffee.getDescription() + \": $\" + milkCoffee.getCost());\n\nCoffee sweetMilkCoffee = new SugarDecorator(milkCoffee);\nSystem.out.println(sweetMilkCoffee.getDescription() + \": $\" + sweetMilkCoffee.getCost());\n\nCoffee whippedSweetMilkCoffee = new WhippedCreamDecorator(sweetMilkCoffee);\nSystem.out.println(whippedSweetMilkCoffee.getDescription() + \": $\" + whippedSweetMilkCoffee.getCost());\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#java-io-decorators","title":"Java I/O Decorators","text":"<p>Java's I/O classes are a real-world example of the Decorator pattern:</p> <pre><code>// Using Java's built-in I/O decorators\nimport java.io.*;\n\npublic class JavaIODecoratorExample {\n    public static void main(String[] args) throws IOException {\n        // Creating a chain of decorators for reading data\n        try (InputStream fileInputStream = new FileInputStream(\"file.txt\");\n             InputStream bufferedInputStream = new BufferedInputStream(fileInputStream);\n             InputStream dataInputStream = new DataInputStream(bufferedInputStream)) {\n\n            // Now we can use methods from DataInputStream\n            // while benefiting from buffering and file input\n            byte data = dataInputStream.readByte();\n        }\n\n        // Creating a chain of decorators for writing data\n        try (OutputStream fileOutputStream = new FileOutputStream(\"output.txt\");\n             OutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);\n             PrintStream printStream = new PrintStream(bufferedOutputStream)) {\n\n            // Now we can use methods from PrintStream\n            // while benefiting from buffering and file output\n            printStream.println(\"Hello, Decorator Pattern!\");\n        }\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-the-decorator-pattern","title":"When to Use the Decorator Pattern","text":"<ul> <li>When you need to add responsibilities to objects dynamically and transparently</li> <li>When extension by subclassing is impractical (would lead to an explosion of subclasses)</li> <li>When you want to add functionality to individual objects without affecting others</li> <li>When you want to add and remove responsibilities at runtime</li> <li>When your design should allow for a potentially unlimited variety of additional functionalities</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#advantages_3","title":"Advantages","text":"<ul> <li>More flexible than inheritance for extending functionality</li> <li>Allows responsibilities to be added and removed at runtime</li> <li>Allows combining multiple behaviors by nesting decorators</li> <li>Follows the Single Responsibility Principle by dividing functionality into classes</li> <li>Follows the Open/Closed Principle by allowing extension without modification</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#disadvantages_3","title":"Disadvantages","text":"<ul> <li>Can result in many small objects that look similar</li> <li>Decorators can complicate the process of instantiating the component</li> <li>Difficult to understand and debug code with many layers of decoration</li> <li>Some implementations of the decorator pattern (especially those with extensive state) may not be identical to the component they wrap</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#facade-pattern","title":"Facade Pattern","text":"<p>The Facade pattern provides a unified interface to a set of interfaces in a subsystem. It defines a higher-level interface that makes the subsystem easier to use.</p>"},{"location":"design-patterns/design-patterns-structural/#intent_4","title":"Intent","text":"<ul> <li>Provide a unified interface to a set of interfaces in a subsystem</li> <li>Define a higher-level interface that makes the subsystem easier to use</li> <li>Shield clients from complex subsystem components</li> <li>Reduce dependencies on external code</li> <li>Promote loose coupling between subsystems and clients</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#implementation_4","title":"Implementation","text":"<pre><code>// Complex subsystem classes\nclass SubsystemA {\n    public void operationA() {\n        System.out.println(\"SubsystemA: Operation A\");\n    }\n}\n\nclass SubsystemB {\n    public void operationB() {\n        System.out.println(\"SubsystemB: Operation B\");\n    }\n}\n\nclass SubsystemC {\n    public void operationC() {\n        System.out.println(\"SubsystemC: Operation C\");\n    }\n}\n\n// Facade\nclass Facade {\n    private SubsystemA subsystemA;\n    private SubsystemB subsystemB;\n    private SubsystemC subsystemC;\n\n    public Facade() {\n        this.subsystemA = new SubsystemA();\n        this.subsystemB = new SubsystemB();\n        this.subsystemC = new SubsystemC();\n    }\n\n    // Methods that delegate to subsystems\n    public void operation1() {\n        System.out.println(\"Facade: Operation 1\");\n        subsystemA.operationA();\n        subsystemB.operationB();\n    }\n\n    public void operation2() {\n        System.out.println(\"Facade: Operation 2\");\n        subsystemB.operationB();\n        subsystemC.operationC();\n    }\n}\n\n// Client code\nFacade facade = new Facade();\nfacade.operation1();\nfacade.operation2();\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#home-theater-example","title":"Home Theater Example","text":"<pre><code>// Complex subsystem classes\nclass DVDPlayer {\n    public void on() {\n        System.out.println(\"DVD Player is ON\");\n    }\n\n    public void off() {\n        System.out.println(\"DVD Player is OFF\");\n    }\n\n    public void play(String movie) {\n        System.out.println(\"DVD Player is playing: \" + movie);\n    }\n\n    public void stop() {\n        System.out.println(\"DVD Player stopped\");\n    }\n}\n\nclass Amplifier {\n    public void on() {\n        System.out.println(\"Amplifier is ON\");\n    }\n\n    public void off() {\n        System.out.println(\"Amplifier is OFF\");\n    }\n\n    public void setVolume(int level) {\n        System.out.println(\"Amplifier volume set to: \" + level);\n    }\n\n    public void setDvd(DVDPlayer dvd) {\n        System.out.println(\"Amplifier connected to DVD player\");\n    }\n}\n\nclass Projector {\n    public void on() {\n        System.out.println(\"Projector is ON\");\n    }\n\n    public void off() {\n        System.out.println(\"Projector is OFF\");\n    }\n\n    public void wideScreenMode() {\n        System.out.println(\"Projector in widescreen mode (16:9)\");\n    }\n}\n\nclass TheaterLights {\n    public void dim(int level) {\n        System.out.println(\"Theater lights dimming to \" + level + \"%\");\n    }\n\n    public void on() {\n        System.out.println(\"Theater lights ON\");\n    }\n}\n\nclass Screen {\n    public void down() {\n        System.out.println(\"Theater screen going down\");\n    }\n\n    public void up() {\n        System.out.println(\"Theater screen going up\");\n    }\n}\n\n// Facade\nclass HomeTheaterFacade {\n    private Amplifier amplifier;\n    private DVDPlayer dvdPlayer;\n    private Projector projector;\n    private TheaterLights lights;\n    private Screen screen;\n\n    public HomeTheaterFacade(Amplifier amplifier, DVDPlayer dvdPlayer, \n                           Projector projector, TheaterLights lights, Screen screen) {\n        this.amplifier = amplifier;\n        this.dvdPlayer = dvdPlayer;\n        this.projector = projector;\n        this.lights = lights;\n        this.screen = screen;\n    }\n\n    public void watchMovie(String movie) {\n        System.out.println(\"=== Getting ready to watch a movie ===\");\n        lights.dim(10);\n        screen.down();\n        projector.on();\n        projector.wideScreenMode();\n        amplifier.on();\n        amplifier.setDvd(dvdPlayer);\n        amplifier.setVolume(5);\n        dvdPlayer.on();\n        dvdPlayer.play(movie);\n    }\n\n    public void endMovie() {\n        System.out.println(\"=== Shutting down movie theater ===\");\n        dvdPlayer.stop();\n        dvdPlayer.off();\n        amplifier.off();\n        projector.off();\n        screen.up();\n        lights.on();\n    }\n}\n\n// Client code\nAmplifier amplifier = new Amplifier();\nDVDPlayer dvdPlayer = new DVDPlayer();\nProjector projector = new Projector();\nTheaterLights lights = new TheaterLights();\nScreen screen = new Screen();\n\nHomeTheaterFacade homeTheater = new HomeTheaterFacade(\n    amplifier, dvdPlayer, projector, lights, screen);\n\n// Using the facade\nhomeTheater.watchMovie(\"Inception\");\n// ... movie is playing ...\nhomeTheater.endMovie();\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#database-facade-example","title":"Database Facade Example","text":"<pre><code>// Complex database subsystem\nclass Connection {\n    public void open(String connectionString) {\n        System.out.println(\"Opening database connection to: \" + connectionString);\n    }\n\n    public void close() {\n        System.out.println(\"Closing database connection\");\n    }\n}\n\nclass Command {\n    private Connection connection;\n\n    public Command(Connection connection) {\n        this.connection = connection;\n    }\n\n    public void execute(String query) {\n        System.out.println(\"Executing query: \" + query);\n    }\n}\n\nclass Transaction {\n    public void begin() {\n        System.out.println(\"Beginning transaction\");\n    }\n\n    public void commit() {\n        System.out.println(\"Committing transaction\");\n    }\n\n    public void rollback() {\n        System.out.println(\"Rolling back transaction\");\n    }\n}\n\nclass ResultSet {\n    public void read() {\n        System.out.println(\"Reading data from result set\");\n    }\n\n    public void close() {\n        System.out.println(\"Closing result set\");\n    }\n}\n\n// Database Facade\nclass DatabaseFacade {\n    private Connection connection;\n    private Transaction transaction;\n\n    public DatabaseFacade() {\n        connection = new Connection();\n        transaction = new Transaction();\n    }\n\n    public void executeQuery(String connectionString, String query) {\n        connection.open(connectionString);\n        Command command = new Command(connection);\n        ResultSet resultSet = new ResultSet();\n\n        try {\n            transaction.begin();\n            command.execute(query);\n            resultSet.read();\n            transaction.commit();\n        } catch (Exception e) {\n            transaction.rollback();\n            System.out.println(\"Error executing query: \" + e.getMessage());\n        } finally {\n            resultSet.close();\n            connection.close();\n        }\n    }\n}\n\n// Client code\nDatabaseFacade dbFacade = new DatabaseFacade();\ndbFacade.executeQuery(\"jdbc:mysql://localhost:3306/mydb\", \"SELECT * FROM users\");\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-the-facade-pattern","title":"When to Use the Facade Pattern","text":"<ul> <li>When you want to provide a simple interface to a complex subsystem</li> <li>When there are many dependencies between clients and the implementation classes of an abstraction</li> <li>When you want to layer your subsystems</li> <li>When you want to decouple your client code from subsystem components</li> <li>When you need to simplify a large, complex API</li> <li>When you want to create an entry point to each level of a layered software</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#advantages_4","title":"Advantages","text":"<ul> <li>Shields clients from subsystem components, reducing coupling</li> <li>Promotes subsystem independence and portability</li> <li>Simplifies the usage of complex systems</li> <li>Provides a context-specific interface to a large, general-purpose API</li> <li>Helps in applying the principle of least knowledge (clients only talk to the facade)</li> <li>Enables organizing systems into layers</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#disadvantages_4","title":"Disadvantages","text":"<ul> <li>A facade can become a god object coupled to all classes of an app</li> <li>The facade might add complexity if the underlying system is simple</li> <li>The facade may hide important configuration options and flexibility</li> <li>Might introduce a performance overhead if not designed carefully</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#flyweight-pattern","title":"Flyweight Pattern","text":"<p>The Flyweight pattern uses sharing to support large numbers of fine-grained objects efficiently. It reduces memory usage by sharing common state between multiple objects instead of keeping all of the data in each object.</p>"},{"location":"design-patterns/design-patterns-structural/#intent_5","title":"Intent","text":"<ul> <li>Use sharing to support large numbers of fine-grained objects efficiently</li> <li>Reduce memory footprint of a large number of similar objects</li> <li>Separate intrinsic (shared) state from extrinsic (unique) state</li> <li>Allow many virtual objects to share the same data</li> <li>Balance memory consumption and performance</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#implementation_5","title":"Implementation","text":"<pre><code>import java.util.HashMap;\nimport java.util.Map;\n\n// Flyweight interface\ninterface Flyweight {\n    void operation(String extrinsicState);\n}\n\n// Concrete Flyweight\nclass ConcreteFlyweight implements Flyweight {\n    private final String intrinsicState;\n\n    public ConcreteFlyweight(String intrinsicState) {\n        this.intrinsicState = intrinsicState;\n    }\n\n    @Override\n    public void operation(String extrinsicState) {\n        System.out.println(\"Intrinsic State: \" + intrinsicState);\n        System.out.println(\"Extrinsic State: \" + extrinsicState);\n    }\n}\n\n// Flyweight Factory\nclass FlyweightFactory {\n    private final Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();\n\n    public Flyweight getFlyweight(String key) {\n        if (!flyweights.containsKey(key)) {\n            flyweights.put(key, new ConcreteFlyweight(key));\n            System.out.println(\"Creating new flyweight with key: \" + key);\n        } else {\n            System.out.println(\"Reusing existing flyweight with key: \" + key);\n        }\n        return flyweights.get(key);\n    }\n\n    public int getFlyweightCount() {\n        return flyweights.size();\n    }\n}\n\n// Client code\nFlyweightFactory factory = new FlyweightFactory();\n\n// Get flyweights with the same intrinsic state\nFlyweight flyweight1 = factory.getFlyweight(\"shared\");\nFlyweight flyweight2 = factory.getFlyweight(\"shared\");\nFlyweight flyweight3 = factory.getFlyweight(\"different\");\n\n// Operations with different extrinsic states\nflyweight1.operation(\"First external state\");\nflyweight2.operation(\"Second external state\");\nflyweight3.operation(\"Third external state\");\n\nSystem.out.println(\"Total flyweights created: \" + factory.getFlyweightCount());\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#text-editor-example","title":"Text Editor Example","text":"<pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\n// Character Flyweight\nclass CharacterFlyweight {\n    private final char character;\n    private final String font;\n    private final int size;\n\n    public CharacterFlyweight(char character, String font, int size) {\n        this.character = character;\n        this.font = font;\n        this.size = size;\n\n        // Simulate memory consumption\n        System.out.println(\"Creating flyweight for character: \" + character + \n                          \", font: \" + font + \", size: \" + size);\n    }\n\n    public void display(int x, int y, String color) {\n        System.out.println(\"Displaying character \" + character + \n                          \" at position (\" + x + \",\" + y + \") with color \" + color + \n                          \" using font \" + font + \" and size \" + size);\n    }\n}\n\n// Flyweight Factory\nclass CharacterFlyweightFactory {\n    private final Map&lt;String, CharacterFlyweight&gt; flyweights = new HashMap&lt;&gt;();\n\n    public CharacterFlyweight getCharacter(char character, String font, int size) {\n        String key = character + font + size;\n        if (!flyweights.containsKey(key)) {\n            flyweights.put(key, new CharacterFlyweight(character, font, size));\n        }\n        return flyweights.get(key);\n    }\n\n    public int getFlyweightCount() {\n        return flyweights.size();\n    }\n}\n\n// Text containing characters with position and color (extrinsic state)\nclass TextEditor {\n    private final List&lt;Character&gt; characters = new ArrayList&lt;&gt;();\n    private final CharacterFlyweightFactory factory;\n\n    private int currentX = 0;\n    private int currentY = 0;\n\n    public TextEditor(CharacterFlyweightFactory factory) {\n        this.factory = factory;\n    }\n\n    public void addCharacter(char character, String font, int size, String color) {\n        CharacterFlyweight flyweight = factory.getCharacter(character, font, size);\n        characters.add(new Character(flyweight, currentX, currentY, color));\n        currentX += 10; // Move cursor position\n    }\n\n    public void display() {\n        for (Character character : characters) {\n            character.display();\n        }\n    }\n\n    // Character position class (stores extrinsic state)\n    private static class Character {\n        private final CharacterFlyweight flyweight;\n        private final int x;\n        private final int y;\n        private final String color;\n\n        public Character(CharacterFlyweight flyweight, int x, int y, String color) {\n            this.flyweight = flyweight;\n            this.x = x;\n            this.y = y;\n            this.color = color;\n        }\n\n        public void display() {\n            flyweight.display(x, y, color);\n        }\n    }\n}\n\n// Usage\nCharacterFlyweightFactory factory = new CharacterFlyweightFactory();\nTextEditor editor = new TextEditor(factory);\n\n// Add text with the same font and size but different positions and colors\nString text = \"Hello Flyweight Pattern!\";\nfor (int i = 0; i &lt; text.length(); i++) {\n    char c = text.charAt(i);\n    String color = i % 2 == 0 ? \"blue\" : \"red\";\n    editor.addCharacter(c, \"Arial\", 12, color);\n}\n\neditor.display();\nSystem.out.println(\"Total flyweights created: \" + factory.getFlyweightCount());\n// Even though we added 23 characters, we only created unique flyweights for each character\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#forest-rendering-example","title":"Forest Rendering Example","text":"<pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n// Tree type - intrinsic state\nclass TreeType {\n    private final String name;\n    private final String color;\n    private final String texture;\n\n    public TreeType(String name, String color, String texture) {\n        this.name = name;\n        this.color = color;\n        this.texture = texture;\n\n        System.out.println(\"Creating a tree type: \" + name);\n    }\n\n    public void render(int x, int y) {\n        System.out.println(\"Rendering \" + name + \" tree with \" + color + \n                          \" color and \" + texture + \" texture at (\" + x + \",\" + y + \")\");\n    }\n}\n\n// Flyweight factory\nclass TreeFactory {\n    private static final Map&lt;String, TreeType&gt; treeTypes = new HashMap&lt;&gt;();\n\n    public static TreeType getTreeType(String name, String color, String texture) {\n        String key = name + color + texture;\n        if (!treeTypes.containsKey(key)) {\n            treeTypes.put(key, new TreeType(name, color, texture));\n        }\n        return treeTypes.get(key);\n    }\n\n    public static int getTreeTypeCount() {\n        return treeTypes.size();\n    }\n}\n\n// Tree - contains extrinsic state\nclass Tree {\n    private final int x;\n    private final int y;\n    private final TreeType type;\n\n    public Tree(int x, int y, TreeType type) {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n    }\n\n    public void render() {\n        type.render(x, y);\n    }\n}\n\n// Forest - contains all trees\nclass Forest {\n    private final List&lt;Tree&gt; trees = new ArrayList&lt;&gt;();\n\n    public void plantTree(int x, int y, String name, String color, String texture) {\n        TreeType type = TreeFactory.getTreeType(name, color, texture);\n        Tree tree = new Tree(x, y, type);\n        trees.add(tree);\n    }\n\n    public void render() {\n        for (Tree tree : trees) {\n            tree.render();\n        }\n    }\n}\n\n// Usage\nForest forest = new Forest();\nRandom random = new Random();\n\n// Plant many trees of a few types\nfor (int i = 0; i &lt; 100; i++) {\n    int x = random.nextInt(500);\n    int y = random.nextInt(500);\n\n    String name;\n    String color;\n    String texture;\n\n    if (random.nextBoolean()) {\n        name = \"Oak\";\n        color = \"Green\";\n        texture = \"Rough\";\n    } else {\n        name = \"Pine\";\n        color = \"Dark Green\";\n        texture = \"Smooth\";\n    }\n\n    forest.plantTree(x, y, name, color, texture);\n}\n\nforest.render();\nSystem.out.println(\"Total tree types created: \" + TreeFactory.getTreeTypeCount());\n// Even though we have 100 trees, we only created 2 tree types\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-the-flyweight-pattern","title":"When to Use the Flyweight Pattern","text":"<ul> <li>When an application uses a large number of objects</li> <li>When memory usage is high due to the sheer quantity of objects</li> <li>When the majority of each object's state can be made extrinsic (external)</li> <li>When many objects can be replaced by a few shared objects</li> <li>When the application doesn't depend on object identity</li> <li>When the objects' intrinsic state is immutable or can be shared</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#advantages_5","title":"Advantages","text":"<ul> <li>Reduces memory usage by sharing common data</li> <li>Improves performance in memory-constrained environments</li> <li>Decreases the total number of objects created</li> <li>Makes it possible to represent large numbers of virtual objects without creating as many real ones</li> <li>Keeps object instances to a minimum, which can improve responsiveness</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#disadvantages_5","title":"Disadvantages","text":"<ul> <li>Adds complexity by separating intrinsic and extrinsic state</li> <li>Managing extrinsic state can add runtime overhead</li> <li>The pattern may not provide significant benefits if objects don't share significant amounts of data</li> <li>Adds synchronization overhead when used in multi-threaded applications</li> <li>Makes it harder to track individual object instances if they need to be tracked separately</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#proxy-pattern","title":"Proxy Pattern","text":"<p>The Proxy pattern provides a surrogate or placeholder for another object to control access to it. It creates a representative object that controls access to another object, which may be remote, expensive to create, or in need of securing.</p>"},{"location":"design-patterns/design-patterns-structural/#intent_6","title":"Intent","text":"<ul> <li>Provide a surrogate or placeholder for another object to control access to it</li> <li>Add a wrapper and delegation to protect the real component from undue complexity</li> <li>Control access to the original object</li> <li>Add functionality when accessing the original object</li> <li>Delay the full cost of creating an object until we need to use it</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#implementation_6","title":"Implementation","text":"<pre><code>// Subject interface\ninterface Subject {\n    void request();\n}\n\n// Real Subject\nclass RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject: Handling request\");\n    }\n}\n\n// Proxy\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    @Override\n    public void request() {\n        // Lazy initialization: create the RealSubject only when needed\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n\n        preRequest();\n        realSubject.request();\n        postRequest();\n    }\n\n    private void preRequest() {\n        System.out.println(\"Proxy: Pre-processing request\");\n    }\n\n    private void postRequest() {\n        System.out.println(\"Proxy: Post-processing request\");\n    }\n}\n\n// Client code\nSubject subject = new Proxy();\nsubject.request();\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#types-of-proxies","title":"Types of Proxies","text":""},{"location":"design-patterns/design-patterns-structural/#virtual-proxy-lazy-initialization","title":"Virtual Proxy (Lazy Initialization)","text":"<pre><code>// Heavy image resource\nclass Image {\n    private String filename;\n\n    public Image(String filename) {\n        this.filename = filename;\n        loadImageFromDisk();\n    }\n\n    private void loadImageFromDisk() {\n        System.out.println(\"Loading image: \" + filename);\n        // Simulate loading a large image\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void display() {\n        System.out.println(\"Displaying image: \" + filename);\n    }\n}\n\n// Image interface\ninterface ImageInterface {\n    void display();\n}\n\n// Real image implementation\nclass RealImage implements ImageInterface {\n    private String filename;\n\n    public RealImage(String filename) {\n        this.filename = filename;\n        loadFromDisk();\n    }\n\n    private void loadFromDisk() {\n        System.out.println(\"Loading image: \" + filename);\n        // Simulate loading a large image\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Displaying image: \" + filename);\n    }\n}\n\n// Virtual proxy for the image\nclass VirtualImage implements ImageInterface {\n    private String filename;\n    private RealImage realImage;\n\n    public VirtualImage(String filename) {\n        this.filename = filename;\n        System.out.println(\"Virtual image created: \" + filename);\n    }\n\n    @Override\n    public void display() {\n        // Load the real image only when needed\n        if (realImage == null) {\n            realImage = new RealImage(filename);\n        }\n        realImage.display();\n    }\n}\n\n// Usage\nSystem.out.println(\"Creating image proxies...\");\nImageInterface image1 = new VirtualImage(\"photo1.jpg\");\nImageInterface image2 = new VirtualImage(\"photo2.jpg\");\n\n// The images aren't loaded until display() is called\nSystem.out.println(\"Will display image1...\");\nimage1.display(); // Now photo1.jpg is loaded\n\nSystem.out.println(\"Will display image1 again...\");\nimage1.display(); // No loading occurs, already loaded\n\nSystem.out.println(\"Will display image2...\");\nimage2.display(); // Now photo2.jpg is loaded\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#protection-proxy-access-control","title":"Protection Proxy (Access Control)","text":"<pre><code>// Internet interface\ninterface Internet {\n    void connectTo(String serverhost) throws Exception;\n}\n\n// Real Internet implementation\nclass RealInternet implements Internet {\n    @Override\n    public void connectTo(String serverHost) {\n        System.out.println(\"Connecting to \" + serverHost);\n    }\n}\n\n// Protection proxy for controlling access\nclass RestrictedInternet implements Internet {\n    private Internet internet = new RealInternet();\n    private List&lt;String&gt; bannedSites;\n\n    public RestrictedInternet() {\n        bannedSites = Arrays.asList(\n            \"banned1.example.com\",\n            \"banned2.example.com\",\n            \"banned3.example.com\"\n        );\n    }\n\n    @Override\n    public void connectTo(String serverHost) throws Exception {\n        if (bannedSites.contains(serverHost)) {\n            throw new Exception(\"Access Denied: Cannot connect to \" + serverHost);\n        }\n\n        internet.connectTo(serverHost);\n    }\n}\n\n// Usage\nInternet internet = new RestrictedInternet();\n\ntry {\n    internet.connectTo(\"allowed.example.com\");      // Allowed\n    internet.connectTo(\"banned1.example.com\");      // Throws exception\n} catch (Exception e) {\n    System.out.println(e.getMessage());\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#remote-proxy","title":"Remote Proxy","text":"<pre><code>// Remote interface\ninterface RemoteService {\n    String performOperation(String data);\n}\n\n// Real service implementation (would be on a remote server)\nclass RealRemoteService implements RemoteService {\n    @Override\n    public String performOperation(String data) {\n        return \"Processed: \" + data;\n    }\n}\n\n// Remote proxy simulating RPC\nclass RemoteServiceProxy implements RemoteService {\n    private RemoteService service;\n\n    public RemoteServiceProxy() {\n        // In a real scenario, this might set up network communication\n        System.out.println(\"Setting up remote service connection\");\n    }\n\n    @Override\n    public String performOperation(String data) {\n        // Lazy initialization of the service connection\n        if (service == null) {\n            System.out.println(\"Establishing connection to remote service\");\n            service = new RealRemoteService(); // In reality, this would be a remote reference\n        }\n\n        System.out.println(\"Sending data over the network: \" + data);\n\n        // Simulate network communication\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        String result = service.performOperation(data);\n\n        System.out.println(\"Received result from remote service\");\n        return result;\n    }\n}\n\n// Usage\nRemoteService service = new RemoteServiceProxy();\nString result = service.performOperation(\"Sample data\");\nSystem.out.println(\"Result: \" + result);\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#smart-proxy-adding-functionality","title":"Smart Proxy (Adding Functionality)","text":"<pre><code>// Database connection interface\ninterface DatabaseExecutor {\n    void execute(String query);\n}\n\n// Real database executor\nclass DatabaseExecutorImpl implements DatabaseExecutor {\n    @Override\n    public void execute(String query) {\n        System.out.println(\"Executing query: \" + query);\n    }\n}\n\n// Smart proxy that adds transaction management and query logging\nclass DatabaseExecutorProxy implements DatabaseExecutor {\n    private boolean isAdmin;\n    private DatabaseExecutor executor;\n\n    public DatabaseExecutorProxy(String user, String password) {\n        if (\"admin\".equals(user) &amp;&amp; \"password\".equals(password)) {\n            isAdmin = true;\n        }\n        executor = new DatabaseExecutorImpl();\n    }\n\n    @Override\n    public void execute(String query) {\n        if (isAdmin) {\n            // Add transaction management\n            System.out.println(\"Starting transaction...\");\n\n            try {\n                // Log the query\n                logQuery(query);\n\n                // Execute the query\n                executor.execute(query);\n\n                System.out.println(\"Committing transaction...\");\n            } catch (Exception e) {\n                System.out.println(\"Rolling back transaction due to: \" + e.getMessage());\n            }\n        } else {\n            if (query.toLowerCase().startsWith(\"select\")) {\n                logQuery(query);\n                executor.execute(query);\n            } else {\n                System.out.println(\"Access denied: Not authorized for non-select queries\");\n            }\n        }\n    }\n\n    private void logQuery(String query) {\n        System.out.println(\"Logging query: \" + query);\n    }\n}\n\n// Usage\nDatabaseExecutor nonAdminExecutor = new DatabaseExecutorProxy(\"guest\", \"guest\");\nnonAdminExecutor.execute(\"SELECT * FROM users\");            // Works\nnonAdminExecutor.execute(\"DELETE FROM users WHERE id = 1\"); // Access denied\n\nDatabaseExecutor adminExecutor = new DatabaseExecutorProxy(\"admin\", \"password\");\nadminExecutor.execute(\"SELECT * FROM users\");               // Works\nadminExecutor.execute(\"DELETE FROM users WHERE id = 1\");    // Works with transaction\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#when-to-use-the-proxy-pattern","title":"When to Use the Proxy Pattern","text":"<ul> <li>When you need lazy initialization (virtual proxy)</li> <li>When you need access control for the original object (protection proxy)</li> <li>When you need to add logging, performance monitoring, or auditing (smart proxy)</li> <li>When you need to connect to a remote service (remote proxy)</li> <li>When you need a simplified version of a complex or heavy object (virtual proxy)</li> <li>When you need a local representative for an object in a different address space (remote proxy)</li> <li>When you need to cache results of expensive operations (caching proxy)</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#advantages_6","title":"Advantages","text":"<ul> <li>Controls access to the original object</li> <li>Allows operations to be performed before or after the request reaches the original object</li> <li>Manages the lifecycle of the original object</li> <li>Works even when the original object is not ready or not available</li> <li>Adds functionality without changing the original object</li> <li>Follows the Open/Closed Principle</li> <li>Implements the principle of separation of concerns</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#disadvantages_6","title":"Disadvantages","text":"<ul> <li>Adds another layer of indirection which can impact performance</li> <li>Makes the code more complex</li> <li>Client code might behave differently depending on whether it's using the proxy or the real subject</li> <li>In some proxy implementations, the response might be delayed due to lazy initialization</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#best-practices","title":"Best Practices","text":""},{"location":"design-patterns/design-patterns-structural/#general-best-practices-for-structural-patterns","title":"General Best Practices for Structural Patterns","text":"<ol> <li> <p>Understand the Problem First: Choose a pattern only after you understand the problem you're trying to solve.</p> </li> <li> <p>Keep It Simple: Don't over-engineer solutions. Use the simplest pattern that meets your needs.</p> </li> <li> <p>Consider Combination: Sometimes combining patterns can provide more powerful solutions.</p> </li> <li> <p>Balance Performance: Structural patterns can introduce overhead, so ensure the benefits outweigh the costs.</p> </li> <li> <p>Document Your Design: Make sure to document why and how you're using specific patterns.</p> </li> </ol>"},{"location":"design-patterns/design-patterns-structural/#pattern-specific-best-practices","title":"Pattern-Specific Best Practices","text":""},{"location":"design-patterns/design-patterns-structural/#adapter-pattern_1","title":"Adapter Pattern","text":"<ul> <li>Keep adapters simple and focused on interface translation</li> <li>Consider using the Adapter pattern for legacy code integration</li> <li>Use composition over inheritance when possible</li> <li>Don't adapt more than necessary</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#bridge-pattern_1","title":"Bridge Pattern","text":"<ul> <li>Identify the varying dimensions early</li> <li>Design for independent evolution</li> <li>Make sure abstractions and implementations can change independently</li> <li>Consider future extensions to both hierarchies</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#composite-pattern_1","title":"Composite Pattern","text":"<ul> <li>Define clear component interface with operations for both leaf and composite</li> <li>Consider whether to use the safe or transparent approach</li> <li>Be careful with operations that don't make sense for particular components</li> <li>Consider adding parent references if needed</li> <li>Be explicit about whether clients can modify the component structure</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#decorator-pattern_1","title":"Decorator Pattern","text":"<ul> <li>Keep decorator interface compatible with the component</li> <li>Make decorators independent of each other</li> <li>Keep the component code simple</li> <li>Consider using Builder or Factory for complex decoration chains</li> <li>Be consistent with method delegation</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#facade-pattern_1","title":"Facade Pattern","text":"<ul> <li>Keep facades simple and focused on providing a simplified interface</li> <li>Avoid turning facades into \"god objects\"</li> <li>Consider creating multiple facades for different use cases</li> <li>Don't expose the subsystem components through the facade</li> <li>Don't make facade dependent on client code</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#flyweight-pattern_1","title":"Flyweight Pattern","text":"<ul> <li>Clearly separate intrinsic and extrinsic state</li> <li>Make flyweight objects immutable</li> <li>Use a factory for flyweight creation and management</li> <li>Ensure thread safety in the flyweight factory if needed</li> <li>Consider the memory/performance tradeoff</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#proxy-pattern_1","title":"Proxy Pattern","text":"<ul> <li>Keep the proxy interface identical to the subject</li> <li>Choose the right type of proxy for your needs</li> <li>Consider lazy initialization for expensive resources</li> <li>Proxy should completely encapsulate access to the real subject</li> <li>Don't add too much logic to the proxy</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"design-patterns/design-patterns-structural/#overusing-patterns","title":"Overusing Patterns","text":"<pre><code>// Overusing patterns - unnecessary Facade\npublic class SimpleService {\n    public void performOperation() {\n        // Simple operation\n    }\n}\n\n// Unnecessary Facade\npublic class ServiceFacade {\n    private SimpleService service = new SimpleService();\n\n    public void operation() {\n        service.performOperation();\n    }\n}\n\n// Better approach - use SimpleService directly if it's already simple\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#overcomplicating-with-unnecessary-layers","title":"Overcomplicating with Unnecessary Layers","text":"<pre><code>// Overcomplicating - too many decorators\ninterface Coffee {\n    double getCost();\n}\n\nclass BasicCoffee implements Coffee {\n    @Override\n    public double getCost() {\n        return 2.0;\n    }\n}\n\nclass MilkDecorator implements Coffee {\n    private Coffee coffee;\n\n    public MilkDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.5;\n    }\n}\n\nclass SugarDecorator implements Coffee {\n    private Coffee coffee;\n\n    public SugarDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.2;\n    }\n}\n\nclass WhippedCreamDecorator implements Coffee {\n    private Coffee coffee;\n\n    public WhippedCreamDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 1.0;\n    }\n}\n\nclass ChocolateSyrupDecorator implements Coffee {\n    private Coffee coffee;\n\n    public ChocolateSyrupDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.8;\n    }\n}\n\nclass CreamDecorator implements Coffee {\n    private Coffee coffee;\n\n    public CreamDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.3;\n    }\n}\n\n// Too many decorators \nCoffee coffee = new ChocolateSyrupDecorator(\n                new CreamDecorator(\n                new WhippedCreamDecorator(\n                new SugarDecorator(\n                new MilkDecorator(\n                new BasicCoffee())))));\n\n// Better approach - combine related decorators or use a Builder pattern\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#confusing-similar-patterns","title":"Confusing Similar Patterns","text":"<p>Developers often confuse similar patterns:</p> <ul> <li>Adapter vs. Bridge: Adapter makes incompatible interfaces work together; Bridge separates abstraction from implementation.</li> <li>Decorator vs. Proxy: Decorator adds responsibilities; Proxy controls access.</li> <li>Facade vs. Adapter: Facade provides a simplified interface; Adapter enables incompatible interfaces to work together.</li> <li>Composite vs. Decorator: Composite builds tree structures; Decorator adds responsibilities without subclassing.</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#performance-issues-with-structural-patterns","title":"Performance Issues with Structural Patterns","text":"<pre><code>// Performance issue - proxy with excessive overhead\nclass ExpensiveProxy implements Subject {\n    private RealSubject realSubject;\n\n    @Override\n    public void request() {\n        // Excessive overhead before delegation\n        System.out.println(\"Starting proxy operation\");\n        for (int i = 0; i &lt; 1000; i++) {\n            // Unnecessary processing\n            Math.sqrt(i);\n        }\n\n        // Create subject on every request instead of reusing\n        realSubject = new RealSubject();\n\n        realSubject.request();\n\n        // Excessive overhead after delegation\n        System.out.println(\"Finishing proxy operation\");\n        for (int i = 0; i &lt; 1000; i++) {\n            // Unnecessary processing\n            Math.sqrt(i);\n        }\n    }\n}\n\n// Better approach - minimize overhead and cache the real subject\nclass EfficientProxy implements Subject {\n    private RealSubject realSubject;\n\n    @Override\n    public void request() {\n        // Lazy initialization with caching\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n\n        // Minimal pre-processing\n        System.out.println(\"Starting proxy operation\");\n\n        realSubject.request();\n\n        // Minimal post-processing\n        System.out.println(\"Finishing proxy operation\");\n    }\n}\n</code></pre>"},{"location":"design-patterns/design-patterns-structural/#ignoring-pattern-limitations","title":"Ignoring Pattern Limitations","text":"<p>Each pattern has limitations that should be considered:</p> <ul> <li>Adapter: Adds complexity and may hide poor design</li> <li>Bridge: Increases complexity and isn't suitable for simple class hierarchies</li> <li>Composite: May make design overly general and compromise type safety</li> <li>Decorator: Can lead to many small, similar objects that are hard to debug</li> <li>Facade: May turn into a god object if not designed carefully</li> <li>Flyweight: Adds complexity for managing extrinsic state</li> <li>Proxy: Adds indirection which can impact performance</li> </ul>"},{"location":"design-patterns/design-patterns-structural/#comparing-structural-patterns","title":"Comparing Structural Patterns","text":""},{"location":"design-patterns/design-patterns-structural/#when-to-choose-which-pattern","title":"When to Choose Which Pattern","text":"Pattern When to Use Adapter When you need to make incompatible interfaces work together Bridge When you want to decouple an abstraction from its implementation Composite When you need to work with tree-like object structures Decorator When you want to add responsibilities dynamically without subclassing Facade When you need to provide a simplified interface to a complex subsystem Flyweight When you need to support a large number of fine-grained objects efficiently Proxy When you need to control access to an object"},{"location":"design-patterns/design-patterns-structural/#comparison-of-key-characteristics","title":"Comparison of Key Characteristics","text":"Pattern Intent Complexity Flexibility Adapter Makes incompatible interfaces compatible Low-Medium Medium Bridge Separates abstraction from implementation Medium-High High Composite Treats individual objects and compositions uniformly Medium Medium Decorator Adds responsibilities dynamically Medium High Facade Simplifies a complex subsystem Low Low Flyweight Shares common state between objects Medium-High Low Proxy Controls access to an object Low-Medium Medium"},{"location":"design-patterns/design-patterns-structural/#pattern-combinations","title":"Pattern Combinations","text":"<p>Structural patterns can be combined for more powerful solutions:</p> <ol> <li>Decorator + Composite: Decorators can add behavior to composite structures.</li> <li>Adapter + Bridge: Adapters can make bridges work with incompatible interfaces.</li> <li>Proxy + Flyweight: A proxy can manage reference to flyweight objects.</li> <li>Facade + Adapter: A facade can use adapters to work with incompatible subsystem components.</li> <li>Composite + Flyweight: Flyweights can be used to reduce memory usage in large composite structures.</li> </ol>"},{"location":"design-patterns/design-patterns-structural/#summary","title":"Summary","text":"<p>Structural design patterns focus on how classes and objects are composed and provide solutions to create flexible, maintainable, and efficient code structure:</p> <ul> <li>Adapter Pattern: Converts the interface of a class into another interface clients expect.</li> <li>Bridge Pattern: Decouples an abstraction from its implementation.</li> <li>Composite Pattern: Composes objects into tree structures to represent part-whole hierarchies.</li> <li>Decorator Pattern: Adds responsibilities to objects dynamically without subclassing.</li> <li>Facade Pattern: Provides a simplified interface to a complex subsystem.</li> <li>Flyweight Pattern: Uses sharing to support large numbers of fine-grained objects efficiently.</li> <li>Proxy Pattern: Provides a surrogate or placeholder for another object to control access.</li> </ul> <p>Each pattern has specific use cases, advantages, and disadvantages. The key to effective use of structural patterns is understanding when and how to apply them to solve specific design problems.</p> <p>By mastering these patterns, you'll be able to design more flexible, maintainable, and efficient object structures in your Java applications.</p>"},{"location":"design-patterns/design-patterns-structural/#further-reading","title":"Further Reading","text":"<ul> <li>\"Design Patterns: Elements of Reusable Object-Oriented Software\" by Gamma, Helm, Johnson, and Vlissides</li> <li>\"Head First Design Patterns\" by Eric Freeman and Elisabeth Robson</li> <li>\"Effective Java\" by Joshua Bloch</li> <li>\"Clean Code\" by Robert C. Martin</li> <li>Refactoring Guru - Design Patterns</li> <li>SourceMaking - Design Patterns</li> <li>Java Design Patterns </li> </ul>"},{"location":"java/basic-concepts/","title":"Java Basic Concepts","text":"<p>This page provides an overview of Java basic concepts and syntax.</p>"},{"location":"java/basic-concepts/#introduction-to-java","title":"Introduction to Java","text":"<p>Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let application developers write once, run anywhere (WORA).</p>"},{"location":"java/basic-concepts/#variables-and-data-types","title":"Variables and Data Types","text":"<p>Java has several built-in data types:</p> <ul> <li>Primitive types: byte, short, int, long, float, double, boolean, char</li> <li>Reference types: String, Arrays, Classes</li> </ul> <p>Example:</p> <pre><code>// Primitive types\nint number = 10;\ndouble price = 9.99;\nboolean isValid = true;\nchar grade = 'A';\n\n// Reference types\nString name = \"John Doe\";\nint[] numbers = {1, 2, 3, 4, 5};\n</code></pre>"},{"location":"java/basic-concepts/#control-flow","title":"Control Flow","text":"<p>Java supports standard control flow constructs:</p>"},{"location":"java/basic-concepts/#conditional-statements","title":"Conditional Statements","text":"<pre><code>if (condition) {\n    // code to execute if condition is true\n} else if (anotherCondition) {\n    // code to execute if anotherCondition is true\n} else {\n    // code to execute if all conditions are false\n}\n\n// Switch statement\nswitch (variable) {\n    case value1:\n        // code\n        break;\n    case value2:\n        // code\n        break;\n    default:\n        // default code\n}\n</code></pre>"},{"location":"java/basic-concepts/#loops","title":"Loops","text":"<pre><code>// For loop\nfor (int i = 0; i &lt; 10; i++) {\n    System.out.println(i);\n}\n\n// While loop\nwhile (condition) {\n    // code\n}\n\n// Do-while loop\ndo {\n    // code\n} while (condition);\n\n// Enhanced for loop (for-each)\nfor (String item : items) {\n    System.out.println(item);\n}\n</code></pre>"},{"location":"java/basic-concepts/#methods","title":"Methods","text":"<p>Methods are blocks of code that perform specific tasks:</p> <pre><code>public returnType methodName(parameterType parameterName) {\n    // method body\n    return value; // if return type is not void\n}\n</code></pre> <p>Example:</p> <pre><code>public int add(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"java/basic-concepts/#classes-and-objects","title":"Classes and Objects","text":"<p>Java is an object-oriented language where classes are blueprints for objects:</p> <pre><code>public class Person {\n    // Fields\n    private String name;\n    private int age;\n\n    // Constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Methods\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n\n// Creating an object\nPerson person = new Person(\"John\", 30);\n</code></pre>"},{"location":"java/basic-concepts/#further-reading","title":"Further Reading","text":"<ul> <li>Oracle Java Documentation</li> <li>Java Language Specification </li> </ul>"},{"location":"java/java-basics/","title":"Java Basics","text":""},{"location":"java/java-basics/#overview","title":"Overview","text":"<p>This guide provides a comprehensive introduction to Java programming fundamentals. Java is a versatile, object-oriented language that runs on the Java Virtual Machine (JVM), making it platform-independent. This guide covers essential Java syntax, data types, control flow, and basic operations for developers new to Java or refreshing their knowledge.</p>"},{"location":"java/java-basics/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of programming concepts</li> <li>Java Development Kit (JDK) 17 or later installed</li> <li>Integrated Development Environment (IDE) such as IntelliJ IDEA, Eclipse, or VS Code</li> </ul>"},{"location":"java/java-basics/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Java's architecture and execution model</li> <li>Master Java syntax and fundamental data types</li> <li>Work with variables, operators, and expressions</li> <li>Implement control flow structures (if/else, loops, switch)</li> <li>Create and run a basic Java program</li> <li>Understand package organization and imports</li> <li>Format and display output in console applications</li> </ul>"},{"location":"java/java-basics/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Java Architecture</li> <li>Setting Up Your Environment</li> <li>First Java Program</li> <li>Variables and Data Types</li> <li>Operators</li> <li>Control Flow</li> <li>Arrays</li> <li>Java Packages</li> <li>Input and Output Basics</li> <li>Naming Conventions</li> </ol>"},{"location":"java/java-basics/#java-architecture","title":"Java Architecture","text":"<p>Java applications operate on the principle of \"Write Once, Run Anywhere\" (WORA) through a two-step process: 1. Java source code (<code>.java</code> files) is compiled into bytecode (<code>.class</code> files) using the <code>javac</code> compiler 2. The bytecode runs on the Java Virtual Machine (JVM), which interprets or just-in-time compiles it to machine code</p> <p>This architecture includes: - JDK (Java Development Kit): Tools for developing Java applications - JRE (Java Runtime Environment): Resources for running Java applications - JVM (Java Virtual Machine): The runtime engine that executes Java bytecode</p> <pre><code>Java Architecture Diagram:\n+----------------+\n| Java Source    |\n| Code (.java)   |\n+----------------+\n        |\n        v\n+----------------+\n| Java Compiler  |\n| (javac)        |\n+----------------+\n        |\n        v\n+----------------+\n| Bytecode       |\n| (.class)       |\n+----------------+\n        |\n        v\n+----------------+\n| JVM            | --&gt; Platform-specific implementation\n+----------------+\n        |\n        v\n+----------------+\n| Operating      |\n| System         |\n+----------------+\n</code></pre>"},{"location":"java/java-basics/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<ol> <li>Install JDK 17+:</li> <li>Download from Oracle or use OpenJDK</li> <li>Set JAVA_HOME environment variable</li> <li> <p>Add Java's bin directory to your PATH</p> </li> <li> <p>Verify installation:    <pre><code>java -version\njavac -version\n</code></pre></p> </li> <li> <p>Choose an IDE:</p> </li> <li>IntelliJ IDEA: Full-featured, powerful IDE</li> <li>Eclipse: Popular open-source option</li> <li>VS Code with Java extensions: Lightweight alternative</li> </ol>"},{"location":"java/java-basics/#first-java-program","title":"First Java Program","text":"<p>Create a file named <code>HelloWorld.java</code>:</p> <pre><code>public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n</code></pre> <p>Let's break this down: - <code>public class HelloWorld</code>: Class declaration matching the filename - <code>public static void main(String[] args)</code>: The entry point method   - <code>public</code>: Accessible from outside the class   - <code>static</code>: Belongs to the class, not an instance   - <code>void</code>: Returns no value   - <code>main</code>: Special method name recognized as program entry point   - <code>String[] args</code>: Command-line arguments array - <code>System.out.println()</code>: Outputs text to the console</p> <p>To compile and run: <pre><code>javac HelloWorld.java\njava HelloWorld\n</code></pre></p>"},{"location":"java/java-basics/#variables-and-data-types","title":"Variables and Data Types","text":"<p>Java is statically typed, requiring variable type declaration.</p>"},{"location":"java/java-basics/#primitive-data-types","title":"Primitive Data Types","text":"Type Size Range Default byte 8 bits -128 to 127 0 short 16 bits -32,768 to 32,767 0 int 32 bits -2^31 to 2^31-1 0 long 64 bits -2^63 to 2^63-1 0L float 32 bits ~3.4e-38 to 3.4e+38 (6-7 significant decimal digits) 0.0f double 64 bits ~1.7e-308 to 1.7e+308 (15 significant decimal digits) 0.0d char 16 bits 0 to 65,535 (Unicode characters) '\\u0000' boolean 1 bit true or false false"},{"location":"java/java-basics/#variable-declaration-and-initialization","title":"Variable Declaration and Initialization","text":"<pre><code>// Declaration\nint age;\ndouble salary;\n\n// Initialization\nage = 25;\nsalary = 50000.50;\n\n// Declaration and initialization\nString name = \"John\";\nfinal double PI = 3.14159; // Constants are declared with 'final'\n\n// Type inference with var (Java 10+)\nvar message = \"Hello\"; // Inferred as String\n</code></pre>"},{"location":"java/java-basics/#reference-types","title":"Reference Types","text":"<ul> <li> <p>String: Sequence of characters   <pre><code>String greeting = \"Hello, Java!\";\n</code></pre></p> </li> <li> <p>Arrays: Fixed-length collections   <pre><code>int[] numbers = {1, 2, 3, 4, 5};\nString[] names = new String[3];\n</code></pre></p> </li> <li> <p>Classes: User-defined types   <pre><code>Person person = new Person(\"John\", 25);\n</code></pre></p> </li> </ul>"},{"location":"java/java-basics/#operators","title":"Operators","text":"<p>Java provides several categories of operators:</p>"},{"location":"java/java-basics/#arithmetic-operators","title":"Arithmetic Operators","text":"<pre><code>int a = 10, b = 5;\nint sum = a + b;        // Addition: 15\nint difference = a - b; // Subtraction: 5\nint product = a * b;    // Multiplication: 50\nint quotient = a / b;   // Division: 2\nint remainder = a % b;  // Modulus: 0\n</code></pre>"},{"location":"java/java-basics/#assignment-operators","title":"Assignment Operators","text":"<pre><code>int x = 10;\nx += 5;  // Equivalent to: x = x + 5\nx -= 3;  // Equivalent to: x = x - 3\nx *= 2;  // Equivalent to: x = x * 2\nx /= 4;  // Equivalent to: x = x / 4\nx %= 3;  // Equivalent to: x = x % 3\n</code></pre>"},{"location":"java/java-basics/#comparison-operators","title":"Comparison Operators","text":"<pre><code>int a = 10, b = 5;\nboolean isEqual = a == b;       // false\nboolean isNotEqual = a != b;    // true\nboolean isGreater = a &gt; b;      // true\nboolean isLess = a &lt; b;         // false\nboolean isGreaterEqual = a &gt;= b; // true\nboolean isLessEqual = a &lt;= b;    // false\n</code></pre>"},{"location":"java/java-basics/#logical-operators","title":"Logical Operators","text":"<pre><code>boolean x = true, y = false;\nboolean andResult = x &amp;&amp; y; // false (logical AND)\nboolean orResult = x || y;  // true (logical OR)\nboolean notResult = !x;     // false (logical NOT)\n</code></pre>"},{"location":"java/java-basics/#bitwise-operators","title":"Bitwise Operators","text":"<pre><code>int a = 5;  // 101 in binary\nint b = 3;  // 011 in binary\n\nint bitwiseAnd = a &amp; b;  // 001 (1 in decimal)\nint bitwiseOr = a | b;   // 111 (7 in decimal)\nint bitwiseXor = a ^ b;  // 110 (6 in decimal)\nint bitwiseNot = ~a;     // ...010 (-6 in decimal, due to two's complement)\nint leftShift = a &lt;&lt; 1;  // 1010 (10 in decimal)\nint rightShift = a &gt;&gt; 1; // 010 (2 in decimal)\n</code></pre>"},{"location":"java/java-basics/#ternary-operator","title":"Ternary Operator","text":"<pre><code>int age = 20;\nString status = (age &gt;= 18) ? \"Adult\" : \"Minor\";\n</code></pre>"},{"location":"java/java-basics/#control-flow","title":"Control Flow","text":""},{"location":"java/java-basics/#conditional-statements","title":"Conditional Statements","text":"<pre><code>// if statement\nif (condition) {\n    // code to execute if condition is true\n}\n\n// if-else statement\nif (condition) {\n    // code to execute if condition is true\n} else {\n    // code to execute if condition is false\n}\n\n// if-else-if ladder\nif (condition1) {\n    // code to execute if condition1 is true\n} else if (condition2) {\n    // code to execute if condition1 is false but condition2 is true\n} else {\n    // code to execute if both conditions are false\n}\n</code></pre> <p>Example: <pre><code>int score = 85;\n\nif (score &gt;= 90) {\n    System.out.println(\"Grade: A\");\n} else if (score &gt;= 80) {\n    System.out.println(\"Grade: B\");\n} else if (score &gt;= 70) {\n    System.out.println(\"Grade: C\");\n} else if (score &gt;= 60) {\n    System.out.println(\"Grade: D\");\n} else {\n    System.out.println(\"Grade: F\");\n}\n</code></pre></p>"},{"location":"java/java-basics/#switch-statement","title":"Switch Statement","text":"<p>Traditional switch: <pre><code>int day = 3;\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    // ... other cases\n    default:\n        System.out.println(\"Invalid day\");\n}\n</code></pre></p> <p>Enhanced switch (Java 12+): <pre><code>int day = 3;\nswitch (day) {\n    case 1 -&gt; System.out.println(\"Monday\");\n    case 2 -&gt; System.out.println(\"Tuesday\");\n    case 3 -&gt; System.out.println(\"Wednesday\");\n    // ... other cases\n    default -&gt; System.out.println(\"Invalid day\");\n}\n\n// With assignment\nString dayName = switch (day) {\n    case 1 -&gt; \"Monday\";\n    case 2 -&gt; \"Tuesday\";\n    case 3 -&gt; \"Wednesday\";\n    // ... other cases\n    default -&gt; \"Invalid day\";\n};\n</code></pre></p>"},{"location":"java/java-basics/#loops","title":"Loops","text":"<pre><code>// for loop\nfor (int i = 0; i &lt; 5; i++) {\n    System.out.println(i);\n}\n\n// enhanced for loop (for-each)\nint[] numbers = {1, 2, 3, 4, 5};\nfor (int num : numbers) {\n    System.out.println(num);\n}\n\n// while loop\nint i = 0;\nwhile (i &lt; 5) {\n    System.out.println(i);\n    i++;\n}\n\n// do-while loop\nint j = 0;\ndo {\n    System.out.println(j);\n    j++;\n} while (j &lt; 5);\n</code></pre>"},{"location":"java/java-basics/#control-statements","title":"Control Statements","text":"<pre><code>// break - exits the loop\nfor (int i = 0; i &lt; 10; i++) {\n    if (i == 5) {\n        break; // exits loop when i is 5\n    }\n    System.out.println(i);\n}\n\n// continue - skips current iteration\nfor (int i = 0; i &lt; 10; i++) {\n    if (i % 2 == 0) {\n        continue; // skips even numbers\n    }\n    System.out.println(i);\n}\n</code></pre>"},{"location":"java/java-basics/#arrays","title":"Arrays","text":"<p>Arrays are fixed-size collections of elements of the same type.</p>"},{"location":"java/java-basics/#array-declaration-and-initialization","title":"Array Declaration and Initialization","text":"<pre><code>// Declaration\nint[] numbers;\nString[] names;\n\n// Initialization\nnumbers = new int[5]; // Creates array of 5 integers initialized to 0\nnames = new String[3]; // Creates array of 3 strings initialized to null\n\n// Declaration and initialization combined\nint[] scores = new int[5];\nint[] values = {10, 20, 30, 40, 50}; // Shorthand initialization\n\n// Multidimensional arrays\nint[][] matrix = new int[3][3]; // 3x3 matrix\nint[][] irregularArray = {\n    {1, 2},\n    {3, 4, 5},\n    {6}\n};\n</code></pre>"},{"location":"java/java-basics/#accessing-and-modifying-arrays","title":"Accessing and Modifying Arrays","text":"<pre><code>int[] numbers = {10, 20, 30, 40, 50};\n\n// Accessing elements (0-indexed)\nint firstNumber = numbers[0]; // 10\nint thirdNumber = numbers[2]; // 30\n\n// Modifying elements\nnumbers[1] = 25; // Changes 20 to 25\n\n// Array length\nint length = numbers.length; // 5\n\n// Iterating through an array\nfor (int i = 0; i &lt; numbers.length; i++) {\n    System.out.println(numbers[i]);\n}\n\n// Enhanced for-loop (for-each)\nfor (int number : numbers) {\n    System.out.println(number);\n}\n</code></pre>"},{"location":"java/java-basics/#common-array-operations","title":"Common Array Operations","text":"<pre><code>// Copying arrays\nint[] source = {1, 2, 3, 4, 5};\nint[] dest = new int[source.length];\nSystem.arraycopy(source, 0, dest, 0, source.length);\n\n// Alternative copying methods\nint[] copy1 = Arrays.copyOf(source, source.length);\nint[] copy2 = Arrays.copyOfRange(source, 1, 4); // {2, 3, 4}\n\n// Sorting arrays\nint[] unsorted = {5, 3, 1, 4, 2};\nArrays.sort(unsorted); // {1, 2, 3, 4, 5}\n\n// Searching (on sorted arrays)\nint index = Arrays.binarySearch(unsorted, 3); // 2\n\n// Filling arrays\nint[] filled = new int[5];\nArrays.fill(filled, 10); // {10, 10, 10, 10, 10}\n\n// Comparing arrays\nboolean areEqual = Arrays.equals(source, copy1); // true\n</code></pre>"},{"location":"java/java-basics/#java-packages","title":"Java Packages","text":"<p>Packages organize related classes and interfaces, providing namespace management and access control.</p>"},{"location":"java/java-basics/#creating-and-using-packages","title":"Creating and Using Packages","text":"<pre><code>// File: com/example/util/MathHelper.java\npackage com.example.util;\n\npublic class MathHelper {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n\n// Using the package in another file\nimport com.example.util.MathHelper;\n\npublic class Main {\n    public static void main(String[] args) {\n        int sum = MathHelper.add(5, 3);\n        System.out.println(\"Sum: \" + sum);\n    }\n}\n</code></pre>"},{"location":"java/java-basics/#common-java-packages","title":"Common Java Packages","text":"<ul> <li><code>java.lang</code>: Fundamental classes (automatically imported)</li> <li><code>java.util</code>: Collections, date/time, random numbers, etc.</li> <li><code>java.io</code>: Input/output operations</li> <li><code>java.nio</code>: Enhanced I/O operations</li> <li><code>java.net</code>: Networking capabilities</li> <li><code>java.sql</code>: Database access</li> <li><code>java.text</code>: Text processing utilities</li> <li><code>java.math</code>: Precise mathematical operations</li> <li><code>java.time</code>: Date and time API (Java 8+)</li> </ul>"},{"location":"java/java-basics/#input-and-output-basics","title":"Input and Output Basics","text":""},{"location":"java/java-basics/#console-output","title":"Console Output","text":"<pre><code>// Print without a newline\nSystem.out.print(\"Hello\");\n\n// Print with a newline\nSystem.out.println(\"Hello, World!\");\n\n// Formatted output\nSystem.out.printf(\"Name: %s, Age: %d%n\", \"John\", 25);\n</code></pre>"},{"location":"java/java-basics/#console-input-using-scanner","title":"Console Input (using Scanner)","text":"<pre><code>import java.util.Scanner;\n\npublic class InputExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"Enter your name: \");\n        String name = scanner.nextLine();\n\n        System.out.print(\"Enter your age: \");\n        int age = scanner.nextInt();\n\n        System.out.println(\"Hello, \" + name + \"! You are \" + age + \" years old.\");\n\n        scanner.close(); // Always close the scanner when done\n    }\n}\n</code></pre>"},{"location":"java/java-basics/#naming-conventions","title":"Naming Conventions","text":"<p>Java uses specific naming conventions for clarity and consistency:</p> <ul> <li>Classes and Interfaces: PascalCase (e.g., <code>CustomerService</code>, <code>Runnable</code>)</li> <li>Methods and Variables: camelCase (e.g., <code>getUserName()</code>, <code>totalAmount</code>)</li> <li>Constants: UPPER_SNAKE_CASE (e.g., <code>MAX_VALUE</code>, <code>PI</code>)</li> <li>Packages: lowercase, domain-reversed (e.g., <code>com.example.project</code>)</li> </ul>"},{"location":"java/java-basics/#best-practices","title":"Best Practices","text":"<ol> <li>Follow naming conventions consistently</li> <li>Initialize variables when declared, when possible</li> <li>Use constants (<code>final</code> variables) for fixed values</li> <li>Avoid magic numbers - use named constants</li> <li>Handle exceptions appropriately</li> <li>Close resources (like Scanner) when done</li> <li>Comment your code meaningfully</li> <li>Break complex operations into smaller methods</li> <li>Use enhanced for-loops for arrays when possible</li> <li>Validate input before processing</li> </ol>"},{"location":"java/java-basics/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":"<ol> <li>Forgetting semicolons: Always end statements with semicolons</li> <li>Mismatching braces: Use an IDE with brace matching</li> <li>Off-by-one errors in loops: Be careful with zero-based indexing</li> <li>Integer division truncation:     <pre><code>double result = 5 / 2; // 2.0 (not 2.5)\ndouble correctResult = 5.0 / 2; // 2.5\n</code></pre></li> <li>Neglecting resource cleanup: Use try-with-resources</li> <li>Comparing Strings with ==: Use <code>equals()</code> method instead    <pre><code>String a = \"hello\";\nString b = new String(\"hello\");\n\nif (a == b) { // Wrong! Compares references\n    // This won't execute\n}\n\nif (a.equals(b)) { // Correct! Compares content\n    // This will execute\n}\n</code></pre></li> <li>Mutable objects in loops: Be careful with modifying objects while iterating</li> <li>Importing every class with <code>import java.util.*</code>: Import specific classes</li> </ol>"},{"location":"java/java-basics/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>Oracle Java Documentation</li> <li> <p>Java SE 17 API Specification</p> </li> <li> <p>Books:</p> </li> <li>\"Effective Java\" by Joshua Bloch</li> <li>\"Java: The Complete Reference\" by Herbert Schildt</li> <li> <p>\"Head First Java\" by Kathy Sierra and Bert Bates</p> </li> <li> <p>Online Courses:</p> </li> <li>Codecademy Java Course</li> <li>Coursera - Object-Oriented Programming in Java</li> <li> <p>Udemy - Java Programming Masterclass</p> </li> <li> <p>Practice Platforms:</p> </li> <li>HackerRank - Java</li> <li>LeetCode</li> <li>Codewars</li> </ol>"},{"location":"java/java-basics/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>Hello User:    Write a program that asks for the user's name and greets them with a personalized message.</p> </li> <li> <p>Number Classifier:    Create a program that takes a number as input and classifies it as positive, negative, or zero.</p> </li> <li> <p>FizzBuzz:    Write a program that prints numbers from 1 to 100, but for multiples of 3 prints \"Fizz,\" for multiples of 5 prints \"Buzz,\" and for multiples of both prints \"FizzBuzz.\"</p> </li> <li> <p>Calculator:    Implement a simple calculator that can perform addition, subtraction, multiplication, and division on two numbers.</p> </li> <li> <p>Array Operations:    Create a program that performs basic operations on an array: find the minimum, maximum, sum, and average.</p> </li> <li> <p>Word Counter:    Write a program that counts the number of words in a given text.</p> </li> <li> <p>Guessing Game:    Implement a number guessing game where the program generates a random number and the user tries to guess it.</p> </li> <li> <p>Temperature Converter:    Create a program that converts temperatures between Celsius and Fahrenheit.</p> </li> <li> <p>Prime Number Checker:    Write a program that checks if a number is prime or not.</p> </li> <li> <p>Palindrome Detector:     Implement a program that determines if a given word or phrase is a palindrome. </p> </li> </ol>"},{"location":"java/java-collections/","title":"Macro Syntax Error","text":"<p>File: <code>java/java-collections.md</code></p> <p>Line 578 in Markdown file: unexpected '}' <pre><code>int[][] matrix1 = {{1, 2}, {3, 4}};\n</code></pre></p>"},{"location":"java/java-concurrency/","title":"Java Concurrency","text":""},{"location":"java/java-concurrency/#overview","title":"Overview","text":"<p>This guide covers Java's concurrency model and multithreading capabilities. Concurrent programming allows multiple processes or threads to execute simultaneously, improving application performance, responsiveness, and resource utilization. Java provides robust APIs and utilities for thread management, synchronization, and concurrent data structures.</p>"},{"location":"java/java-concurrency/#prerequisites","title":"Prerequisites","text":"<ul> <li>Solid understanding of Java core concepts</li> <li>Familiarity with object-oriented programming</li> <li>Basic knowledge of Java memory model</li> <li>Understanding of Java collections framework</li> </ul>"},{"location":"java/java-concurrency/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand fundamental concurrent programming concepts</li> <li>Create and manage threads in Java</li> <li>Apply synchronization techniques to prevent race conditions</li> <li>Utilize Java's high-level concurrency utilities</li> <li>Design thread-safe classes and data structures</li> <li>Implement executor services and thread pools</li> <li>Apply concurrent collections for multithreaded applications</li> <li>Understand atomic operations and non-blocking algorithms</li> <li>Recognize and avoid common concurrency pitfalls</li> </ul>"},{"location":"java/java-concurrency/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Concurrency Fundamentals</li> <li>Thread Basics</li> <li>Thread Synchronization</li> <li>Java Memory Model</li> <li>Lock Mechanisms</li> <li>Executor Framework</li> <li>Concurrent Collections</li> <li>Atomic Variables</li> <li>CompletableFuture API</li> <li>Best Practices</li> </ol>"},{"location":"java/java-concurrency/#concurrency-fundamentals","title":"Concurrency Fundamentals","text":""},{"location":"java/java-concurrency/#processes-vs-threads","title":"Processes vs Threads","text":"<ul> <li>Process: Self-contained execution environment with its own memory space</li> <li>Thread: Lightweight execution unit within a process that shares memory with other threads</li> </ul>"},{"location":"java/java-concurrency/#concurrency-vs-parallelism","title":"Concurrency vs Parallelism","text":"<ul> <li>Concurrency: Handling multiple tasks by switching between them (time-slicing)</li> <li>Parallelism: Executing multiple tasks simultaneously (requires multiple CPU cores)</li> </ul>"},{"location":"java/java-concurrency/#benefits-of-multithreading","title":"Benefits of Multithreading","text":"<ul> <li>Improved responsiveness: UI remains responsive while background operations execute</li> <li>Resource efficiency: CPU utilization improved during I/O operations</li> <li>Throughput: Executing multiple tasks simultaneously on multicore systems</li> </ul>"},{"location":"java/java-concurrency/#challenges-in-concurrent-programming","title":"Challenges in Concurrent Programming","text":"<ul> <li>Race conditions: Unpredictable results when two threads access shared data simultaneously</li> <li>Deadlocks: Two or more threads waiting indefinitely for resources held by each other</li> <li>Livelocks: Threads respond to each other without making progress</li> <li>Thread starvation: Threads denied necessary resources to progress</li> <li>Thread interference: One thread's operations affect another thread's operations</li> </ul>"},{"location":"java/java-concurrency/#thread-basics","title":"Thread Basics","text":""},{"location":"java/java-concurrency/#creating-threads","title":"Creating Threads","text":"<p>Java provides two primary ways to create threads:</p>"},{"location":"java/java-concurrency/#1-extending-the-thread-class","title":"1. Extending the Thread class","text":"<pre><code>public class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running: \" + Thread.currentThread().getName());\n        // Thread logic here\n    }\n\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        thread.start(); // Starts the thread\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#2-implementing-the-runnable-interface-preferred","title":"2. Implementing the Runnable interface (preferred)","text":"<pre><code>public class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running: \" + Thread.currentThread().getName());\n        // Thread logic here\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyRunnable());\n        thread.start(); // Starts the thread\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#3-using-lambda-expressions-java-8","title":"3. Using lambda expressions (Java 8+)","text":"<pre><code>public class LambdaThread {\n    public static void main(String[] args) {\n        Runnable task = () -&gt; {\n            System.out.println(\"Thread running: \" + Thread.currentThread().getName());\n            // Thread logic here\n        };\n\n        Thread thread = new Thread(task);\n        thread.start();\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#thread-lifecycle","title":"Thread Lifecycle","text":"<p>A thread goes through various states during its lifetime:</p> <ol> <li>NEW: Thread created but not started</li> <li>RUNNABLE: Thread is executing or ready to execute</li> <li>BLOCKED: Thread waiting to acquire a monitor lock</li> <li>WAITING: Thread waiting indefinitely for another thread</li> <li>TIMED_WAITING: Thread waiting for a specified time</li> <li>TERMINATED: Thread completed execution</li> </ol> <pre><code>// Example of tracking thread states\npublic class ThreadStates {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(() -&gt; {\n            try {\n                Thread.sleep(2000); // TIMED_WAITING\n                synchronized (ThreadStates.class) {\n                    ThreadStates.class.wait(); // WAITING\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        System.out.println(\"After creation: \" + thread.getState()); // NEW\n\n        thread.start();\n        System.out.println(\"After start: \" + thread.getState()); // RUNNABLE\n\n        Thread.sleep(1000);\n        System.out.println(\"After sleep: \" + thread.getState()); // TIMED_WAITING\n\n        // Eventually thread terminates...\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#thread-methods","title":"Thread Methods","text":"<pre><code>Thread thread = new Thread(() -&gt; {\n    // Thread logic\n});\n\nthread.start();               // Start thread execution\nthread.setName(\"WorkerThread\"); // Set thread name\nthread.setPriority(Thread.MAX_PRIORITY); // Set thread priority (1-10)\nthread.setDaemon(true);       // Set as daemon thread\nthread.interrupt();           // Interrupt the thread\nthread.join();                // Wait for thread to complete\nthread.join(1000);            // Wait for thread to complete with timeout\n</code></pre>"},{"location":"java/java-concurrency/#sleep-yield-and-join","title":"Sleep, Yield, and Join","text":"<pre><code>// Sleep: Pause thread execution\ntry {\n    Thread.sleep(1000); // Pause for 1 second\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n\n// Yield: Hint that thread can pause\nThread.yield();\n\n// Join: Wait for another thread to complete\nThread worker = new Thread(() -&gt; {\n    // Long-running task\n});\nworker.start();\n\ntry {\n    worker.join(); // Wait for worker to complete\n    // Code here executes after worker is done\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n</code></pre>"},{"location":"java/java-concurrency/#thread-synchronization","title":"Thread Synchronization","text":""},{"location":"java/java-concurrency/#race-conditions","title":"Race Conditions","text":"<p>Race conditions occur when multiple threads access and modify shared data simultaneously, causing unpredictable results.</p> <pre><code>// Example of a race condition\npublic class Counter {\n    private int count = 0;\n\n    // Not thread-safe\n    public void increment() {\n        count++;  // This is not an atomic operation\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) {\n                counter.increment();\n            }\n        });\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) {\n                counter.increment();\n            }\n        });\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n        // Expected: 2000, Actual: potentially less due to race condition\n        System.out.println(\"Count: \" + counter.getCount());\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#synchronized-methods","title":"Synchronized Methods","text":"<p>The <code>synchronized</code> keyword provides intrinsic locks to prevent multiple threads from executing a critical section simultaneously.</p> <pre><code>public class SynchronizedCounter {\n    private int count = 0;\n\n    // Thread-safe method\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#synchronized-blocks","title":"Synchronized Blocks","text":"<p>For finer-grained control, use synchronized blocks to lock specific objects or sections of code.</p> <pre><code>public class SynchronizedBlockExample {\n    private final Object lockObject = new Object();\n    private int count = 0;\n\n    public void increment() {\n        synchronized (lockObject) {\n            count++;\n        }\n    }\n\n    public int getCount() {\n        synchronized (lockObject) {\n            return count;\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#volatile-keyword","title":"Volatile Keyword","text":"<p>The <code>volatile</code> keyword ensures visibility of changes to variables across threads.</p> <pre><code>public class VolatileExample {\n    private volatile boolean running = true;\n\n    public void stop() {\n        running = false;\n    }\n\n    public void process() {\n        while (running) {\n            // Do work\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#thread-cooperation","title":"Thread Cooperation","text":"<p>Wait and notify methods allow threads to communicate with each other.</p> <pre><code>public class WaitNotifyExample {\n    private final List&lt;String&gt; buffer = new ArrayList&lt;&gt;();\n    private final int MAX_SIZE = 10;\n\n    public synchronized void produce(String item) throws InterruptedException {\n        while (buffer.size() == MAX_SIZE) {\n            wait(); // Wait until buffer has space\n        }\n        buffer.add(item);\n        notifyAll(); // Notify consumers that item is available\n    }\n\n    public synchronized String consume() throws InterruptedException {\n        while (buffer.isEmpty()) {\n            wait(); // Wait until buffer has an item\n        }\n        String item = buffer.remove(0);\n        notifyAll(); // Notify producers that space is available\n        return item;\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#java-memory-model","title":"Java Memory Model","text":""},{"location":"java/java-concurrency/#happens-before-relationship","title":"Happens-Before Relationship","text":"<p>The Java Memory Model defines a partial ordering of operations called \"happens-before,\" which ensures visibility of memory operations across threads.</p> <p>Key happens-before relationships: - Program order: Actions in a thread happen before subsequent actions in that thread - Monitor lock: <code>unlock</code> happens before subsequent <code>lock</code> of the same monitor - Volatile field: Write to a volatile field happens before subsequent reads - Thread start: <code>start()</code> happens before any actions in the started thread - Thread termination: All actions in a thread happen before detection of thread termination - Transitivity: If A happens before B, and B happens before C, then A happens before C</p>"},{"location":"java/java-concurrency/#memory-visibility","title":"Memory Visibility","text":"<p>Memory visibility ensures that changes made by one thread are visible to other threads.</p> <pre><code>public class MemoryVisibilityExample {\n    private int number;\n    private volatile boolean ready;\n\n    // Writer thread\n    public void writer() {\n        number = 42;\n        ready = true; // Volatile write ensures visibility of number=42\n    }\n\n    // Reader thread\n    public void reader() {\n        if (ready) { // Volatile read\n            // Due to happens-before, this thread will see number=42\n            System.out.println(number);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#lock-mechanisms","title":"Lock Mechanisms","text":""},{"location":"java/java-concurrency/#reentrantlock","title":"ReentrantLock","text":"<p><code>ReentrantLock</code> provides more flexibility than synchronized blocks, with capabilities like timed lock acquisition and interruptible locks.</p> <pre><code>import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockExample {\n    private final Lock lock = new ReentrantLock();\n    private int count = 0;\n\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // Always unlock in finally block\n        }\n    }\n\n    public int getCount() {\n        lock.lock();\n        try {\n            return count;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // Trylock example\n    public boolean incrementIfAvailable() {\n        if (lock.tryLock()) {\n            try {\n                count++;\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#readwritelock","title":"ReadWriteLock","text":"<p><code>ReadWriteLock</code> allows multiple readers but only a single writer at a time.</p> <pre><code>import java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class ReadWriteLockExample {\n    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n    private final Map&lt;String, String&gt; data = new HashMap&lt;&gt;();\n\n    public void put(String key, String value) {\n        rwLock.writeLock().lock();\n        try {\n            data.put(key, value);\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n\n    public String get(String key) {\n        rwLock.readLock().lock();\n        try {\n            return data.get(key);\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#stampedlock-java-8","title":"StampedLock (Java 8+)","text":"<p><code>StampedLock</code> provides optimistic reading, which allows multiple readers and possibility to upgrade to write lock.</p> <pre><code>import java.util.concurrent.locks.StampedLock;\n\npublic class StampedLockExample {\n    private final StampedLock lock = new StampedLock();\n    private double x, y;\n\n    public void move(double deltaX, double deltaY) {\n        long stamp = lock.writeLock();\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            lock.unlockWrite(stamp);\n        }\n    }\n\n    public double distanceFromOrigin() {\n        // Optimistic read\n        long stamp = lock.tryOptimisticRead();\n        double currentX = x;\n        double currentY = y;\n\n        // Check if the stamp is still valid (no writes occurred)\n        if (!lock.validate(stamp)) {\n            // Fall back to pessimistic read lock\n            stamp = lock.readLock();\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                lock.unlockRead(stamp);\n            }\n        }\n\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#executor-framework","title":"Executor Framework","text":"<p>The Executor Framework separates task submission from execution, providing a flexible thread management system.</p>"},{"location":"java/java-concurrency/#executor-and-executorservice","title":"Executor and ExecutorService","text":"<pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ExecutorExample {\n    public static void main(String[] args) {\n        // Create an executor with a fixed thread pool of 3 threads\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n\n        // Submit tasks\n        for (int i = 0; i &lt; 10; i++) {\n            final int taskId = i;\n            executor.submit(() -&gt; {\n                System.out.println(\"Task \" + taskId + \" executed by \" \n                    + Thread.currentThread().getName());\n            });\n        }\n\n        // Shutdown the executor (no new tasks accepted)\n        executor.shutdown();\n\n        // Alternative: Shutdown and wait for tasks to complete\n        // executor.awaitTermination(5, TimeUnit.SECONDS);\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#types-of-executors","title":"Types of Executors","text":"<pre><code>// Fixed thread pool - fixed number of threads\nExecutorService fixedPool = Executors.newFixedThreadPool(4);\n\n// Cached thread pool - creates new threads as needed, reuses idle threads\nExecutorService cachedPool = Executors.newCachedThreadPool();\n\n// Single thread executor - single worker thread\nExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();\n\n// Scheduled executor - for delayed or periodic tasks\nScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(2);\n</code></pre>"},{"location":"java/java-concurrency/#scheduled-tasks","title":"Scheduled Tasks","text":"<pre><code>import java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScheduledExecutorExample {\n    public static void main(String[] args) {\n        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\n        // Execute after 5 seconds delay\n        scheduler.schedule(() -&gt; System.out.println(\"Delayed task\"), \n                           5, TimeUnit.SECONDS);\n\n        // Execute every 2 seconds, starting after 0 seconds\n        scheduler.scheduleAtFixedRate(() -&gt; System.out.println(\"Fixed rate task\"), \n                                     0, 2, TimeUnit.SECONDS);\n\n        // Execute every 2 seconds after previous completion\n        scheduler.scheduleWithFixedDelay(() -&gt; System.out.println(\"Fixed delay task\"), \n                                       0, 2, TimeUnit.SECONDS);\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#future-and-callable","title":"Future and Callable","text":"<p><code>Future</code> represents the result of an asynchronous computation, and <code>Callable</code> is similar to <code>Runnable</code> but can return a value.</p> <pre><code>import java.util.concurrent.*;\n\npublic class FutureExample {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService executor = Executors.newFixedThreadPool(1);\n\n        // Submit Callable task that returns a value\n        Future&lt;Integer&gt; future = executor.submit(() -&gt; {\n            Thread.sleep(2000); // Simulate long computation\n            return 42;\n        });\n\n        // Do other work while the task is executing\n        System.out.println(\"Waiting for result...\");\n\n        // Block and get the result (with optional timeout)\n        Integer result = future.get(3, TimeUnit.SECONDS);\n        System.out.println(\"Result: \" + result);\n\n        executor.shutdown();\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#concurrent-collections","title":"Concurrent Collections","text":"<p>Java provides specialized collections designed for concurrent access.</p>"},{"location":"java/java-concurrency/#concurrenthashmap","title":"ConcurrentHashMap","text":"<p>Thread-safe alternative to HashMap without locking the entire map.</p> <pre><code>import java.util.concurrent.ConcurrentHashMap;\n\npublic class ConcurrentMapExample {\n    public static void main(String[] args) {\n        ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();\n\n        // Thread-safe operations\n        map.put(\"one\", 1);\n        map.put(\"two\", 2);\n\n        // Atomic operations\n        map.putIfAbsent(\"three\", 3);\n        map.replace(\"two\", 2, 22);\n\n        // Aggregate operations (Java 8+)\n        map.forEach((k, v) -&gt; System.out.println(k + \" = \" + v));\n\n        // Compute methods\n        map.compute(\"four\", (k, v) -&gt; v == null ? 4 : v + 1);\n        map.computeIfAbsent(\"five\", k -&gt; 5);\n        map.computeIfPresent(\"one\", (k, v) -&gt; v + 10);\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#copyonwritearraylist","title":"CopyOnWriteArrayList","text":"<p>Thread-safe variant of ArrayList optimized for read-heavy workloads.</p> <pre><code>import java.util.concurrent.CopyOnWriteArrayList;\n\npublic class CopyOnWriteExample {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n        list.add(\"one\");\n        list.add(\"two\");\n\n        // Safe iteration during concurrent modification\n        for (String item : list) {\n            System.out.println(item);\n            list.add(\"three\"); // Won't affect current iteration\n        }\n\n        System.out.println(\"Final size: \" + list.size());\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#blockingqueue","title":"BlockingQueue","text":"<p>Queue that supports operations that wait for the queue to become non-empty or non-full.</p> <pre><code>import java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\npublic class BlockingQueueExample {\n    public static void main(String[] args) {\n        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(10);\n\n        // Producer thread\n        new Thread(() -&gt; {\n            try {\n                for (int i = 0; i &lt; 20; i++) {\n                    String item = \"Item-\" + i;\n                    queue.put(item); // Blocks if queue is full\n                    System.out.println(\"Produced: \" + item);\n                    Thread.sleep(100);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }).start();\n\n        // Consumer thread\n        new Thread(() -&gt; {\n            try {\n                while (true) {\n                    String item = queue.take(); // Blocks if queue is empty\n                    System.out.println(\"Consumed: \" + item);\n                    Thread.sleep(300);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }).start();\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#atomic-variables","title":"Atomic Variables","text":"<p>Atomic variables provide lock-free, thread-safe operations on single variables.</p> <pre><code>import java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class AtomicExample {\n    public static void main(String[] args) {\n        // Atomic primitive types\n        AtomicInteger counter = new AtomicInteger(0);\n\n        counter.incrementAndGet(); // Atomic increment and get\n        counter.getAndIncrement(); // Get and atomic increment\n        counter.addAndGet(5);      // Atomic add and get\n        counter.compareAndSet(6, 10); // Compare and set if equal\n\n        System.out.println(\"Counter: \" + counter.get());\n\n        // Atomic reference\n        AtomicReference&lt;String&gt; reference = new AtomicReference&lt;&gt;(\"initial\");\n        reference.set(\"updated\");\n        reference.compareAndSet(\"updated\", \"final\");\n\n        System.out.println(\"Reference: \" + reference.get());\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#completablefuture-api","title":"CompletableFuture API","text":"<p>Java 8 introduced CompletableFuture for asynchronous programming with a composable, functional style.</p> <pre><code>import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class CompletableFutureExample {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // Creating a CompletableFuture\n        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            return \"Hello\";\n        });\n\n        // Transform the result\n        CompletableFuture&lt;String&gt; greetingFuture = future.thenApply(s -&gt; s + \" World\");\n\n        // Chain another asynchronous operation\n        CompletableFuture&lt;String&gt; completedFuture = greetingFuture.thenCompose(s -&gt; \n            CompletableFuture.supplyAsync(() -&gt; s + \"!\"));\n\n        // Handle errors\n        CompletableFuture&lt;String&gt; safeFuture = completedFuture.exceptionally(ex -&gt; {\n            System.err.println(\"Error: \" + ex.getMessage());\n            return \"Error occurred\";\n        });\n\n        // Combine two futures\n        CompletableFuture&lt;Integer&gt; anotherFuture = CompletableFuture.supplyAsync(() -&gt; 42);\n        CompletableFuture&lt;String&gt; combinedFuture = safeFuture.thenCombine(\n            anotherFuture,\n            (s, i) -&gt; s + \" - \" + i\n        );\n\n        // Execute callback when complete\n        combinedFuture.thenAccept(System.out::println);\n\n        // Block and get the result\n        String result = combinedFuture.get();\n        System.out.println(\"Final result: \" + result);\n    }\n}\n</code></pre>"},{"location":"java/java-concurrency/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Prefer higher-level concurrency utilities over raw threads and <code>synchronized</code> <pre><code>// Instead of managing threads directly\nExecutorService executor = Executors.newFixedThreadPool(nThreads);\n</code></pre></p> </li> <li> <p>Use thread pools to limit resource consumption and improve performance    <pre><code>// Good - reuse threads\nExecutorService executor = Executors.newFixedThreadPool(\n    Runtime.getRuntime().availableProcessors()); \n</code></pre></p> </li> <li> <p>Prefer concurrent collections over synchronized collections for better scalability    <pre><code>// Better performance under concurrent access\nMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();\n// vs\nMap&lt;String, String&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;&gt;());\n</code></pre></p> </li> <li> <p>Minimize lock scope - lock only what's necessary for the shortest time    <pre><code>// Bad - locking too much\npublic synchronized void processList(List&lt;Item&gt; items) {\n    // Process each item (locking the entire method)\n}\n\n// Better - lock only the critical section\npublic void processList(List&lt;Item&gt; items) {\n    for (Item item : items) {\n        // Process item outside of lock\n        synchronized (this) {\n            // Update shared state\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Use atomic variables for simple counters and flags    <pre><code>// Better than synchronized for simple operations\nAtomicInteger counter = new AtomicInteger();\n</code></pre></p> </li> <li> <p>Avoid using Thread.stop(), Thread.suspend(), and Thread.resume() as they are deprecated and unsafe</p> </li> <li> <p>Always catch InterruptedException and restore the interrupt status <pre><code>try {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    // Restore interrupt status\n    Thread.currentThread().interrupt();\n    // Handle appropriately\n}\n</code></pre></p> </li> <li> <p>Use thread-local variables for thread-confined data    <pre><code>private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = \n    ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(\"yyyy-MM-dd\"));\n</code></pre></p> </li> <li> <p>Avoid unnecessary object creation in concurrent code    <pre><code>// Create outside loop to avoid garbage collection pressure\nStringBuilder builder = new StringBuilder();\nfor (int i = 0; i &lt; 1000; i++) {\n    builder.setLength(0); // Reset instead of creating new instance\n    builder.append(\"Item \").append(i);\n    process(builder.toString());\n}\n</code></pre></p> </li> <li> <p>Design immutable classes when possible for thread safety     <pre><code>// Immutable class is inherently thread-safe\npublic final class Point {\n    private final int x;\n    private final int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() { return x; }\n    public int getY() { return y; }\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-concurrency/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":""},{"location":"java/java-concurrency/#1-race-conditions","title":"1. Race Conditions","text":"<p>Problem: Multiple threads accessing shared data concurrently may lead to inconsistent state.</p> <p>Solution: Use proper synchronization, locks, or atomic variables. <pre><code>// Safe increment with synchronized\npublic synchronized void increment() {\n    count++;\n}\n\n// Or with AtomicInteger\nprivate AtomicInteger count = new AtomicInteger();\npublic void increment() {\n    count.incrementAndGet();\n}\n</code></pre></p>"},{"location":"java/java-concurrency/#2-deadlocks","title":"2. Deadlocks","text":"<p>Problem: Two or more threads waiting for locks held by each other.</p> <p>Solution: Always acquire locks in a consistent order. <pre><code>// Potential deadlock (Thread A gets lock1 then lock2, Thread B gets lock2 then lock1)\nsynchronized (lock1) {\n    synchronized (lock2) {\n        // ...\n    }\n}\n\n// Fix: Always acquire locks in consistent order\n// All threads should acquire lock1 first, then lock2\n</code></pre></p>"},{"location":"java/java-concurrency/#3-thread-leaks","title":"3. Thread Leaks","text":"<p>Problem: Threads not properly shutdown, consuming resources.</p> <p>Solution: Always properly shut down executor services and threads. <pre><code>ExecutorService executor = Executors.newFixedThreadPool(nThreads);\ntry {\n    // Submit tasks\n} finally {\n    executor.shutdown();\n    try {\n        if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n            executor.shutdownNow();\n        }\n    } catch (InterruptedException e) {\n        executor.shutdownNow();\n        Thread.currentThread().interrupt();\n    }\n}\n</code></pre></p>"},{"location":"java/java-concurrency/#4-memory-leaks-in-threadlocal","title":"4. Memory Leaks in ThreadLocal","text":"<p>Problem: ThreadLocal variables not properly removed can cause memory leaks.</p> <p>Solution: Always call remove() when done with ThreadLocal variables. <pre><code>ThreadLocal&lt;Resource&gt; resourceHolder = new ThreadLocal&lt;&gt;();\ntry {\n    resourceHolder.set(new Resource());\n    // Use the resource\n} finally {\n    resourceHolder.remove(); // Clean up\n}\n</code></pre></p>"},{"location":"java/java-concurrency/#5-busy-waiting","title":"5. Busy Waiting","text":"<p>Problem: Actively checking a condition in a loop wastes CPU.</p> <p>Solution: Use proper waiting mechanisms. <pre><code>// Bad: Busy waiting\nwhile (!condition) {\n    // Waste CPU cycles\n}\n\n// Good: Use proper waiting\nsynchronized (lock) {\n    while (!condition) {\n        lock.wait();\n    }\n}\n</code></pre></p>"},{"location":"java/java-concurrency/#6-double-checked-locking-issues","title":"6. Double-Checked Locking Issues","text":"<p>Problem: Incorrect implementation can lead to partially initialized objects.</p> <p>Solution: Use volatile or synchronized correctly. <pre><code>// Correct double-checked locking with volatile\nprivate volatile Singleton instance;\n\npublic Singleton getInstance() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance;\n}\n\n// Better: Use holder class idiom\npublic class Singleton {\n    private Singleton() {}\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n</code></pre></p>"},{"location":"java/java-concurrency/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>Java Concurrency in Practice</li> <li> <p>Java SE Documentation: java.util.concurrent</p> </li> <li> <p>Books:</p> </li> <li>\"Java Concurrency in Practice\" by Brian Goetz</li> <li>\"Concurrent Programming in Java\" by Doug Lea</li> <li> <p>\"Seven Concurrency Models in Seven Weeks\" by Paul Butcher</p> </li> <li> <p>Online Resources:</p> </li> <li>Baeldung Concurrency Guides</li> <li>Jakob Jenkov's Java Concurrency Tutorial</li> <li> <p>IBM Developer: Java Concurrency</p> </li> <li> <p>Practice Platforms:</p> </li> <li>LeetCode Concurrency Problems</li> <li>Coursera: Parallel, Concurrent, and Distributed Programming in Java</li> </ol>"},{"location":"java/java-concurrency/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>Thread-Safe Counter:    Implement a thread-safe counter class using different synchronization mechanisms (synchronized, AtomicInteger, Lock).</p> </li> <li> <p>Producer-Consumer Pattern:    Create a producer-consumer scenario using BlockingQueue.</p> </li> <li> <p>Resource Pool:    Implement a thread-safe resource pool that manages a fixed number of resources.</p> </li> <li> <p>Web Crawler:    Build a concurrent web crawler that downloads and processes web pages in parallel.</p> </li> <li> <p>Task Scheduler:    Create a task scheduler that executes tasks at specified intervals.</p> </li> <li> <p>Concurrent File Processor:    Implement a program that concurrently processes large files.</p> </li> <li> <p>Bank Account Transfer:    Create a system to simulate bank account transfers with proper locking to avoid race conditions.</p> </li> <li> <p>Thread-Safe Cache:    Implement a concurrent cache with automatic expiration of entries.</p> </li> <li> <p>Fork/Join Sorting:    Use the Fork/Join framework to implement a parallel sorting algorithm.</p> </li> <li> <p>Concurrent Data Pipeline:     Build a data processing pipeline where multiple stages of processing occur concurrently.</p> </li> </ol>"},{"location":"java/java-exception-handling/","title":"Java Exception Handling","text":""},{"location":"java/java-exception-handling/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Exception Handling</li> <li>Types of Exceptions</li> <li>Exception Handling Mechanisms</li> <li>Best Practices</li> <li>Common Scenarios</li> </ol>"},{"location":"java/java-exception-handling/#introduction","title":"Introduction","text":"<p>Exception handling in Java is a mechanism to handle runtime errors and maintain normal application flow. It's crucial for building robust and reliable applications.</p>"},{"location":"java/java-exception-handling/#why-exception-handling","title":"Why Exception Handling?","text":"<ul> <li>Separate error handling code from regular code</li> <li>Propagate errors up the call stack</li> <li>Group and differentiate error types</li> <li>Maintain program reliability</li> </ul>"},{"location":"java/java-exception-handling/#types-of-exceptions","title":"Types of Exceptions","text":""},{"location":"java/java-exception-handling/#1-checked-exceptions","title":"1. Checked Exceptions","text":"<p>Exceptions that must be either caught or declared in the method signature.</p> <pre><code>public class CheckedExceptionExample {\n    public void readFile(String filename) throws IOException {\n        FileReader file = new FileReader(filename);\n        // Process file\n    }\n\n    public void handleFile() {\n        try {\n            readFile(\"example.txt\");\n        } catch (IOException e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#2-unchecked-exceptions","title":"2. Unchecked Exceptions","text":"<p>Runtime exceptions that don't need to be explicitly caught or declared.</p> <pre><code>public class UncheckedExceptionExample {\n    public void divideNumbers(int a, int b) {\n        try {\n            int result = a / b;\n            System.out.println(\"Result: \" + result);\n        } catch (ArithmeticException e) {\n            System.err.println(\"Cannot divide by zero!\");\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#3-error","title":"3. Error","text":"<p>Serious problems that reasonable applications shouldn't try to catch.</p> <pre><code>public class ErrorExample {\n    public void recursiveMethod() {\n        // This will cause StackOverflowError\n        recursiveMethod();\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#exception-handling-mechanisms","title":"Exception Handling Mechanisms","text":""},{"location":"java/java-exception-handling/#1-try-catch-block","title":"1. try-catch Block","text":"<p>Basic exception handling mechanism.</p> <pre><code>public class TryCatchExample {\n    public void demonstrateTryCatch() {\n        try {\n            // Code that might throw an exception\n            int[] arr = new int[5];\n            arr[10] = 50; // ArrayIndexOutOfBoundsException\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.err.println(\"Array index out of bounds!\");\n        } catch (Exception e) {\n            System.err.println(\"Generic error: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#2-try-with-resources","title":"2. try-with-resources","text":"<p>Automatically closes resources that implement AutoCloseable.</p> <pre><code>public class TryWithResourcesExample {\n    public void readFile() {\n        try (FileReader fr = new FileReader(\"file.txt\");\n             BufferedReader br = new BufferedReader(fr)) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#3-throw-and-throws","title":"3. throw and throws","text":"<p>Mechanisms to throw and declare exceptions.</p> <pre><code>public class ThrowExample {\n    public void validateAge(int age) throws IllegalArgumentException {\n        if (age &lt; 0) {\n            throw new IllegalArgumentException(\"Age cannot be negative\");\n        }\n        // Process age\n    }\n\n    public void processAge() {\n        try {\n            validateAge(-5);\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"Invalid age: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#4-finally-block","title":"4. finally Block","text":"<p>Code that always executes, regardless of exception.</p> <pre><code>public class FinallyExample {\n    public void processResource() {\n        Resource resource = null;\n        try {\n            resource = new Resource();\n            // Process resource\n        } catch (Exception e) {\n            System.err.println(\"Error processing resource\");\n        } finally {\n            if (resource != null) {\n                resource.close();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#best-practices","title":"Best Practices","text":""},{"location":"java/java-exception-handling/#1-exception-hierarchy","title":"1. Exception Hierarchy","text":"<p>Create custom exceptions by extending appropriate exception classes.</p> <pre><code>public class CustomExceptionExample {\n    public class BusinessException extends Exception {\n        public BusinessException(String message) {\n            super(message);\n        }\n    }\n\n    public class ValidationException extends BusinessException {\n        public ValidationException(String message) {\n            super(message);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#2-exception-handling-strategies","title":"2. Exception Handling Strategies","text":"<pre><code>public class ExceptionHandlingStrategy {\n    // 1. Catch and Handle\n    public void handleLocally() {\n        try {\n            // Risky operation\n        } catch (Exception e) {\n            // Handle completely\n            logError(e);\n            notifyUser();\n        }\n    }\n\n    // 2. Catch and Rethrow\n    public void handleAndRethrow() throws BusinessException {\n        try {\n            // Risky operation\n        } catch (Exception e) {\n            logError(e);\n            throw new BusinessException(\"Operation failed: \" + e.getMessage());\n        }\n    }\n\n    // 3. Catch and Transform\n    public void handleAndTransform() {\n        try {\n            // Risky operation\n        } catch (SQLException e) {\n            throw new DataAccessException(\"Database error\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#3-logging-best-practices","title":"3. Logging Best Practices","text":"<pre><code>public class ExceptionLogging {\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionLogging.class);\n\n    public void demonstrateLogging() {\n        try {\n            // Risky operation\n        } catch (Exception e) {\n            logger.error(\"Operation failed\", e);\n            // Include stack trace for debugging\n            logger.debug(\"Stack trace: \", e);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#common-scenarios","title":"Common Scenarios","text":""},{"location":"java/java-exception-handling/#1-database-operations","title":"1. Database Operations","text":"<pre><code>public class DatabaseExample {\n    public void performDatabaseOperation() {\n        Connection conn = null;\n        try {\n            conn = getConnection();\n            // Perform database operations\n        } catch (SQLException e) {\n            handleDatabaseError(e);\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    logger.error(\"Error closing connection\", e);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#2-file-operations","title":"2. File Operations","text":"<pre><code>public class FileOperationExample {\n    public void processFile(String path) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                processLine(line);\n            }\n        } catch (IOException e) {\n            handleFileError(e);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#3-network-operations","title":"3. Network Operations","text":"<pre><code>public class NetworkExample {\n    public void makeHttpRequest() {\n        HttpURLConnection conn = null;\n        try {\n            URL url = new URL(\"http://api.example.com\");\n            conn = (HttpURLConnection) url.openConnection();\n            // Process response\n        } catch (MalformedURLException e) {\n            handleInvalidURL(e);\n        } catch (IOException e) {\n            handleNetworkError(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exception-handling/#testing-exception-handling","title":"Testing Exception Handling","text":"<pre><code>@Test\npublic void testExceptionHandling() {\n    ExceptionExample example = new ExceptionExample();\n\n    assertThrows(IllegalArgumentException.class, () -&gt; {\n        example.validateInput(null);\n    });\n\n    assertDoesNotThrow(() -&gt; {\n        example.validateInput(\"valid input\");\n    });\n}\n</code></pre>"},{"location":"java/java-exception-handling/#summary","title":"Summary","text":"<ul> <li>Always catch specific exceptions before general ones</li> <li>Use try-with-resources for AutoCloseable resources</li> <li>Create custom exceptions for business logic</li> <li>Log exceptions appropriately</li> <li>Clean up resources in finally blocks</li> <li>Test exception handling code</li> <li>Document exception handling behavior </li> </ul>"},{"location":"java/java-exceptions/","title":"Java Exceptions","text":""},{"location":"java/java-exceptions/#overview","title":"Overview","text":"<p>This guide covers Java's exception handling system, which provides a structured way to handle runtime anomalies and error conditions. Exception handling allows programs to detect and react to unexpected situations, separate error-handling code from regular code, and provide meaningful feedback to users and developers. Understanding Java's exception model is crucial for building robust, maintainable applications.</p>"},{"location":"java/java-exceptions/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Java syntax</li> <li>Familiarity with control flow statements</li> <li>Knowledge of Java classes and inheritance</li> <li>Understanding of method declarations and invocations</li> </ul>"},{"location":"java/java-exceptions/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the Java exception hierarchy</li> <li>Distinguish between checked and unchecked exceptions</li> <li>Master try-catch-finally exception handling blocks</li> <li>Apply try-with-resources for automatic resource management</li> <li>Create and use custom exceptions</li> <li>Implement proper exception propagation</li> <li>Apply multi-catch blocks and exception chaining</li> <li>Recognize when and how to document exceptions with Javadoc</li> <li>Follow best practices for exception handling</li> <li>Avoid common exception handling pitfalls</li> </ul>"},{"location":"java/java-exceptions/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Exception Hierarchy</li> <li>Checked vs Unchecked Exceptions</li> <li>Try-Catch-Finally</li> <li>Try-With-Resources</li> <li>Creating Custom Exceptions</li> <li>Exception Propagation</li> <li>Multi-Catch and Exception Chaining</li> <li>Exception Documentation</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ol>"},{"location":"java/java-exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>Java's exception architecture consists of a class hierarchy that provides an organized approach to handling errors:</p> <pre><code>             Object\n               |\n            Throwable\n            /      \\\n      Exception    Error\n       /    \\        \\\n  Checked   RuntimeException  (Various Error types)\nExceptions      \\\n                (Various RuntimeExceptions)\n</code></pre>"},{"location":"java/java-exceptions/#throwable","title":"Throwable","text":"<p>The root class of the exception hierarchy is <code>Throwable</code>, which provides common methods for all exceptions:</p> <pre><code>// Common methods on all exception types\ntry {\n    // Code that might throw an exception\n} catch (Throwable t) {\n    String message = t.getMessage();      // Gets the detail message\n    t.printStackTrace();                  // Prints stack trace to console\n    StackTraceElement[] stackTrace = t.getStackTrace(); // Gets the stack trace\n    Throwable cause = t.getCause();       // Gets the original cause\n    t.initCause(new IOException());       // Sets the cause\n}\n</code></pre>"},{"location":"java/java-exceptions/#error","title":"Error","text":"<p><code>Error</code> represents serious problems that reasonable applications should not try to catch, such as: - <code>OutOfMemoryError</code>: JVM has exhausted available memory - <code>StackOverflowError</code>: Stack has exceeded its capacity - <code>LinkageError</code>: Class dependency issues - <code>VirtualMachineError</code>: Issues with the JVM itself</p> <pre><code>// Errors generally should not be caught, but it is possible\ntry {\n    // Code that might cause an Error\n} catch (OutOfMemoryError e) {\n    // Recovery may not be possible\n    System.err.println(\"Critical error: \" + e.getMessage());\n    // Maybe log the error and exit gracefully\n    System.exit(1);\n}\n</code></pre>"},{"location":"java/java-exceptions/#exception","title":"Exception","text":"<p><code>Exception</code> is the parent class for all regular exceptions: - Checked exceptions: Must be declared or caught - Unchecked exceptions: Subclasses of <code>RuntimeException</code></p> <pre><code>// Base Exception class example\npublic void exampleMethod() throws Exception {\n    throw new Exception(\"Something went wrong\");\n}\n</code></pre>"},{"location":"java/java-exceptions/#checked-vs-unchecked-exceptions","title":"Checked vs Unchecked Exceptions","text":""},{"location":"java/java-exceptions/#checked-exceptions","title":"Checked Exceptions","text":"<p>Checked exceptions must be either: 1. Caught using try-catch blocks, or 2. Declared in the method signature using the <code>throws</code> clause</p> <p>Common checked exceptions include: - <code>IOException</code>: Input/output operations issues - <code>SQLException</code>: Database access problems - <code>ClassNotFoundException</code>: Class loading issues - <code>InterruptedException</code>: Thread interruption</p> <pre><code>// Handling checked exceptions\npublic void readFile(String fileName) {\n    // Option 1: Catch the exception\n    try {\n        FileReader fileReader = new FileReader(fileName);\n        // Read from file\n    } catch (IOException e) {\n        // Handle the exception\n        System.err.println(\"Error reading file: \" + e.getMessage());\n    }\n}\n\n// Option 2: Declare the exception\npublic void readFile2(String fileName) throws IOException {\n    FileReader fileReader = new FileReader(fileName);\n    // Read from file\n}\n</code></pre>"},{"location":"java/java-exceptions/#unchecked-exceptions","title":"Unchecked Exceptions","text":"<p>Unchecked exceptions (subclasses of <code>RuntimeException</code>) don't require explicit catching or declaration. They typically represent programming errors.</p> <p>Common unchecked exceptions include: - <code>NullPointerException</code>: Reference to a null object - <code>ArrayIndexOutOfBoundsException</code>: Invalid array index - <code>IllegalArgumentException</code>: Illegal argument passed to a method - <code>ArithmeticException</code>: Arithmetic errors like division by zero - <code>ClassCastException</code>: Invalid class casting</p> <pre><code>// Unchecked exceptions don't need to be declared\npublic int divide(int a, int b) {\n    if (b == 0) {\n        throw new ArithmeticException(\"Division by zero\");\n    }\n    return a / b;\n}\n\n// But they can still be caught\npublic void safeOperation() {\n    try {\n        int result = divide(10, 0);\n    } catch (ArithmeticException e) {\n        System.err.println(\"Math error: \" + e.getMessage());\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#try-catch-finally","title":"Try-Catch-Finally","text":""},{"location":"java/java-exceptions/#basic-try-catch","title":"Basic Try-Catch","text":"<p>The try-catch block is the foundation of exception handling:</p> <pre><code>try {\n    // Code that might throw an exception\n    int result = 10 / 0; // Will throw ArithmeticException\n} catch (ArithmeticException e) {\n    // Code to handle the specific exception\n    System.err.println(\"Cannot divide by zero!\");\n}\n</code></pre>"},{"location":"java/java-exceptions/#multiple-catch-blocks","title":"Multiple Catch Blocks","text":"<p>Catch blocks are evaluated in order; place more specific exceptions before more general ones:</p> <pre><code>try {\n    // Code that might throw different types of exceptions\n    String fileName = \"file.txt\";\n    FileReader fileReader = new FileReader(fileName);\n    // Potentially other exception-throwing operations\n} catch (FileNotFoundException e) {\n    // Handle file not found case\n    System.err.println(\"File not found: \" + e.getMessage());\n} catch (IOException e) {\n    // Handle other I/O issues\n    System.err.println(\"Error reading file: \" + e.getMessage());\n} catch (Exception e) {\n    // Catch any other exceptions\n    System.err.println(\"Unexpected error: \" + e.getMessage());\n}\n</code></pre>"},{"location":"java/java-exceptions/#finally-block","title":"Finally Block","text":"<p>The finally block contains code that always executes, regardless of whether an exception occurs:</p> <pre><code>FileReader fileReader = null;\ntry {\n    fileReader = new FileReader(\"file.txt\");\n    // Read operations\n} catch (IOException e) {\n    System.err.println(\"Error reading file: \" + e.getMessage());\n} finally {\n    // This code always executes\n    if (fileReader != null) {\n        try {\n            fileReader.close();\n        } catch (IOException e) {\n            System.err.println(\"Error closing file: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"java/java-exceptions/#1-handle-and-recover","title":"1. Handle and recover","text":"<pre><code>try {\n    // Attempt operation\n} catch (Exception e) {\n    // Handle the issue and allow the program to continue\n    // Perhaps use a default value or alternative approach\n}\n</code></pre>"},{"location":"java/java-exceptions/#2-log-and-rethrow","title":"2. Log and rethrow","text":"<pre><code>try {\n    // Attempt operation\n} catch (Exception e) {\n    // Log the error\n    logger.error(\"Operation failed\", e);\n    // Re-throw same or a new exception\n    throw e;\n}\n</code></pre>"},{"location":"java/java-exceptions/#3-cleanup-with-finally","title":"3. Cleanup with finally","text":"<pre><code>Resource resource = null;\ntry {\n    resource = acquireResource();\n    // Use resource\n} catch (Exception e) {\n    // Handle any exceptions\n} finally {\n    // Clean up resources\n    if (resource != null) {\n        resource.close();\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#try-with-resources","title":"Try-With-Resources","text":"<p>Introduced in Java 7, try-with-resources automatically closes resources that implement <code>AutoCloseable</code> or <code>Closeable</code> interfaces:</p>"},{"location":"java/java-exceptions/#basic-syntax","title":"Basic Syntax","text":"<pre><code>try (\n    // Resources declared here are automatically closed\n    FileReader reader = new FileReader(\"input.txt\");\n    BufferedReader buffered = new BufferedReader(reader)\n) {\n    // Use the resources\n    String line = buffered.readLine();\n    System.out.println(line);\n\n    // No need for finally block to close resources\n    // Both buffered and reader will be closed automatically\n} catch (IOException e) {\n    System.err.println(\"Error: \" + e.getMessage());\n}\n</code></pre>"},{"location":"java/java-exceptions/#custom-resources","title":"Custom Resources","text":"<p>Any class implementing <code>AutoCloseable</code> can be used with try-with-resources:</p> <pre><code>class DatabaseConnection implements AutoCloseable {\n    public DatabaseConnection() {\n        System.out.println(\"Opening database connection\");\n    }\n\n    public void executeQuery(String query) {\n        System.out.println(\"Executing: \" + query);\n    }\n\n    @Override\n    public void close() throws Exception {\n        System.out.println(\"Closing database connection\");\n    }\n}\n\n// Using custom resource\ntry (DatabaseConnection connection = new DatabaseConnection()) {\n    connection.executeQuery(\"SELECT * FROM users\");\n    // Connection automatically closed\n}\n</code></pre>"},{"location":"java/java-exceptions/#suppressed-exceptions","title":"Suppressed Exceptions","text":"<p>When an exception occurs inside the try block and another exception occurs during resource closing, the second exception is suppressed:</p> <pre><code>public static void main(String[] args) {\n    try (AutoCloseableResource resource = new AutoCloseableResource()) {\n        throw new Exception(\"Try block exception\");\n    } catch (Exception e) {\n        System.err.println(\"Main exception: \" + e.getMessage());\n\n        // Access suppressed exceptions\n        Throwable[] suppressed = e.getSuppressed();\n        for (Throwable t : suppressed) {\n            System.err.println(\"Suppressed: \" + t.getMessage());\n        }\n    }\n}\n\nstatic class AutoCloseableResource implements AutoCloseable {\n    @Override\n    public void close() throws Exception {\n        throw new Exception(\"Close exception\");\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#creating-custom-exceptions","title":"Creating Custom Exceptions","text":""},{"location":"java/java-exceptions/#basic-custom-exception","title":"Basic Custom Exception","text":"<pre><code>// Custom checked exception\npublic class InsufficientFundsException extends Exception {\n    // Default constructor\n    public InsufficientFundsException() {\n        super();\n    }\n\n    // Constructor with message\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n\n    // Constructor with message and cause\n    public InsufficientFundsException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\n// Custom unchecked exception\npublic class InvalidUserOperationException extends RuntimeException {\n    public InvalidUserOperationException(String message) {\n        super(message);\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#adding-context-to-custom-exceptions","title":"Adding Context to Custom Exceptions","text":"<p>Custom exceptions can include additional information relevant to the error:</p> <pre><code>public class InsufficientFundsException extends Exception {\n    private final double available;\n    private final double required;\n\n    public InsufficientFundsException(double available, double required) {\n        super(String.format(\"Insufficient funds: available $%.2f, required $%.2f\", \n              available, required));\n        this.available = available;\n        this.required = required;\n    }\n\n    public double getAvailable() {\n        return available;\n    }\n\n    public double getRequired() {\n        return required;\n    }\n\n    public double getDeficit() {\n        return required - available;\n    }\n}\n\n// Usage\npublic void withdraw(double amount) throws InsufficientFundsException {\n    if (amount &gt; balance) {\n        throw new InsufficientFundsException(balance, amount);\n    }\n    // Withdraw logic\n}\n\n// Handling\ntry {\n    account.withdraw(100.0);\n} catch (InsufficientFundsException e) {\n    System.out.println(e.getMessage());\n    System.out.println(\"You need $\" + e.getDeficit() + \" more\");\n}\n</code></pre>"},{"location":"java/java-exceptions/#when-to-create-custom-exceptions","title":"When to Create Custom Exceptions","text":"<p>Create custom exceptions when: - Standard exceptions don't adequately describe the error - You need to add domain-specific information - You want to group related errors under a common type - You're creating a reusable library or framework</p> <pre><code>// Hierarchy of custom exceptions for a banking application\npublic class BankingException extends Exception { /* ... */ }\n\npublic class InsufficientFundsException extends BankingException { /* ... */ }\n\npublic class AccountNotFoundException extends BankingException { /* ... */ }\n\npublic class TransactionLimitExceededException extends BankingException { /* ... */ }\n</code></pre>"},{"location":"java/java-exceptions/#exception-propagation","title":"Exception Propagation","text":"<p>Exception propagation refers to how exceptions move up the call stack if not caught:</p>"},{"location":"java/java-exceptions/#call-stack-propagation","title":"Call Stack Propagation","text":"<pre><code>public static void main(String[] args) {\n    try {\n        methodA();\n    } catch (Exception e) {\n        System.out.println(\"Caught in main: \" + e.getMessage());\n    }\n}\n\npublic static void methodA() throws Exception {\n    methodB();\n}\n\npublic static void methodB() throws Exception {\n    methodC();\n}\n\npublic static void methodC() throws Exception {\n    throw new Exception(\"Exception from methodC\");\n}\n</code></pre> <p>In this example, the exception: 1. Originates in <code>methodC</code> 2. Propagates to <code>methodB</code> 3. Continues to <code>methodA</code> 4. Finally, it's caught in <code>main</code></p>"},{"location":"java/java-exceptions/#checked-vs-unchecked-exception-propagation","title":"Checked vs Unchecked Exception Propagation","text":"<ul> <li>Checked exceptions must be declared or caught at each level</li> <li>Unchecked exceptions automatically propagate without declaration</li> </ul> <pre><code>// Checked exception propagation requires declaration\npublic void level1() throws IOException {\n    level2();\n}\n\npublic void level2() throws IOException {\n    level3();\n}\n\npublic void level3() throws IOException {\n    throw new IOException(\"IO Error\");\n}\n\n// Unchecked exception propagation doesn't require declaration\npublic void levelA() {\n    levelB();\n}\n\npublic void levelB() {\n    levelC();\n}\n\npublic void levelC() {\n    throw new RuntimeException(\"Runtime Error\");\n}\n</code></pre>"},{"location":"java/java-exceptions/#partial-handling","title":"Partial Handling","text":"<p>Sometimes you might partially handle an exception and then rethrow it:</p> <pre><code>public void processFile(String path) throws IOException {\n    try {\n        // File operations\n    } catch (IOException e) {\n        // Log the issue\n        System.err.println(\"Error processing file: \" + path);\n\n        // Clean up any resources\n\n        // Rethrow for higher-level handling\n        throw e;\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#multi-catch-and-exception-chaining","title":"Multi-Catch and Exception Chaining","text":""},{"location":"java/java-exceptions/#multi-catch-java-7","title":"Multi-Catch (Java 7+)","text":"<p>Catch multiple exception types with a single block:</p> <pre><code>try {\n    // Code that might throw multiple exception types\n    methodThatThrowsMultipleExceptions();\n} catch (FileNotFoundException | SQLException e) {\n    // Handle both exception types the same way\n    System.err.println(\"Data access error: \" + e.getMessage());\n} catch (Exception e) {\n    // Handle other exceptions differently\n    System.err.println(\"General error: \" + e.getMessage());\n}\n</code></pre>"},{"location":"java/java-exceptions/#exception-chaining","title":"Exception Chaining","text":"<p>Preserve the original cause when throwing a new exception:</p> <pre><code>public void processFile(String filename) throws ServiceException {\n    try {\n        // File operations\n        FileInputStream file = new FileInputStream(filename);\n        // Process file...\n    } catch (IOException e) {\n        // Wrap the original exception\n        throw new ServiceException(\"Error processing file: \" + filename, e);\n    }\n}\n\n// Higher-level code can access the original cause\ntry {\n    service.processFile(\"data.txt\");\n} catch (ServiceException e) {\n    System.err.println(\"Service error: \" + e.getMessage());\n\n    // Get the original cause\n    Throwable cause = e.getCause();\n    if (cause != null) {\n        System.err.println(\"Original cause: \" + cause.getMessage());\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#exception-translation","title":"Exception Translation","text":"<p>Convert low-level exceptions to more appropriate higher-level ones:</p> <pre><code>public User findUserById(int id) throws UserNotFoundException {\n    try {\n        // Database operations\n        String sql = \"SELECT * FROM users WHERE id = ?\";\n        // Execute query...\n        if (resultSet.next()) {\n            // Map result to User object\n            return mapResultToUser(resultSet);\n        } else {\n            throw new UserNotFoundException(\"User with ID \" + id + \" not found\");\n        }\n    } catch (SQLException e) {\n        // Translate low-level database exception\n        throw new DataAccessException(\"Database error while finding user\", e);\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#exception-documentation","title":"Exception Documentation","text":""},{"location":"java/java-exceptions/#javadoc-for-exceptions","title":"Javadoc for Exceptions","text":"<p>Document exceptions with the <code>@throws</code> or <code>@exception</code> tag:</p> <pre><code>/**\n * Transfers funds between accounts.\n *\n * @param fromAccount The source account\n * @param toAccount The destination account\n * @param amount The amount to transfer\n * @throws InsufficientFundsException If the source account has insufficient funds\n * @throws AccountNotFoundException If either account does not exist\n * @throws IllegalArgumentException If the amount is negative\n */\npublic void transferFunds(String fromAccount, String toAccount, double amount) \n        throws InsufficientFundsException, AccountNotFoundException {\n\n    if (amount &lt; 0) {\n        throw new IllegalArgumentException(\"Transfer amount cannot be negative\");\n    }\n\n    // Implementation...\n}\n</code></pre>"},{"location":"java/java-exceptions/#runtime-exception-documentation","title":"Runtime Exception Documentation","text":"<p>Document unchecked exceptions even though they don't need to be declared:</p> <pre><code>/**\n * Calculates the average of the provided values.\n *\n * @param values Array of numbers to average\n * @return The average value\n * @throws NullPointerException If the values array is null\n * @throws IllegalArgumentException If the array is empty\n */\npublic double calculateAverage(double[] values) {\n    if (values == null) {\n        throw new NullPointerException(\"Values array cannot be null\");\n    }\n    if (values.length == 0) {\n        throw new IllegalArgumentException(\"Cannot calculate average of empty array\");\n    }\n\n    double sum = 0;\n    for (double value : values) {\n        sum += value;\n    }\n    return sum / values.length;\n}\n</code></pre>"},{"location":"java/java-exceptions/#documenting-exception-behavior","title":"Documenting Exception Behavior","text":"<p>Be specific about exactly when and why exceptions are thrown:</p> <pre><code>/**\n * Retrieves a user by email address.\n *\n * @param email The email to search for\n * @return The matching user\n * @throws UserNotFoundException If no user with the given email exists\n * @throws InvalidEmailException If the email format is invalid\n * @throws DataAccessException If a database error occurs\n */\npublic User getUserByEmail(String email) throws UserNotFoundException, \n                                               InvalidEmailException, \n                                               DataAccessException {\n    // Implementation...\n}\n</code></pre>"},{"location":"java/java-exceptions/#best-practices","title":"Best Practices","text":""},{"location":"java/java-exceptions/#1-use-specific-exception-types","title":"1. Use specific exception types","text":"<pre><code>// Bad: Too generic\nthrow new Exception(\"Something went wrong\");\n\n// Good: Specific and descriptive\nthrow new FileNotFoundException(\"Config file not found at \" + path);\n</code></pre>"},{"location":"java/java-exceptions/#2-include-meaningful-information-in-exceptions","title":"2. Include meaningful information in exceptions","text":"<pre><code>// Bad: Vague message\nthrow new IllegalArgumentException(\"Invalid value\");\n\n// Good: Detailed context\nthrow new IllegalArgumentException(\"Age must be between 0 and 120, got: \" + age);\n</code></pre>"},{"location":"java/java-exceptions/#3-catch-exceptions-at-the-right-level","title":"3. Catch exceptions at the right level","text":"<pre><code>// Good: Low-level method declares exception\npublic byte[] readFile(String path) throws IOException {\n    // Implementation...\n}\n\n// Good: High-level method handles the exception appropriately\npublic Configuration loadConfig() {\n    try {\n        byte[] data = readFile(CONFIG_PATH);\n        return parseConfig(data);\n    } catch (IOException e) {\n        logger.warn(\"Failed to load configuration, using defaults\", e);\n        return new DefaultConfiguration();\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#4-handle-exceptions-gracefully","title":"4. Handle exceptions gracefully","text":"<pre><code>public void processUserInput(String input) {\n    try {\n        int value = Integer.parseInt(input);\n        processValue(value);\n    } catch (NumberFormatException e) {\n        // Friendly message to user\n        displayError(\"Please enter a valid number\");\n\n        // Log with technical details for developers\n        logger.debug(\"Invalid number format: \" + input, e);\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#5-close-resources-properly","title":"5. Close resources properly","text":"<pre><code>// Good: Using try-with-resources\npublic String readFirstLine(String path) throws IOException {\n    try (BufferedReader reader = new BufferedReader(new FileReader(path))) {\n        return reader.readLine();\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#6-dont-swallow-exceptions","title":"6. Don't swallow exceptions","text":"<pre><code>// Bad: Exception swallowed\ntry {\n    someRiskyOperation();\n} catch (Exception e) {\n    // Empty catch block or just e.printStackTrace()\n}\n\n// Good: Proper handling\ntry {\n    someRiskyOperation();\n} catch (Exception e) {\n    logger.error(\"Operation failed\", e);\n    notifyUser(\"An error occurred: \" + e.getMessage());\n}\n</code></pre>"},{"location":"java/java-exceptions/#7-dont-use-exceptions-for-normal-flow-control","title":"7. Don't use exceptions for normal flow control","text":"<pre><code>// Bad: Using exceptions for expected cases\npublic boolean isUserValid(String username) {\n    try {\n        findUser(username);\n        return true;\n    } catch (UserNotFoundException e) {\n        return false;\n    }\n}\n\n// Good: Check without exceptions\npublic boolean isUserValid(String username) {\n    return userRepository.exists(username);\n}\n</code></pre>"},{"location":"java/java-exceptions/#8-balance-checked-and-unchecked-exceptions","title":"8. Balance checked and unchecked exceptions","text":"<pre><code>// Good use of unchecked exception: Programming error\npublic void setAge(int age) {\n    if (age &lt; 0 || age &gt; 150) {\n        throw new IllegalArgumentException(\"Invalid age: \" + age);\n    }\n    this.age = age;\n}\n\n// Good use of checked exception: External condition\npublic void saveDocument(Document doc, String path) throws IOException {\n    // Implementation with proper IOException propagation\n}\n</code></pre>"},{"location":"java/java-exceptions/#9-create-domain-specific-exception-hierarchy","title":"9. Create domain-specific exception hierarchy","text":"<pre><code>// Base exception for your application\npublic class AppException extends Exception { /*...*/ }\n\n// Functional categories\npublic class ValidationException extends AppException { /*...*/ }\npublic class SecurityException extends AppException { /*...*/ }\npublic class DataException extends AppException { /*...*/ }\n\n// Specific exceptions\npublic class InvalidInputException extends ValidationException { /*...*/ }\npublic class DuplicateEntityException extends DataException { /*...*/ }\n</code></pre>"},{"location":"java/java-exceptions/#10-clean-up-properly-in-catch-and-finally-blocks","title":"10. Clean up properly in catch and finally blocks","text":"<pre><code>Lock lock = new ReentrantLock();\ntry {\n    lock.lock();\n    // Critical section\n} catch (Exception e) {\n    // Handle exception\n} finally {\n    // Always release the lock\n    lock.unlock();\n}\n</code></pre>"},{"location":"java/java-exceptions/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"java/java-exceptions/#1-catching-exception-or-throwable","title":"1. Catching Exception or Throwable","text":"<p>Problem: Catching overly general exceptions can mask bugs.</p> <pre><code>// Bad: Catches everything including programming errors\ntry {\n    // A lot of code...\n} catch (Exception e) {\n    logger.error(\"Error\", e);\n}\n\n// Better: Catch specific exceptions\ntry {\n    // Code...\n} catch (IOException e) {\n    // Handle I/O issues\n} catch (SQLException e) {\n    // Handle database issues\n} catch (RuntimeException e) {\n    // Handle unexpected runtime issues\n    throw e; // Consider rethrowing\n}\n</code></pre>"},{"location":"java/java-exceptions/#2-ignoring-exceptions","title":"2. Ignoring exceptions","text":"<p>Problem: Silently ignoring exceptions hides issues.</p> <pre><code>// Bad: Empty catch block\ntry {\n    deleteFile(path);\n} catch (IOException e) {\n    // Do nothing\n}\n\n// Better: At least log the exception\ntry {\n    deleteFile(path);\n} catch (IOException e) {\n    logger.warn(\"Failed to delete file: \" + path, e);\n}\n</code></pre>"},{"location":"java/java-exceptions/#3-excessive-try-catch-blocks","title":"3. Excessive try-catch blocks","text":"<p>Problem: Too many try-catch blocks make code hard to read.</p> <pre><code>// Bad: Try-catch for every operation\ntry {\n    openFile(path);\n} catch (IOException e) {\n    handleError(e);\n}\n\ntry {\n    readData();\n} catch (IOException e) {\n    handleError(e);\n}\n\n// Better: Single try-catch for related operations\ntry {\n    File file = openFile(path);\n    readData(file);\n    processData();\n} catch (IOException e) {\n    handleError(e);\n}\n</code></pre>"},{"location":"java/java-exceptions/#4-logging-and-throwing","title":"4. Logging and throwing","text":"<p>Problem: Both logging and throwing the same exception leads to duplicate logs.</p> <pre><code>// Bad: Duplicated error information\ntry {\n    // Code...\n} catch (SQLException e) {\n    logger.error(\"Database error\", e);\n    throw e; // Will be logged again higher up\n}\n\n// Better: Either log or throw with context\ntry {\n    // Code...\n} catch (SQLException e) {\n    // Option 1: Log and convert\n    logger.error(\"Database error\", e);\n    throw new DataAccessException(\"Error accessing data\", e);\n\n    // Option 2: Just throw with context\n    throw new DataAccessException(\"Error accessing data\", e);\n    // Then log at the top level where it's finally handled\n}\n</code></pre>"},{"location":"java/java-exceptions/#5-destructive-wrapping","title":"5. Destructive wrapping","text":"<p>Problem: Wrapping exceptions without the original cause.</p> <pre><code>// Bad: Original cause is lost\ntry {\n    // Code...\n} catch (IOException e) {\n    throw new ServiceException(\"Service failed\"); // Original e is lost\n}\n\n// Good: Preserve the cause\ntry {\n    // Code...\n} catch (IOException e) {\n    throw new ServiceException(\"Service failed\", e); // e is included as cause\n}\n</code></pre>"},{"location":"java/java-exceptions/#6-throwing-raw-exception-types","title":"6. Throwing raw exception types","text":"<p>Problem: Throwing the base Exception class provides little information.</p> <pre><code>// Bad: Generic exception type\nif (username == null) {\n    throw new Exception(\"Username is required\");\n}\n\n// Good: Specific exception type\nif (username == null) {\n    throw new IllegalArgumentException(\"Username is required\");\n}\n</code></pre>"},{"location":"java/java-exceptions/#7-not-cleaning-up-resources","title":"7. Not cleaning up resources","text":"<p>Problem: Resource leaks when exceptions occur.</p> <pre><code>// Bad: Resources might not be closed\nConnection conn = getConnection();\ntry {\n    // Use connection\n} catch (Exception e) {\n    // Handle exception\n    return; // Connection not closed if exception or early return\n}\nconn.close();\n\n// Good: Resources always closed\ntry (Connection conn = getConnection()) {\n    // Use connection\n} catch (Exception e) {\n    // Handle exception\n}\n// Connection is automatically closed\n</code></pre>"},{"location":"java/java-exceptions/#8-stack-trace-performance","title":"8. Stack trace performance","text":"<p>Problem: Creating exceptions is expensive due to stack trace capture.</p> <pre><code>// Bad for performance-critical code: Exception creation is costly\nif (!isValid(value)) {\n    throw new IllegalArgumentException(\"Invalid value: \" + value);\n}\n\n// Better for extremely performance-critical sections:\nif (!isValid(value)) {\n    IllegalArgumentException e = new IllegalArgumentException(\"Invalid value: \" + value);\n    e.setStackTrace(new StackTraceElement[0]); // Empty stack trace\n    throw e;\n}\n</code></pre>"},{"location":"java/java-exceptions/#9-exception-handling-in-constructors","title":"9. Exception handling in constructors","text":"<p>Problem: Object left in inconsistent state if constructor throws exception.</p> <pre><code>// Problematic: Partially initialized object\npublic class ResourceManager {\n    private Resource resource1;\n    private Resource resource2;\n\n    public ResourceManager() {\n        resource1 = new Resource(); // What if this throws?\n        resource2 = new Resource(); // Never initialized\n    }\n}\n\n// Better: All-or-nothing initialization\npublic class ResourceManager {\n    private final Resource resource1;\n    private final Resource resource2;\n\n    public ResourceManager() throws ResourceException {\n        Resource r1 = null;\n        Resource r2 = null;\n        try {\n            r1 = new Resource();\n            r2 = new Resource();\n        } catch (Exception e) {\n            // Clean up any partially allocated resources\n            if (r1 != null) r1.close();\n            throw new ResourceException(\"Failed to initialize resources\", e);\n        }\n\n        // Only assign when everything succeeded\n        this.resource1 = r1;\n        this.resource2 = r2;\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#10-exceptions-in-finally-blocks","title":"10. Exceptions in finally blocks","text":"<p>Problem: Exceptions in finally blocks suppress exceptions in try blocks.</p> <pre><code>// Bad: Exception in finally overwrites the original exception\ntry {\n    throw new ImportantException(\"Critical error\");\n} finally {\n    // This exception replaces the ImportantException\n    throw new LessImportantException(\"Cleanup error\");\n}\n\n// Better: Handle exceptions in finally without throwing\ntry {\n    throw new ImportantException(\"Critical error\");\n} finally {\n    try {\n        // Cleanup code that might throw\n    } catch (Exception e) {\n        logger.warn(\"Error during cleanup\", e);\n    }\n}\n</code></pre>"},{"location":"java/java-exceptions/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>Java Exceptions Tutorial</li> <li> <p>Java SE API Documentation: Exception</p> </li> <li> <p>Books:</p> </li> <li>\"Effective Java\" by Joshua Bloch (Chapter on Exceptions)</li> <li>\"Java: The Complete Reference\" by Herbert Schildt</li> <li> <p>\"Clean Code\" by Robert C. Martin (Section on Error Handling)</p> </li> <li> <p>Online Resources:</p> </li> <li>Baeldung's Java Exception Handling</li> <li>IBM Developer: Best practices for using exceptions</li> <li>Oracle's Lesson on Exceptions</li> </ol>"},{"location":"java/java-exceptions/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>Exception Hierarchy Analysis:    Analyze an exception hierarchy and create a diagram of the inheritance relationships.</p> </li> <li> <p>Custom Exception Creation:    Implement a custom exception hierarchy for a specific domain.</p> </li> <li> <p>Resource Management:    Refactor code to properly close resources using try-with-resources.</p> </li> <li> <p>Exception Translation:    Implement methods that translate low-level exceptions to more appropriate higher-level ones.</p> </li> <li> <p>Real-world Error Handling:    Design an error handling strategy for a command-line application.</p> </li> <li> <p>Exception Testing:    Write unit tests that verify correct exception handling in a method.</p> </li> <li> <p>Checked vs Unchecked Decision:    Analyze scenarios and determine whether checked or unchecked exceptions are more appropriate.</p> </li> <li> <p>Internationalization of Exceptions:    Modify exceptions to support localized error messages.</p> </li> <li> <p>Debugging Stack Traces:    Analyze stack traces from real exceptions and identify the root cause.</p> </li> <li> <p>Exception Performance Analysis:     Benchmark different exception handling approaches to understand their performance implications. </p> </li> </ol>"},{"location":"java/java-generics/","title":"Java Generics","text":""},{"location":"java/java-generics/#overview","title":"Overview","text":"<p>Java Generics, introduced in Java 5 (2004), provides a way to create classes, interfaces, and methods that operate on a type parameter. The primary motivation behind generics is to enable programmers to create type-safe collections while providing compile-time type checking and eliminating the need for explicit casting. Generics allow you to abstract over types, creating reusable components that work with different data types while maintaining type safety.</p>"},{"location":"java/java-generics/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Java programming knowledge</li> <li>Understanding of object-oriented programming concepts</li> <li>Familiarity with Java collections framework</li> <li>Understanding of Java class hierarchy and polymorphism</li> </ul>"},{"location":"java/java-generics/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the purpose and benefits of generics in Java</li> <li>Learn to create and use generic classes and interfaces</li> <li>Master type parameters, bounds, and wildcards</li> <li>Understand the limitations imposed by type erasure</li> <li>Apply generics effectively with Java collections</li> <li>Implement generic methods to create flexible, reusable code</li> <li>Recognize and navigate common generics pitfalls</li> <li>Apply best practices for working with generics</li> </ul>"},{"location":"java/java-generics/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Generics</li> <li>Generic Classes and Interfaces</li> <li>Type Parameters and Naming Conventions</li> <li>Type Parameter Bounds</li> <li>Generic Methods</li> <li>Wildcards</li> <li>Type Erasure</li> <li>Generics and Collections</li> <li>Generics and Inheritance</li> <li>Raw Types and Backward Compatibility</li> <li>Advanced Generic Patterns</li> </ol>"},{"location":"java/java-generics/#introduction-to-generics","title":"Introduction to Generics","text":""},{"location":"java/java-generics/#benefits-of-generics","title":"Benefits of Generics","text":"<p>Generics provide several important benefits for Java programs:</p> <ol> <li>Type Safety: Generics enable compile-time type checking, preventing ClassCastExceptions at runtime.</li> <li>Elimination of Casts: No need for explicit casting when retrieving elements from collections.</li> <li>Code Reusability: Write code once that works with different types.</li> <li>Higher Abstraction: Express algorithms independently of specific types.</li> </ol>"},{"location":"java/java-generics/#before-and-after-generics","title":"Before and After Generics","text":"<p>Let's compare code with and without generics:</p> <pre><code>// Before generics (pre-Java 5)\nList list = new ArrayList();\nlist.add(\"Hello\");\nlist.add(42);  // No type checking, can add anything\nString s = (String) list.get(0);  // Explicit casting required\nInteger i = (Integer) list.get(1);\nString error = (String) list.get(1);  // Runtime ClassCastException\n\n// With generics (Java 5+)\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Hello\");\n// list.add(42);  // Compile-time error\nString s = list.get(0);  // No casting needed\n</code></pre>"},{"location":"java/java-generics/#generic-classes-and-interfaces","title":"Generic Classes and Interfaces","text":""},{"location":"java/java-generics/#creating-a-generic-class","title":"Creating a Generic Class","text":"<p>A generic class is declared with one or more type parameters enclosed in angle brackets.</p> <pre><code>// Generic class with one type parameter\npublic class Box&lt;T&gt; {\n    private T item;\n\n    public void put(T item) {\n        this.item = item;\n    }\n\n    public T get() {\n        return item;\n    }\n}\n\n// Usage\nBox&lt;String&gt; stringBox = new Box&lt;&gt;();\nstringBox.put(\"Hello Generics\");\nString str = stringBox.get();  // No casting needed\n\nBox&lt;Integer&gt; intBox = new Box&lt;&gt;();\nintBox.put(42);\nInteger num = intBox.get();\n</code></pre>"},{"location":"java/java-generics/#generic-class-with-multiple-type-parameters","title":"Generic Class with Multiple Type Parameters","text":"<pre><code>// Generic class with two type parameters\npublic class Pair&lt;K, V&gt; {\n    private K key;\n    private V value;\n\n    public Pair(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public K getKey() {\n        return key;\n    }\n\n    public V getValue() {\n        return value;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + key + \", \" + value + \")\";\n    }\n}\n\n// Usage\nPair&lt;String, Integer&gt; pair = new Pair&lt;&gt;(\"Age\", 30);\nString key = pair.getKey();  // \"Age\"\nInteger value = pair.getValue();  // 30\n</code></pre>"},{"location":"java/java-generics/#generic-interfaces","title":"Generic Interfaces","text":"<p>Interfaces can also be generic, allowing for type-safe contracts.</p> <pre><code>// Generic interface\npublic interface Repository&lt;T, ID&gt; {\n    T findById(ID id);\n    List&lt;T&gt; findAll();\n    void save(T entity);\n    void delete(ID id);\n}\n\n// Implementation for User entity\npublic class UserRepository implements Repository&lt;User, Long&gt; {\n    @Override\n    public User findById(Long id) {\n        // Implementation\n        return new User(id);\n    }\n\n    @Override\n    public List&lt;User&gt; findAll() {\n        // Implementation\n        return new ArrayList&lt;&gt;();\n    }\n\n    @Override\n    public void save(User entity) {\n        // Implementation\n    }\n\n    @Override\n    public void delete(Long id) {\n        // Implementation\n    }\n}\n</code></pre>"},{"location":"java/java-generics/#type-parameters-and-naming-conventions","title":"Type Parameters and Naming Conventions","text":"<p>Java generics follow standard naming conventions for type parameters:</p> <ul> <li><code>E</code> - Element (used extensively by the Java Collections Framework)</li> <li><code>K</code> - Key (used for mapped types)</li> <li><code>V</code> - Value (also used for mapped types)</li> <li><code>N</code> - Number</li> <li><code>T</code> - Type (general purpose type)</li> <li><code>S</code>, <code>U</code>, <code>V</code> etc. - Additional types when multiple type parameters are needed</li> </ul> <pre><code>// Standard conventions in action\npublic class Container&lt;T&gt; { /* ... */ }\npublic interface List&lt;E&gt; { /* ... */ }\npublic interface Map&lt;K, V&gt; { /* ... */ }\npublic class Converter&lt;S, T&gt; { /* ... */ }\n</code></pre> <p>While single-letter names are conventional, you can use more descriptive names when it improves readability:</p> <pre><code>public class DataProcessor&lt;InputType, OutputType&gt; {\n    public OutputType process(InputType input) {\n        // Implementation\n        return null;\n    }\n}\n</code></pre>"},{"location":"java/java-generics/#type-parameter-bounds","title":"Type Parameter Bounds","text":"<p>Type parameter bounds limit the types that can be used as type arguments in a generic class or method.</p>"},{"location":"java/java-generics/#upper-bounds","title":"Upper Bounds","text":"<p>Restricts the type parameter to a specific type or a subtype of that type.</p> <pre><code>// T must be a Number or a subclass of Number\npublic class NumberBox&lt;T extends Number&gt; {\n    private T value;\n\n    public NumberBox(T value) {\n        this.value = value;\n    }\n\n    public double doubleValue() {\n        return value.doubleValue();  // Can call Number methods\n    }\n\n    public T getValue() {\n        return value;\n    }\n}\n\n// Usage\nNumberBox&lt;Integer&gt; intBox = new NumberBox&lt;&gt;(42);\nNumberBox&lt;Double&gt; doubleBox = new NumberBox&lt;&gt;(3.14);\n// NumberBox&lt;String&gt; stringBox = new NumberBox&lt;&gt;(\"not allowed\");  // Compile error\n\n// Access to Number methods\ndouble doubleValue = intBox.doubleValue();  // 42.0\n</code></pre>"},{"location":"java/java-generics/#multiple-bounds","title":"Multiple Bounds","text":"<p>A type parameter can have multiple bounds, one class and any number of interfaces.</p> <pre><code>// T must extend Comparable&lt;T&gt; and implement Serializable\npublic class SortableBox&lt;T extends Comparable&lt;T&gt; &amp; Serializable&gt; {\n    private T value;\n\n    public SortableBox(T value) {\n        this.value = value;\n    }\n\n    public int compareTo(SortableBox&lt;T&gt; other) {\n        return this.value.compareTo(other.value);\n    }\n\n    public void save() {\n        // Can serialize this.value\n    }\n}\n\n// Usage with String (both Comparable and Serializable)\nSortableBox&lt;String&gt; box1 = new SortableBox&lt;&gt;(\"apple\");\nSortableBox&lt;String&gt; box2 = new SortableBox&lt;&gt;(\"banana\");\nint result = box1.compareTo(box2);  // -1 (apple &lt; banana)\n</code></pre>"},{"location":"java/java-generics/#generic-methods","title":"Generic Methods","text":"<p>Generic methods allow type parameters to be scoped to the method level rather than the class level.</p>"},{"location":"java/java-generics/#basic-generic-method","title":"Basic Generic Method","text":"<pre><code>public class Utils {\n    // Generic method - type parameter T is defined at method level\n    public static &lt;T&gt; T identity(T value) {\n        return value;\n    }\n}\n\n// Usage - explicit type specification (often not needed due to type inference)\nString str = Utils.&lt;String&gt;identity(\"Hello\");\n\n// Usage - with type inference\nInteger num = Utils.identity(42);  // Type inferred as Integer\n</code></pre>"},{"location":"java/java-generics/#type-inference-in-generic-methods","title":"Type Inference in Generic Methods","text":"<p>Java's type inference system allows the compiler to determine the type arguments in many cases.</p> <pre><code>public class Collections {\n    public static &lt;T&gt; List&lt;T&gt; emptyList() {\n        return new ArrayList&lt;&gt;();\n    }\n}\n\n// Types inferred by the context\nList&lt;String&gt; strings = Collections.emptyList();  // Inferred as List&lt;String&gt;\n</code></pre>"},{"location":"java/java-generics/#generic-methods-with-bounded-type-parameters","title":"Generic Methods with Bounded Type Parameters","text":"<pre><code>public class MathUtils {\n    // Generic method with bounded type parameter\n    public static &lt;T extends Number&gt; double sum(List&lt;T&gt; numbers) {\n        double total = 0;\n        for (T number : numbers) {\n            total += number.doubleValue();  // Can call Number methods\n        }\n        return total;\n    }\n}\n\n// Usage\nList&lt;Integer&gt; integers = Arrays.asList(1, 2, 3);\ndouble sum1 = MathUtils.sum(integers);  // 6.0\n\nList&lt;Double&gt; doubles = Arrays.asList(1.1, 2.2, 3.3);\ndouble sum2 = MathUtils.sum(doubles);  // 6.6\n</code></pre>"},{"location":"java/java-generics/#generic-static-methods","title":"Generic Static Methods","text":"<p>Type parameters in static methods are independent of any type parameters in the containing class.</p> <pre><code>public class Container&lt;T&gt; {\n    private T value;\n\n    // Instance method using the class's type parameter T\n    public void setValue(T value) {\n        this.value = value;\n    }\n\n    // Static method with its own type parameter E (independent of T)\n    public static &lt;E&gt; List&lt;E&gt; asList(E... elements) {\n        List&lt;E&gt; list = new ArrayList&lt;&gt;();\n        for (E element : elements) {\n            list.add(element);\n        }\n        return list;\n    }\n}\n\n// Usage of static method (independent of class type parameter)\nList&lt;String&gt; strings = Container.asList(\"a\", \"b\", \"c\");\nList&lt;Integer&gt; numbers = Container.asList(1, 2, 3);\n</code></pre>"},{"location":"java/java-generics/#wildcards","title":"Wildcards","text":"<p>Wildcards provide flexibility when working with generic types, especially in method parameters.</p>"},{"location":"java/java-generics/#unbounded-wildcards","title":"Unbounded Wildcards","text":"<p>The unbounded wildcard <code>&lt;?&gt;</code> represents an unknown type. It's useful when you want to work with objects of unknown type.</p> <pre><code>// Method that prints any type of list\npublic static void printList(List&lt;?&gt; list) {\n    for (Object item : list) {\n        System.out.println(item);\n    }\n}\n\n// Usage\nList&lt;String&gt; strings = Arrays.asList(\"one\", \"two\", \"three\");\nList&lt;Integer&gt; integers = Arrays.asList(1, 2, 3);\n\nprintList(strings);  // Works with strings\nprintList(integers);  // Works with integers\n</code></pre>"},{"location":"java/java-generics/#upper-bounded-wildcards","title":"Upper Bounded Wildcards","text":"<p>Upper bounded wildcards <code>&lt;? extends Type&gt;</code> allow you to work with a specific type or any of its subtypes.</p> <pre><code>// Method that sums any list of numbers\npublic static double sumOfNumbers(List&lt;? extends Number&gt; numbers) {\n    double sum = 0.0;\n    for (Number number : numbers) {\n        sum += number.doubleValue();\n    }\n    return sum;\n}\n\n// Usage\nList&lt;Integer&gt; integers = Arrays.asList(1, 2, 3);\nList&lt;Double&gt; doubles = Arrays.asList(1.1, 2.2, 3.3);\n\ndouble sum1 = sumOfNumbers(integers);  // Works with integers\ndouble sum2 = sumOfNumbers(doubles);   // Works with doubles\n</code></pre>"},{"location":"java/java-generics/#lower-bounded-wildcards","title":"Lower Bounded Wildcards","text":"<p>Lower bounded wildcards <code>&lt;? super Type&gt;</code> allow you to work with a specific type or any of its supertypes.</p> <pre><code>// Method that adds integers to a list of integers or any supertype\npublic static void addIntegers(List&lt;? super Integer&gt; list) {\n    list.add(1);\n    list.add(2);\n    list.add(3);\n}\n\n// Usage\nList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();\nList&lt;Number&gt; numbers = new ArrayList&lt;&gt;();\nList&lt;Object&gt; objects = new ArrayList&lt;&gt;();\n\naddIntegers(integers);  // Works with Integer\naddIntegers(numbers);   // Works with Number (supertype of Integer)\naddIntegers(objects);   // Works with Object (supertype of Integer)\n</code></pre>"},{"location":"java/java-generics/#pecs-producer-extends-consumer-super","title":"PECS (Producer Extends, Consumer Super)","text":"<p>A useful mnemonic for wildcards: - Use <code>&lt;? extends T&gt;</code> when you need to get values out of a structure (Producer) - Use <code>&lt;? super T&gt;</code> when you need to put values into a structure (Consumer)</p> <pre><code>// Producer (get values) - \"extends\"\npublic static void printFirstElement(List&lt;? extends Number&gt; list) {\n    Number first = list.get(0);  // Safe to read as Number\n    System.out.println(first);\n}\n\n// Consumer (add values) - \"super\"\npublic static void addElements(List&lt;? super Integer&gt; list) {\n    list.add(1);  // Safe to add Integers\n    list.add(2);\n}\n\n// Both producer and consumer - use specific type\npublic static void transferElements(List&lt;Integer&gt; source, List&lt;? super Integer&gt; dest) {\n    for (Integer item : source) {\n        dest.add(item);\n    }\n}\n</code></pre>"},{"location":"java/java-generics/#type-erasure","title":"Type Erasure","text":"<p>Java implements generics using type erasure: generic type information is present only at compile time and erased at runtime.</p>"},{"location":"java/java-generics/#how-type-erasure-works","title":"How Type Erasure Works","text":"<ol> <li>Replaces type parameters with their bounds or Object if unbounded</li> <li>Inserts casts where necessary</li> <li>Generates bridge methods to preserve polymorphism</li> </ol> <pre><code>// Before erasure\npublic class Box&lt;T&gt; {\n    private T value;\n\n    public T getValue() {\n        return value;\n    }\n\n    public void setValue(T value) {\n        this.value = value;\n    }\n}\n\n// After erasure (conceptual representation)\npublic class Box {\n    private Object value;\n\n    public Object getValue() {\n        return value;\n    }\n\n    public void setValue(Object value) {\n        this.value = value;\n    }\n}\n</code></pre>"},{"location":"java/java-generics/#consequences-of-type-erasure","title":"Consequences of Type Erasure","text":""},{"location":"java/java-generics/#cannot-instantiate-type-parameters","title":"Cannot Instantiate Type Parameters","text":"<pre><code>public class Creator&lt;T&gt; {\n    // Error: Cannot instantiate the type parameter T\n    public T create() {\n        return new T();  // Compiler error\n    }\n\n    // Workaround: Use a factory or Class&lt;T&gt; parameter\n    public T createWithClass(Class&lt;T&gt; clazz) throws Exception {\n        return clazz.getDeclaredConstructor().newInstance();\n    }\n}\n</code></pre>"},{"location":"java/java-generics/#cannot-create-arrays-of-parameterized-types","title":"Cannot Create Arrays of Parameterized Types","text":"<pre><code>// Error: Cannot create arrays of generic types\n// List&lt;String&gt;[] array = new List&lt;String&gt;[10];  // Compiler error\n\n// Workaround: Create array of raw type and cast\n@SuppressWarnings(\"unchecked\")\nList&lt;String&gt;[] array = (List&lt;String&gt;[]) new List[10];  // Works but with unchecked warning\n</code></pre>"},{"location":"java/java-generics/#cannot-use-primitives-as-type-arguments","title":"Cannot Use Primitives as Type Arguments","text":"<pre><code>// Error: Cannot use primitive types as type arguments\n// Box&lt;int&gt; intBox = new Box&lt;&gt;();  // Compiler error\n\n// Solution: Use wrapper classes\nBox&lt;Integer&gt; integerBox = new Box&lt;&gt;();\n</code></pre>"},{"location":"java/java-generics/#cannot-overload-methods-that-differ-only-in-type-parameters","title":"Cannot Overload Methods That Differ Only in Type Parameters","text":"<pre><code>public class Processor {\n    // Compile error: Erasure causes method clash\n    public void process(List&lt;String&gt; strings) { /* ... */ }\n    public void process(List&lt;Integer&gt; integers) { /* ... */ }\n}\n</code></pre>"},{"location":"java/java-generics/#generics-and-collections","title":"Generics and Collections","text":"<p>The Java Collections Framework is one of the primary use cases for generics.</p>"},{"location":"java/java-generics/#type-safe-collections","title":"Type-Safe Collections","text":"<pre><code>// Type-safe collections\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();\nstrings.add(\"Hello\");\n// strings.add(42);  // Compile error: incompatible types\n\n// Type-safe map\nMap&lt;String, Integer&gt; nameToAge = new HashMap&lt;&gt;();\nnameToAge.put(\"Alice\", 30);\nnameToAge.put(\"Bob\", 25);\n\n// Type-safe iteration\nfor (String name : nameToAge.keySet()) {\n    Integer age = nameToAge.get(name);\n    System.out.println(name + \" is \" + age + \" years old\");\n}\n</code></pre>"},{"location":"java/java-generics/#using-collections-with-generic-methods","title":"Using Collections with Generic Methods","text":"<pre><code>public class CollectionUtils {\n    // Find maximum element in a collection\n    public static &lt;T extends Comparable&lt;T&gt;&gt; T findMax(Collection&lt;T&gt; collection) {\n        if (collection.isEmpty()) {\n            throw new IllegalArgumentException(\"Collection cannot be empty\");\n        }\n\n        Iterator&lt;T&gt; iterator = collection.iterator();\n        T max = iterator.next();\n\n        while (iterator.hasNext()) {\n            T current = iterator.next();\n            if (current.compareTo(max) &gt; 0) {\n                max = current;\n            }\n        }\n\n        return max;\n    }\n}\n\n// Usage\nList&lt;Integer&gt; numbers = Arrays.asList(3, 1, 4, 1, 5, 9);\nInteger max = CollectionUtils.findMax(numbers);  // 9\n</code></pre>"},{"location":"java/java-generics/#using-custom-objects-with-generics-and-collections","title":"Using Custom Objects with Generics and Collections","text":"<pre><code>// Custom class implementing Comparable\npublic class Person implements Comparable&lt;Person&gt; {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public int compareTo(Person other) {\n        return Integer.compare(this.age, other.age);\n    }\n\n    @Override\n    public String toString() {\n        return name + \" (\" + age + \")\";\n    }\n}\n\n// Usage in collections\nList&lt;Person&gt; people = Arrays.asList(\n    new Person(\"Alice\", 30),\n    new Person(\"Bob\", 25),\n    new Person(\"Charlie\", 35)\n);\n\n// Sort list of people (uses Person's compareTo method)\nCollections.sort(people);\n\n// Find oldest person using generic method\nPerson oldest = CollectionUtils.findMax(people);  // Charlie (35)\n</code></pre>"},{"location":"java/java-generics/#generics-and-inheritance","title":"Generics and Inheritance","text":"<p>Generics interact with inheritance in ways that can be initially confusing.</p>"},{"location":"java/java-generics/#type-relationships","title":"Type Relationships","text":"<p>For any types A and B where B is a subtype of A: - <code>B</code> is a subtype of <code>A</code> - <code>List&lt;B&gt;</code> is NOT a subtype of <code>List&lt;A&gt;</code> - <code>Box&lt;B&gt;</code> is NOT a subtype of <code>Box&lt;A&gt;</code></p> <p>This is a key point that's often surprising to newcomers:</p> <pre><code>// Regular inheritance\nObject obj = \"hello\";  // String is a subtype of Object\n\n// But with generics:\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();\n// List&lt;Object&gt; objects = strings;  // Compile error!\n</code></pre> <p>To understand why this restriction exists, consider what would happen if it were allowed: <pre><code>// If this were allowed (it's not):\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();\nList&lt;Object&gt; objects = strings;  // Hypothetically allowed\nobjects.add(42);  // Would add an Integer to a List&lt;String&gt;!\nString s = strings.get(0);  // ClassCastException at runtime\n</code></pre></p>"},{"location":"java/java-generics/#wildcards-for-inheritance-relationships","title":"Wildcards for Inheritance Relationships","text":"<p>Wildcards provide the solution:</p> <pre><code>// Using wildcards to enable inheritance relationships\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();\nstrings.add(\"hello\");\n\n// Reading with upper bounded wildcard\nList&lt;? extends Object&gt; objects = strings;  // OK\nObject obj = objects.get(0);  // OK to read\n// objects.add(\"world\");  // Compile error - can't add to ? extends Object\n\n// Writing with lower bounded wildcard\nList&lt;Object&gt; objectList = new ArrayList&lt;&gt;();\nList&lt;? super String&gt; stringSuperList = objectList;  // OK\nstringSuperList.add(\"hello\");  // OK to add String\n// String s = stringSuperList.get(0);  // Compile error - not safe to read as String\n</code></pre>"},{"location":"java/java-generics/#covariance-and-contravariance","title":"Covariance and Contravariance","text":"<ul> <li>Covariance: <code>&lt;? extends T&gt;</code> - preserves the \"is-a\" relationship</li> <li>Contravariance: <code>&lt;? super T&gt;</code> - reverses the \"is-a\" relationship</li> <li>Invariance: <code>&lt;T&gt;</code> - no subtyping relationship</li> </ul> <p>These terms describe how type relationships are preserved or modified by generics:</p> <pre><code>// Covariance: can read as T or its supertype\nList&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;();\nNumber n = numbers.get(0);  // Safe, because any element is at least a Number\n// numbers.add(1);  // Error, can't add to a list with unknown specific type\n\n// Contravariance: can write T or its subtypes\nList&lt;? super Number&gt; superNumbers = new ArrayList&lt;Object&gt;();\nsuperNumbers.add(1);  // Safe, because any Number can be added\nsuperNumbers.add(1.0);  // Safe, because any Number can be added\n// Number n = superNumbers.get(0);  // Error, can't read because it might be any supertype of Number\n</code></pre>"},{"location":"java/java-generics/#raw-types-and-backward-compatibility","title":"Raw Types and Backward Compatibility","text":""},{"location":"java/java-generics/#raw-types","title":"Raw Types","text":"<p>Raw types are generic types without type parameters. They exist for backward compatibility with pre-generic code.</p> <pre><code>// Raw type (avoid in new code)\nList rawList = new ArrayList();\nrawList.add(\"string\");\nrawList.add(42);\n\n// To retrieve elements, casting is required\nString s = (String) rawList.get(0);  // May throw ClassCastException at runtime\n</code></pre>"},{"location":"java/java-generics/#working-with-legacy-code","title":"Working with Legacy Code","text":"<p>Sometimes you need to interact with legacy code that uses raw types:</p> <pre><code>// Legacy method using raw types\npublic void legacyMethod(List list) {\n    list.add(\"Legacy element\");\n}\n\n// Modern code with generics\nList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();\nintegers.add(1);\nintegers.add(2);\n\n// Unchecked warning when passing generic to raw type\nlegacyMethod(integers);  // Warning: unchecked call to legacyMethod(List)\n\n// This could cause problems later\n// Integer i = integers.get(2);  // ClassCastException (String cannot be cast to Integer)\n</code></pre>"},{"location":"java/java-generics/#suppresswarnings-annotation","title":"SuppressWarnings Annotation","text":"<p>When integrating with legacy code, you can suppress unchecked warnings where appropriate:</p> <pre><code>public class LegacyIntegration {\n    // Suppress warnings for a specific statement\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; List&lt;T&gt; createFromLegacy(List legacyList) {\n        return (List&lt;T&gt;) new ArrayList&lt;&gt;(legacyList);\n    }\n\n    // Suppress warnings for an entire method\n    @SuppressWarnings(\"unchecked\")\n    public static void processList(List list) {\n        // Operations that would normally cause unchecked warnings\n    }\n}\n</code></pre>"},{"location":"java/java-generics/#advanced-generic-patterns","title":"Advanced Generic Patterns","text":""},{"location":"java/java-generics/#bounded-type-parameters-with-recursive-generics","title":"Bounded Type Parameters with Recursive Generics","text":"<p>This pattern is used to create self-referential types:</p> <pre><code>// Recursive type parameter for comparable entities\npublic abstract class Entity&lt;T extends Entity&lt;T&gt;&gt; implements Comparable&lt;T&gt; {\n    private Long id;\n    private String name;\n\n    // Default comparison based on ID\n    @Override\n    public int compareTo(T other) {\n        return this.id.compareTo(other.id);\n    }\n}\n\n// Concrete implementation\npublic class User extends Entity&lt;User&gt; {\n    private String email;\n\n    // User-specific implementation\n    @Override\n    public int compareTo(User other) {\n        // Custom comparison logic (e.g., by email)\n        return this.email.compareTo(other.email);\n    }\n}\n</code></pre>"},{"location":"java/java-generics/#builder-pattern-with-generics","title":"Builder Pattern with Generics","text":"<p>Generics enable fluent builder patterns with method chaining:</p> <pre><code>// Generic builder pattern\npublic class GenericBuilder&lt;T&gt; {\n    private final Supplier&lt;T&gt; instantiator;\n    private final List&lt;Consumer&lt;T&gt;&gt; modifiers = new ArrayList&lt;&gt;();\n\n    public GenericBuilder(Supplier&lt;T&gt; instantiator) {\n        this.instantiator = instantiator;\n    }\n\n    public &lt;V&gt; GenericBuilder&lt;T&gt; with(BiConsumer&lt;T, V&gt; consumer, V value) {\n        modifiers.add(instance -&gt; consumer.accept(instance, value));\n        return this;\n    }\n\n    public T build() {\n        T instance = instantiator.get();\n        modifiers.forEach(modifier -&gt; modifier.accept(instance));\n        return instance;\n    }\n}\n\n// Usage\nclass Person {\n    private String name;\n    private int age;\n\n    public void setName(String name) { this.name = name; }\n    public void setAge(int age) { this.age = age; }\n\n    @Override\n    public String toString() {\n        return \"Person{name='\" + name + \"', age=\" + age + \"}\";\n    }\n}\n\n// Building a person with the generic builder\nPerson person = new GenericBuilder&lt;&gt;(Person::new)\n        .with(Person::setName, \"John\")\n        .with(Person::setAge, 30)\n        .build();\n</code></pre>"},{"location":"java/java-generics/#type-safe-heterogeneous-container","title":"Type Safe Heterogeneous Container","text":"<p>A technique for storing objects of different types in a single container:</p> <pre><code>// Type token class\nclass TypeToken&lt;T&gt; {\n    private final Class&lt;T&gt; type;\n\n    @SuppressWarnings(\"unchecked\")\n    private TypeToken() {\n        // Use reflection to get the actual type argument\n        Type superclass = getClass().getGenericSuperclass();\n        ParameterizedType paramType = (ParameterizedType) superclass;\n        this.type = (Class&lt;T&gt;) paramType.getActualTypeArguments()[0];\n    }\n\n    public Class&lt;T&gt; getType() {\n        return type;\n    }\n}\n\n// Heterogeneous container\nclass TypeSafeMap {\n    private final Map&lt;Class&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();\n\n    public &lt;T&gt; void put(Class&lt;T&gt; type, T instance) {\n        map.put(type, instance);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public &lt;T&gt; T get(Class&lt;T&gt; type) {\n        return (T) map.get(type);\n    }\n}\n\n// Usage\nTypeSafeMap container = new TypeSafeMap();\ncontainer.put(String.class, \"Hello\");\ncontainer.put(Integer.class, 42);\n\nString s = container.get(String.class);   // \"Hello\"\nInteger i = container.get(Integer.class);  // 42\n</code></pre>"},{"location":"java/java-generics/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use generics for type safety:    <pre><code>// Avoid raw types in new code\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();  // Good\nList rawList = new ArrayList();  // Avoid\n</code></pre></p> </li> <li> <p>Favor bounded wildcards for API flexibility:    <pre><code>// Good - allows reading from any list of numbers\npublic double sumOfList(List&lt;? extends Number&gt; list) { /* ... */ }\n\n// Good - allows adding integers to any suitable list\npublic void addNumbers(List&lt;? super Integer&gt; list) { /* ... */ }\n</code></pre></p> </li> <li> <p>Remember PECS: Producer-Extends, Consumer-Super:    <pre><code>// Producer - use \"extends\" when getting values\npublic void printElements(Collection&lt;? extends Number&gt; numbers) {\n    for (Number n : numbers) {\n        System.out.println(n);\n    }\n}\n\n// Consumer - use \"super\" when adding values\npublic void fillWithIntegers(Collection&lt;? super Integer&gt; collection) {\n    collection.add(1);\n    collection.add(2);\n}\n</code></pre></p> </li> <li> <p>Minimize wildcard usage within a class:    <pre><code>// Only use wildcards in public APIs when needed\n// For private or internal methods, use concrete type parameters\n</code></pre></p> </li> <li> <p>Provide factory methods for generic instance creation:    <pre><code>// Factory method to overcome \"new T()\" restriction\npublic static &lt;T&gt; List&lt;T&gt; createArrayList(Class&lt;T&gt; clazz) {\n    return new ArrayList&lt;&gt;();\n}\n</code></pre></p> </li> <li> <p>Use explicit type parameters when type inference fails:    <pre><code>// When inference doesn't work\nList&lt;String&gt; list = Collections.&lt;String&gt;emptyList();\n</code></pre></p> </li> <li> <p>Document generic parameters clearly:    <pre><code>/**\n * Performs a binary search on the specified list.\n *\n * @param &lt;T&gt; the type of elements in the list\n * @param list the list to be searched (must be sorted)\n * @param key the key to be searched for\n * @return the index of the key, if it is contained in the list;\n *         otherwise, (-(insertion point) - 1)\n */\npublic static &lt;T extends Comparable&lt;? super T&gt;&gt; \n        int binarySearch(List&lt;? extends T&gt; list, T key) {\n    // Implementation\n}\n</code></pre></p> </li> <li> <p>Use generic types all the way through:    <pre><code>// Maintain type safety throughout your code\npublic &lt;T&gt; List&lt;T&gt; filterList(List&lt;T&gt; list, Predicate&lt;T&gt; predicate) {\n    List&lt;T&gt; result = new ArrayList&lt;&gt;();\n    for (T element : list) {\n        if (predicate.test(element)) {\n            result.add(element);\n        }\n    }\n    return result;\n}\n</code></pre></p> </li> <li> <p>Use @SuppressWarnings sparingly and with comments:    <pre><code>// Only suppress warnings when you're sure it's safe\n@SuppressWarnings(\"unchecked\") // Safe because we know the list contains only strings\npublic static &lt;T&gt; List&lt;T&gt; createList(T... elements) {\n    return (List&lt;T&gt;) Arrays.asList(elements);\n}\n</code></pre></p> </li> <li> <p>Avoid excessive generic complexity:     <pre><code>// Overly complex generics can be hard to understand\npublic &lt;K, V extends Comparable&lt;? super V&gt;&gt; \n       Pair&lt;K, V&gt; findMaxByValue(Map&lt;K, V&gt; map) {\n    // This is already complex enough\n}\n\n// Even more complex - avoid unless necessary\npublic &lt;T, S extends Collection&lt;? extends T&gt;, \n       R extends Collection&lt;? super T&gt;&gt; \n       R transferElements(S source, R dest) {\n    // Too complex\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-generics/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":"<ol> <li> <p>Mixing raw types with generics:    <pre><code>// Problematic\nList rawList = new ArrayList&lt;String&gt;();  // Raw use of List\nrawList.add(42);  // No compile-time error, but will cause problems\n\n// Correct\nList&lt;String&gt; stringList = new ArrayList&lt;&gt;();\n</code></pre></p> </li> <li> <p>Trying to instantiate type parameters:    <pre><code>// Won't work\npublic &lt;T&gt; T create() {\n    return new T();  // Compiler error\n}\n\n// Alternative: pass a factory or Class&lt;T&gt; with newInstance()\npublic &lt;T&gt; T create(Supplier&lt;T&gt; factory) {\n    return factory.get();\n}\n</code></pre></p> </li> <li> <p>Attempting to create arrays of parameterized types:    <pre><code>// Won't work\nList&lt;String&gt;[] arrayOfLists = new List&lt;String&gt;[10];  // Compiler error\n\n// Alternative: use a List of Lists\nList&lt;List&lt;String&gt;&gt; listOfLists = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; 10; i++) {\n    listOfLists.add(new ArrayList&lt;&gt;());\n}\n</code></pre></p> </li> <li> <p>Overloading methods with different generic parameters:    <pre><code>// Won't work - after erasure, these are the same method\npublic void process(List&lt;String&gt; strings) { /* ... */ }\npublic void process(List&lt;Integer&gt; integers) { /* ... */ }\n\n// Alternative: use different method names\npublic void processStrings(List&lt;String&gt; strings) { /* ... */ }\npublic void processIntegers(List&lt;Integer&gt; integers) { /* ... */ }\n</code></pre></p> </li> <li> <p>Assuming List is a subtype of List:    <pre><code>// Won't work\nList&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();\nList&lt;Animal&gt; animals = dogs;  // Compiler error\n\n// Use wildcards instead\nList&lt;? extends Animal&gt; animals = dogs;  // OK\n</code></pre> <li> <p>Ignoring compiler warnings:    <pre><code>// Unchecked assignment warnings should not be ignored without thought\nList&lt;String&gt; strings = new ArrayList();  // Warning: unchecked conversion\n\n// Either fix the code or suppress with justification\n@SuppressWarnings(\"unchecked\")  // Suppression reason explained here\nList&lt;String&gt; strings = new ArrayList();\n</code></pre></p> </li> <li> <p>Excessive use of wildcards:    <pre><code>// Too complex\nMap&lt;? extends String, ? extends List&lt;? extends Number&gt;&gt; map;\n\n// Consider simplifying\nMap&lt;String, List&lt;Number&gt;&gt; map;\n</code></pre></p> </li> <li> <p>Forgetting generic type arguments:    <pre><code>// Accidental use of raw type\nSet set = new HashSet&lt;&gt;();  // Missing type arguments\nset.add(\"string\");\nInteger i = (Integer) set.iterator().next();  // ClassCastException\n\n// Be explicit\nSet&lt;String&gt; set = new HashSet&lt;&gt;();\n</code></pre></p> </li> <li> <p>Combining wildcards with type inference incorrectly:    <pre><code>// This won't compile as expected\nList&lt;?&gt; wildcardList = new ArrayList&lt;&gt;();\nwildcardList.add(\"string\");  // Compiler error - can't add to List&lt;?&gt;\n\n// Correct usage\nList&lt;String&gt; typedList = new ArrayList&lt;&gt;();\ntypedList.add(\"string\");\nList&lt;?&gt; wildcardList = typedList;  // OK for read-only operations\n</code></pre></p> </li> <li> <p>Misunderstanding invariance:     <pre><code>// Won't work\nList&lt;Object&gt; objectList = new ArrayList&lt;String&gt;();  // Compiler error\n\n// Won't work either\nvoid addToList(List&lt;Object&gt; list) { list.add(42); }\nList&lt;String&gt; strings = new ArrayList&lt;&gt;();\naddToList(strings);  // Compiler error, prevents heap pollution\n</code></pre></p> </li>"},{"location":"java/java-generics/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>Java Generics Tutorial</li> <li> <p>Java Generics FAQs</p> </li> <li> <p>Books:</p> </li> <li>\"Java Generics and Collections\" by Maurice Naftalin and Philip Wadler</li> <li>\"Effective Java\" by Joshua Bloch (Chapter on Generics)</li> <li> <p>\"Java Generics\" by Gilad Bracha</p> </li> <li> <p>Online Resources:</p> </li> <li>Baeldung Java Generics Tutorials</li> <li>Oracle's Java Magazine: Understanding Generics</li> <li> <p>Generic Programming in Java</p> </li> <li> <p>Advanced Topics:</p> </li> <li>Type Erasure Details</li> <li>Wildcards in Java</li> <li>Reifiable Types</li> </ol>"},{"location":"java/java-generics/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>Generic Box Implementation:    Create a generic <code>Box&lt;T&gt;</code> class that can store and retrieve a value of any type. Implement methods to check if the box is empty and to clear its contents.</p> </li> <li> <p>Generic Pair Class:    Implement a <code>Pair&lt;K,V&gt;</code> class that holds two values of potentially different types. Include methods to access, modify, and swap the values.</p> </li> <li> <p>Generic Stack:    Create a generic stack implementation with <code>push()</code>, <code>pop()</code>, <code>peek()</code>, and <code>isEmpty()</code> methods.</p> </li> <li> <p>Type-Safe Heterogeneous Container:    Implement a container that can store objects of different types and retrieve them safely without casting.</p> </li> <li> <p>Generic Binary Tree:    Implement a generic binary tree structure with methods for insertion, traversal, and search.</p> </li> <li> <p>Function Composition:    Create a utility class that allows composing functions with different input and output types using generics.</p> </li> <li> <p>Generic Sorting:    Implement a generic method that can sort any list of comparable objects.</p> </li> <li> <p>Generic Cache:    Create a cache implementation that can store and retrieve different types of objects using keys.</p> </li> <li> <p>Type-Safe Builder Pattern:    Implement a generic builder pattern that ensures type safety during the building process.</p> </li> <li> <p>Covariant Result Type Pattern:     Create a class hierarchy with methods that return a more specific type in subclasses using generics. </p> </li> </ol>"},{"location":"java/java-io/","title":"Java I/O (Input/Output)","text":""},{"location":"java/java-io/#overview","title":"Overview","text":"<p>Java I/O (Input/Output) provides a comprehensive set of classes for performing input and output operations in Java applications. The I/O API allows Java programs to read and write data from various sources and destinations, including files, network connections, memory buffers, and other devices. This guide covers both the traditional I/O package (java.io) and the enhanced NIO (New I/O) package (java.nio) introduced in Java 1.4, along with NIO.2 features added in Java 7.</p>"},{"location":"java/java-io/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Java programming knowledge</li> <li>Understanding of exception handling in Java</li> <li>Familiarity with Java streams concepts</li> </ul>"},{"location":"java/java-io/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the Java I/O architecture and class hierarchy</li> <li>Learn how to work with files and directories</li> <li>Master reading from and writing to files using various streams</li> <li>Use character and byte streams appropriately</li> <li>Implement buffered I/O operations for improved performance</li> <li>Understand object serialization and deserialization</li> <li>Work with the enhanced NIO and NIO.2 APIs</li> <li>Apply best practices for resource management and performance optimization</li> </ul>"},{"location":"java/java-io/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Java I/O Architecture</li> <li>File Handling</li> <li>Byte Streams</li> <li>Character Streams</li> <li>Buffered Streams</li> <li>Data Streams</li> <li>Object Serialization</li> <li>NIO (New I/O)</li> <li>NIO.2 (Java 7+)</li> <li>Files and Path API</li> <li>Memory-Mapped Files</li> <li>Asynchronous I/O</li> </ol>"},{"location":"java/java-io/#java-io-architecture","title":"Java I/O Architecture","text":"<p>Java's I/O architecture is designed around streams, channels, buffers, and selectors:</p>"},{"location":"java/java-io/#stream-based-io-javaio","title":"Stream-Based I/O (java.io)","text":"<p>The traditional I/O package is based on the concept of streams. A stream represents a sequence of data and supports various operations to read from or write to the stream.</p> <p>Key Characteristics: - Primarily blocking operations - Byte-oriented and character-oriented streams - Simple sequential access model - Extensible through decorator pattern</p>"},{"location":"java/java-io/#channel-based-io-javanio","title":"Channel-Based I/O (java.nio)","text":"<p>NIO introduced the concept of channels and buffers for more efficient I/O operations.</p> <p>Key Characteristics: - Support for non-blocking operations - Buffer-oriented rather than stream-oriented - Selectors for multiplexed, non-blocking I/O - More complex but potentially more efficient</p>"},{"location":"java/java-io/#class-hierarchy-overview","title":"Class Hierarchy Overview","text":"<pre><code>java.io Class Hierarchy:\n\nInputStream\n\u251c\u2500\u2500 FileInputStream\n\u251c\u2500\u2500 ByteArrayInputStream\n\u251c\u2500\u2500 FilterInputStream\n\u2502   \u251c\u2500\u2500 BufferedInputStream\n\u2502   \u2514\u2500\u2500 DataInputStream\n\u251c\u2500\u2500 ObjectInputStream\n\u2514\u2500\u2500 PipedInputStream\n\nOutputStream\n\u251c\u2500\u2500 FileOutputStream\n\u251c\u2500\u2500 ByteArrayOutputStream\n\u251c\u2500\u2500 FilterOutputStream\n\u2502   \u251c\u2500\u2500 BufferedOutputStream\n\u2502   \u2514\u2500\u2500 DataOutputStream\n\u251c\u2500\u2500 ObjectOutputStream\n\u2514\u2500\u2500 PipedOutputStream\n\nReader\n\u251c\u2500\u2500 BufferedReader\n\u251c\u2500\u2500 InputStreamReader\n\u2502   \u2514\u2500\u2500 FileReader\n\u251c\u2500\u2500 StringReader\n\u2514\u2500\u2500 PipedReader\n\nWriter\n\u251c\u2500\u2500 BufferedWriter\n\u251c\u2500\u2500 OutputStreamWriter\n\u2502   \u2514\u2500\u2500 FileWriter\n\u251c\u2500\u2500 StringWriter\n\u251c\u2500\u2500 PrintWriter\n\u2514\u2500\u2500 PipedWriter\n</code></pre>"},{"location":"java/java-io/#file-handling","title":"File Handling","text":""},{"location":"java/java-io/#working-with-the-file-class","title":"Working with the File Class","text":"<p>The <code>File</code> class represents a file or directory path. It provides methods to create, delete, and manipulate files and directories.</p> <pre><code>// Creating a File object\nFile file = new File(\"example.txt\");\n\n// Checking if a file exists\nboolean exists = file.exists();\n\n// Getting file properties\nString name = file.getName();\nString path = file.getPath();\nString absolutePath = file.getAbsolutePath();\nlong length = file.length();\nboolean isDirectory = file.isDirectory();\nboolean isFile = file.isFile();\nlong lastModified = file.lastModified();\n\n// File operations\nboolean created = file.createNewFile();\nboolean deleted = file.delete();\nboolean renamed = file.renameTo(new File(\"new_name.txt\"));\n\n// Directory operations\nFile dir = new File(\"my_directory\");\nboolean dirCreated = dir.mkdir();\nboolean dirTreeCreated = dir.mkdirs(); // Creates parent directories too\n\n// Listing directory contents\nFile[] files = dir.listFiles();\nString[] fileNames = dir.list();\n\n// File filtering\nFile[] javaFiles = dir.listFiles((d, name) -&gt; name.endsWith(\".java\"));\n</code></pre>"},{"location":"java/java-io/#file-vs-path-javaniofile","title":"File vs Path (java.nio.file)","text":"<p>While <code>File</code> is part of the legacy I/O API, <code>Path</code> and <code>Files</code> were introduced in Java 7 (NIO.2) and provide more powerful and flexible file operations.</p> <pre><code>// Using Path (Java 7+)\nPath path = Paths.get(\"example.txt\");\nboolean exists = Files.exists(path);\n</code></pre>"},{"location":"java/java-io/#byte-streams","title":"Byte Streams","text":"<p>Byte streams work with binary data and are suitable for processing all types of data, including text, images, audio, etc.</p>"},{"location":"java/java-io/#fileinputstream-and-fileoutputstream","title":"FileInputStream and FileOutputStream","text":"<p>For reading from and writing to files at the byte level.</p> <pre><code>// Reading from a file byte by byte\ntry (FileInputStream fis = new FileInputStream(\"input.txt\")) {\n    int data;\n    while ((data = fis.read()) != -1) {\n        // Process each byte\n        System.out.print((char) data);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Writing to a file byte by byte\ntry (FileOutputStream fos = new FileOutputStream(\"output.txt\")) {\n    String message = \"Hello, Java I/O!\";\n    byte[] bytes = message.getBytes();\n    fos.write(bytes);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Reading/writing byte arrays\ntry (FileInputStream fis = new FileInputStream(\"input.txt\");\n     FileOutputStream fos = new FileOutputStream(\"output.txt\")) {\n\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n\n    while ((bytesRead = fis.read(buffer)) != -1) {\n        fos.write(buffer, 0, bytesRead);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#bytearrayinputstream-and-bytearrayoutputstream","title":"ByteArrayInputStream and ByteArrayOutputStream","text":"<p>For reading from and writing to byte arrays in memory.</p> <pre><code>// Reading from a byte array\nbyte[] data = {65, 66, 67, 68, 69}; // ABCDE\ntry (ByteArrayInputStream bais = new ByteArrayInputStream(data)) {\n    int byteData;\n    while ((byteData = bais.read()) != -1) {\n        System.out.print((char) byteData);\n    }\n}\n\n// Writing to a byte array\ntry (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n    baos.write(\"Hello\".getBytes());\n    baos.write(\", \".getBytes());\n    baos.write(\"World!\".getBytes());\n\n    byte[] byteArray = baos.toByteArray();\n    String result = new String(byteArray);\n    System.out.println(result); // Hello, World!\n}\n</code></pre>"},{"location":"java/java-io/#character-streams","title":"Character Streams","text":"<p>Character streams work with text data and automatically handle character encoding/decoding.</p>"},{"location":"java/java-io/#reader-and-writer","title":"Reader and Writer","text":"<p>Abstract base classes for character-based input and output streams.</p>"},{"location":"java/java-io/#filereader-and-filewriter","title":"FileReader and FileWriter","text":"<p>For reading from and writing to files using the default character encoding.</p> <pre><code>// Reading characters from a file\ntry (FileReader reader = new FileReader(\"input.txt\")) {\n    int character;\n    while ((character = reader.read()) != -1) {\n        System.out.print((char) character);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Writing characters to a file\ntry (FileWriter writer = new FileWriter(\"output.txt\")) {\n    writer.write(\"Hello, Character Streams!\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Appending to a file\ntry (FileWriter writer = new FileWriter(\"output.txt\", true)) { // append mode\n    writer.write(\"\\nThis is appended text.\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#inputstreamreader-and-outputstreamwriter","title":"InputStreamReader and OutputStreamWriter","text":"<p>Bridge classes between byte streams and character streams with explicit charset support.</p> <pre><code>// Reading with a specific charset\ntry (FileInputStream fis = new FileInputStream(\"input.txt\");\n     InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);\n     BufferedReader reader = new BufferedReader(isr)) {\n\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Writing with a specific charset\ntry (FileOutputStream fos = new FileOutputStream(\"output.txt\");\n     OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);\n     BufferedWriter writer = new BufferedWriter(osw)) {\n\n    writer.write(\"Text with explicit UTF-8 encoding\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#stringreader-and-stringwriter","title":"StringReader and StringWriter","text":"<p>For reading from and writing to String objects.</p> <pre><code>// Reading from a string\ntry (StringReader reader = new StringReader(\"Hello, StringReader!\")) {\n    int character;\n    while ((character = reader.read()) != -1) {\n        System.out.print((char) character);\n    }\n}\n\n// Writing to a string\ntry (StringWriter writer = new StringWriter()) {\n    writer.write(\"Hello, StringWriter!\");\n    writer.write(\" This text is in memory.\");\n\n    String result = writer.toString();\n    System.out.println(result);\n}\n</code></pre>"},{"location":"java/java-io/#buffered-streams","title":"Buffered Streams","text":"<p>Buffered streams improve performance by reducing the number of I/O operations through buffering.</p>"},{"location":"java/java-io/#bufferedinputstream-and-bufferedoutputstream","title":"BufferedInputStream and BufferedOutputStream","text":"<p>For buffered byte stream I/O.</p> <pre><code>// Buffered file reading (bytes)\ntry (FileInputStream fis = new FileInputStream(\"input.txt\");\n     BufferedInputStream bis = new BufferedInputStream(fis)) {\n\n    int data;\n    while ((data = bis.read()) != -1) {\n        System.out.print((char) data);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Buffered file writing (bytes)\ntry (FileOutputStream fos = new FileOutputStream(\"output.txt\");\n     BufferedOutputStream bos = new BufferedOutputStream(fos)) {\n\n    String text = \"Text written with buffered output.\";\n    bos.write(text.getBytes());\n    // No need to flush explicitly when using try-with-resources\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#bufferedreader-and-bufferedwriter","title":"BufferedReader and BufferedWriter","text":"<p>For buffered character stream I/O.</p> <pre><code>// Reading lines from a file\ntry (FileReader fr = new FileReader(\"input.txt\");\n     BufferedReader br = new BufferedReader(fr)) {\n\n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Writing lines to a file\ntry (FileWriter fw = new FileWriter(\"output.txt\");\n     BufferedWriter bw = new BufferedWriter(fw)) {\n\n    bw.write(\"Line 1\");\n    bw.newLine(); // Platform-dependent line separator\n    bw.write(\"Line 2\");\n    bw.newLine();\n    bw.write(\"Line 3\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#data-streams","title":"Data Streams","text":"<p>Data streams allow reading and writing of primitive data types and strings.</p>"},{"location":"java/java-io/#datainputstream-and-dataoutputstream","title":"DataInputStream and DataOutputStream","text":"<p>For reading and writing primitive Java data types.</p> <pre><code>// Writing primitive data types\ntry (FileOutputStream fos = new FileOutputStream(\"data.bin\");\n     DataOutputStream dos = new DataOutputStream(fos)) {\n\n    dos.writeInt(123);\n    dos.writeDouble(3.14159);\n    dos.writeBoolean(true);\n    dos.writeUTF(\"Hello, DataOutputStream!\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Reading primitive data types\ntry (FileInputStream fis = new FileInputStream(\"data.bin\");\n     DataInputStream dis = new DataInputStream(fis)) {\n\n    int intValue = dis.readInt();\n    double doubleValue = dis.readDouble();\n    boolean booleanValue = dis.readBoolean();\n    String stringValue = dis.readUTF();\n\n    System.out.println(\"Int: \" + intValue);\n    System.out.println(\"Double: \" + doubleValue);\n    System.out.println(\"Boolean: \" + booleanValue);\n    System.out.println(\"String: \" + stringValue);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#object-serialization","title":"Object Serialization","text":"<p>Object serialization allows converting Java objects to byte streams and vice versa.</p>"},{"location":"java/java-io/#serializable-interface","title":"Serializable Interface","text":"<p>Classes must implement this marker interface to be serializable.</p> <pre><code>// Serializable class\npublic class Person implements Serializable {\n    private static final long serialVersionUID = 1L; // Important for versioning\n\n    private String name;\n    private int age;\n    private transient String secretData; // transient fields aren't serialized\n\n    // Constructor, getters, setters\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person [name=\" + name + \", age=\" + age + \"]\";\n    }\n}\n</code></pre>"},{"location":"java/java-io/#objectinputstream-and-objectoutputstream","title":"ObjectInputStream and ObjectOutputStream","text":"<p>For reading and writing serialized objects.</p> <pre><code>// Serializing an object\ntry (FileOutputStream fos = new FileOutputStream(\"person.ser\");\n     ObjectOutputStream oos = new ObjectOutputStream(fos)) {\n\n    Person person = new Person(\"John Doe\", 30);\n    oos.writeObject(person);\n    System.out.println(\"Object serialized successfully\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Deserializing an object\ntry (FileInputStream fis = new FileInputStream(\"person.ser\");\n     ObjectInputStream ois = new ObjectInputStream(fis)) {\n\n    Person person = (Person) ois.readObject();\n    System.out.println(\"Object deserialized: \" + person);\n} catch (IOException | ClassNotFoundException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#serialization-customization","title":"Serialization Customization","text":"<p>Custom serialization behavior can be implemented using special methods.</p> <pre><code>public class CustomPerson implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private String firstName;\n    private String lastName;\n    private transient String fullName; // Derived field, not serialized\n\n    public CustomPerson(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        updateFullName();\n    }\n\n    private void updateFullName() {\n        this.fullName = firstName + \" \" + lastName;\n    }\n\n    // Called during serialization\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject(); // Default serialization\n        // Additional custom serialization if needed\n    }\n\n    // Called during deserialization\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject(); // Default deserialization\n        updateFullName(); // Reconstruct transient fields\n    }\n}\n</code></pre>"},{"location":"java/java-io/#nio-new-io","title":"NIO (New I/O)","text":"<p>Java NIO provides an alternative set of I/O APIs for improved performance.</p>"},{"location":"java/java-io/#channels-and-buffers","title":"Channels and Buffers","text":"<p>The core components of the NIO API.</p> <pre><code>// Reading a file using a channel and buffer\ntry (RandomAccessFile file = new RandomAccessFile(\"input.txt\", \"r\");\n     FileChannel channel = file.getChannel()) {\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n    int bytesRead = channel.read(buffer);\n\n    while (bytesRead != -1) {\n        buffer.flip(); // Switch from writing to reading mode\n\n        while (buffer.hasRemaining()) {\n            System.out.print((char) buffer.get());\n        }\n\n        buffer.clear(); // Prepare buffer for writing\n        bytesRead = channel.read(buffer);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Writing to a file using a channel and buffer\ntry (FileOutputStream fos = new FileOutputStream(\"output.txt\");\n     FileChannel channel = fos.getChannel()) {\n\n    String text = \"Hello, NIO Channel!\";\n    ByteBuffer buffer = ByteBuffer.allocate(128);\n    buffer.put(text.getBytes());\n    buffer.flip(); // Switch from writing to reading mode\n\n    while (buffer.hasRemaining()) {\n        channel.write(buffer);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#direct-vs-non-direct-buffers","title":"Direct vs. Non-Direct Buffers","text":"<p>NIO provides two types of ByteBuffers.</p> <pre><code>// Non-direct buffer (heap buffer)\nByteBuffer heapBuffer = ByteBuffer.allocate(1024);\n\n// Direct buffer (off-heap)\nByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);\n</code></pre>"},{"location":"java/java-io/#buffer-operations","title":"Buffer Operations","text":"<p>Important methods for working with buffers.</p> <pre><code>ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n// Writing to buffer\nbuffer.put((byte) 'H');\nbuffer.put((byte) 'e');\nbuffer.put((byte) 'l');\nbuffer.put((byte) 'l');\nbuffer.put((byte) 'o');\n\n// Prepare for reading\nbuffer.flip();\n\n// Reading from buffer\nwhile (buffer.hasRemaining()) {\n    byte b = buffer.get();\n    System.out.print((char) b);\n}\n\n// Clearing the buffer\nbuffer.clear();\n\n// Other useful methods\nbuffer.rewind(); // Resets position to 0\nbuffer.compact(); // Compacts the buffer (copies unread data to the beginning)\nbuffer.mark(); // Sets a mark at the current position\nbuffer.reset(); // Resets the position to the previously set mark\n</code></pre>"},{"location":"java/java-io/#scattergather-operations","title":"Scatter/Gather Operations","text":"<p>Reading from a channel to multiple buffers or writing from multiple buffers to a channel.</p> <pre><code>// Scatter read\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body = ByteBuffer.allocate(1024);\nByteBuffer[] buffers = { header, body };\n\ntry (FileChannel channel = new RandomAccessFile(\"data.txt\", \"r\").getChannel()) {\n    channel.read(buffers);\n\n    header.flip();\n    body.flip();\n\n    // Process header and body separately\n}\n\n// Gather write\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body = ByteBuffer.allocate(1024);\n\n// Fill buffers with data\n// ...\n\nByteBuffer[] buffers = { header, body };\ntry (FileChannel channel = new FileOutputStream(\"data.txt\").getChannel()) {\n    channel.write(buffers);\n}\n</code></pre>"},{"location":"java/java-io/#selectors","title":"Selectors","text":"<p>For multiplexed, non-blocking I/O operations.</p> <pre><code>// Setting up a selector (usually used for network I/O)\nSelector selector = Selector.open();\n\n// Registering a channel with a selector\nServerSocketChannel serverChannel = ServerSocketChannel.open();\nserverChannel.configureBlocking(false);\nserverChannel.socket().bind(new InetSocketAddress(8080));\nserverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n// Selector operation loop\nwhile (true) {\n    int readyChannels = selector.select();\n    if (readyChannels == 0) continue;\n\n    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();\n    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();\n\n    while (keyIterator.hasNext()) {\n        SelectionKey key = keyIterator.next();\n\n        if (key.isAcceptable()) {\n            // Accept connection\n        } else if (key.isReadable()) {\n            // Read data\n        } else if (key.isWritable()) {\n            // Write data\n        }\n\n        keyIterator.remove();\n    }\n}\n</code></pre>"},{"location":"java/java-io/#nio2-java-7","title":"NIO.2 (Java 7+)","text":"<p>Java 7 introduced NIO.2 with significant improvements to file system operations.</p>"},{"location":"java/java-io/#path-interface","title":"Path Interface","text":"<p>A modern replacement for the File class.</p> <pre><code>// Creating a Path\nPath path1 = Paths.get(\"data.txt\");\nPath path2 = Paths.get(\"/home\", \"user\", \"documents\", \"data.txt\");\nPath path3 = Paths.get(URI.create(\"file:///home/user/documents/data.txt\"));\n\n// Path operations\nPath fileName = path1.getFileName();\nPath parent = path1.getParent();\nint nameCount = path1.getNameCount();\nPath subpath = path1.subpath(0, 2);\nPath normalized = path1.normalize();\nPath resolved = path1.resolve(\"subdir/file.txt\");\nPath relativized = path1.relativize(path2);\n</code></pre>"},{"location":"java/java-io/#files-and-path-api","title":"Files and Path API","text":"<p>The Files class provides utility methods for file operations.</p>"},{"location":"java/java-io/#basic-file-operations","title":"Basic File Operations","text":"<pre><code>Path path = Paths.get(\"example.txt\");\n\n// Checking file attributes\nboolean exists = Files.exists(path);\nboolean isRegularFile = Files.isRegularFile(path);\nboolean isDirectory = Files.isDirectory(path);\nboolean isReadable = Files.isReadable(path);\nboolean isWritable = Files.isWritable(path);\n\n// Creating files and directories\nPath newFile = Files.createFile(Paths.get(\"newfile.txt\"));\nPath newDir = Files.createDirectory(Paths.get(\"newdir\"));\nPath newDirs = Files.createDirectories(Paths.get(\"dir1/dir2/dir3\"));\n\n// Copying and moving files\nPath source = Paths.get(\"source.txt\");\nPath target = Paths.get(\"target.txt\");\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\nFiles.move(source, target, StandardCopyOption.REPLACE_EXISTING);\n\n// Deleting files\nFiles.delete(path);\nboolean deleted = Files.deleteIfExists(path);\n</code></pre>"},{"location":"java/java-io/#reading-and-writing-files","title":"Reading and Writing Files","text":"<pre><code>Path path = Paths.get(\"example.txt\");\n\n// Reading all bytes\nbyte[] bytes = Files.readAllBytes(path);\n\n// Reading all lines\nList&lt;String&gt; lines = Files.readAllLines(path, StandardCharsets.UTF_8);\n\n// Writing bytes and strings\nFiles.write(path, \"Hello, Files API!\".getBytes());\nFiles.write(path, Arrays.asList(\"Line 1\", \"Line 2\"), StandardCharsets.UTF_8);\n\n// Streaming lines (Java 8+)\ntry (Stream&lt;String&gt; stream = Files.lines(path, StandardCharsets.UTF_8)) {\n    stream.forEach(System.out::println);\n}\n</code></pre>"},{"location":"java/java-io/#walking-a-directory-tree","title":"Walking a Directory Tree","text":"<pre><code>Path startPath = Paths.get(\"src\");\n\n// Simple directory listing\ntry (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(startPath)) {\n    for (Path entry : stream) {\n        System.out.println(entry);\n    }\n}\n\n// Walking a directory tree\ntry (Stream&lt;Path&gt; stream = Files.walk(startPath)) {\n    stream.filter(Files::isRegularFile)\n          .filter(p -&gt; p.toString().endsWith(\".java\"))\n          .forEach(System.out::println);\n}\n\n// Finding files\ntry (Stream&lt;Path&gt; stream = Files.find(startPath, Integer.MAX_VALUE,\n        (path, attr) -&gt; path.toString().endsWith(\".java\") &amp;&amp; attr.isRegularFile())) {\n    stream.forEach(System.out::println);\n}\n\n// Using a FileVisitor\nFiles.walkFileTree(startPath, new SimpleFileVisitor&lt;Path&gt;() {\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n        System.out.println(\"File: \" + file);\n        return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n        System.out.println(\"Directory: \" + dir);\n        return FileVisitResult.CONTINUE;\n    }\n});\n</code></pre>"},{"location":"java/java-io/#file-attributes","title":"File Attributes","text":"<pre><code>Path path = Paths.get(\"example.txt\");\n\n// Basic attributes\nBasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\nSystem.out.println(\"Size: \" + attrs.size());\nSystem.out.println(\"Creation time: \" + attrs.creationTime());\nSystem.out.println(\"Last modified: \" + attrs.lastModifiedTime());\nSystem.out.println(\"Last access: \" + attrs.lastAccessTime());\nSystem.out.println(\"Is directory: \" + attrs.isDirectory());\nSystem.out.println(\"Is regular file: \" + attrs.isRegularFile());\n\n// Specific file system attributes (POSIX)\nPosixFileAttributes posixAttrs = Files.readAttributes(path, PosixFileAttributes.class);\nSystem.out.println(\"Owner: \" + posixAttrs.owner());\nSystem.out.println(\"Group: \" + posixAttrs.group());\nSystem.out.println(\"Permissions: \" + PosixFilePermissions.toString(posixAttrs.permissions()));\n\n// Setting attributes\nFiles.setAttribute(path, \"lastModifiedTime\", FileTime.fromMillis(System.currentTimeMillis()));\nFiles.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));\n</code></pre>"},{"location":"java/java-io/#memory-mapped-files","title":"Memory-Mapped Files","text":"<p>Memory-mapped files provide high-performance I/O by mapping a file directly into memory.</p> <pre><code>// Reading a file using memory mapping\ntry (RandomAccessFile file = new RandomAccessFile(\"bigfile.data\", \"r\");\n     FileChannel channel = file.getChannel()) {\n\n    long fileSize = channel.size();\n    MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n\n    // Directly access the file as if it were in memory\n    for (int i = 0; i &lt; fileSize; i++) {\n        byte b = buffer.get(i);\n        // Process byte\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Writing to a memory-mapped file\ntry (RandomAccessFile file = new RandomAccessFile(\"output.data\", \"rw\");\n     FileChannel channel = file.getChannel()) {\n\n    long fileSize = 1024 * 1024; // 1MB\n    MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);\n\n    // Write to the file through memory\n    for (int i = 0; i &lt; fileSize; i++) {\n        buffer.put(i, (byte) (i % 256));\n    }\n\n    buffer.force(); // Flush changes to disk\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#asynchronous-io","title":"Asynchronous I/O","text":"<p>Java 7 introduced asynchronous I/O with the <code>AsynchronousChannel</code> interfaces.</p> <pre><code>// Asynchronous file reading\ntry (AsynchronousFileChannel channel = \n        AsynchronousFileChannel.open(Paths.get(\"input.txt\"), StandardOpenOption.READ)) {\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    // Read with Future\n    Future&lt;Integer&gt; result = channel.read(buffer, 0);\n    while (!result.isDone()) {\n        // Do something else while waiting\n    }\n\n    int bytesRead = result.get();\n    buffer.flip();\n\n    // ... process data in buffer\n\n    // Read with CompletionHandler\n    channel.read(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            attachment.flip();\n            // Process data\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            exc.printStackTrace();\n        }\n    });\n} catch (IOException | InterruptedException | ExecutionException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"java/java-io/#best-practices","title":"Best Practices","text":"<ol> <li>Always close resources properly:</li> <li>Use try-with-resources (Java 7+) for automatic resource management</li> <li> <p>For pre-Java 7, use finally blocks to ensure closing    <pre><code>// Good (Java 7+)\ntry (FileInputStream fis = new FileInputStream(\"file.txt\")) {\n    // Use the resource\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Pre-Java 7\nFileInputStream fis = null;\ntry {\n    fis = new FileInputStream(\"file.txt\");\n    // Use the resource\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (fis != null) {\n        try {\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Use buffered streams for performance:</p> </li> <li> <p>Wrap basic streams with buffered streams to reduce system calls    <pre><code>// Better performance with buffering\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n    // Use reader\n}\n</code></pre></p> </li> <li> <p>Choose the right stream type:</p> </li> <li>Use byte streams for binary data (images, audio, etc.)</li> <li> <p>Use character streams for text data to handle character encoding properly</p> </li> <li> <p>Prefer NIO.2 (Java 7+) for file operations:</p> </li> <li>More powerful and expressive API than traditional File class</li> <li> <p>Better exception handling with more specific exceptions</p> </li> <li> <p>Use memory-mapped files for large files:</p> </li> <li>Provides better performance for large files</li> <li> <p>Good for random access patterns</p> </li> <li> <p>Optimize buffer sizes:</p> </li> <li>Default buffer sizes may not be optimal for all scenarios</li> <li>Consider the access pattern and platform when choosing buffer size</li> <li>Too small: too many system calls</li> <li> <p>Too large: wasted memory</p> </li> <li> <p>Handle character encodings explicitly:    <pre><code>// Explicit encoding is better than platform default\nReader reader = new InputStreamReader(new FileInputStream(\"file.txt\"), StandardCharsets.UTF_8);\n</code></pre></p> </li> <li> <p>Use NIO for high-throughput scenarios:</p> </li> <li>Selectors for handling multiple connections with fewer threads</li> <li> <p>Non-blocking I/O for scalable network applications</p> </li> <li> <p>Implement proper serialization controls:</p> </li> <li>Define serialVersionUID for all serializable classes</li> <li>Make sensitive fields transient to avoid serializing them</li> <li> <p>Consider implementing readObject/writeObject for custom serialization</p> </li> <li> <p>Use file locking for concurrent access:     <pre><code>try (FileChannel channel = FileChannel.open(Paths.get(\"file.txt\"), StandardOpenOption.WRITE)) {\n    FileLock lock = channel.lock();\n    try {\n        // Perform operations while locked\n    } finally {\n        lock.release();\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-io/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":"<ol> <li> <p>Resource leaks:    <pre><code>// BAD: Resources not closed properly\nFileInputStream fis = new FileInputStream(\"file.txt\");\n// ... operations without proper closing\n\n// GOOD: try-with-resources ensures closing\ntry (FileInputStream fis = new FileInputStream(\"file.txt\")) {\n    // ... operations\n}\n</code></pre></p> </li> <li> <p>Character encoding issues:    <pre><code>// BAD: Implicitly uses platform default encoding\nFileReader reader = new FileReader(\"file.txt\");\n\n// GOOD: Explicitly specify encoding\nReader reader = new InputStreamReader(new FileInputStream(\"file.txt\"), StandardCharsets.UTF_8);\n</code></pre></p> </li> <li> <p>Ignoring exceptions during closing:    <pre><code>// BAD: Swallowing exceptions\ntry {\n    resource.close();\n} catch (IOException e) {\n    // Empty catch block\n}\n\n// GOOD: At minimum, log the exception\ntry {\n    resource.close();\n} catch (IOException e) {\n    logger.error(\"Error closing resource\", e);\n}\n</code></pre></p> </li> <li> <p>Inefficient reading/writing:    <pre><code>// BAD: Reading one byte at a time\nwhile ((b = inputStream.read()) != -1) {\n    // Process single byte\n}\n\n// GOOD: Use buffer for bulk operations\nbyte[] buffer = new byte[8192];\nint bytesRead;\nwhile ((bytesRead = inputStream.read(buffer)) != -1) {\n    // Process bytesRead bytes from buffer\n}\n</code></pre></p> </li> <li> <p>Accidentally using write() instead of append():    <pre><code>// BAD: Overwrites existing file content\ntry (FileWriter writer = new FileWriter(\"log.txt\")) {\n    writer.write(\"New log entry\");\n}\n\n// GOOD: Appends to existing content\ntry (FileWriter writer = new FileWriter(\"log.txt\", true)) {\n    writer.write(\"New log entry\");\n}\n</code></pre></p> </li> <li> <p>Incorrect buffer handling in NIO:    <pre><code>// BAD: Forgetting to flip buffer before reading\nchannel.read(buffer);\n// Should call buffer.flip() here\nwhile (buffer.hasRemaining()) {\n    // Process buffer content\n}\n\n// GOOD: Proper buffer handling\nchannel.read(buffer);\nbuffer.flip(); // Switch from writing to reading mode\nwhile (buffer.hasRemaining()) {\n    // Process buffer content\n}\nbuffer.clear(); // Reset for next use\n</code></pre></p> </li> <li> <p>Synchronization issues with file access:    <pre><code>// BAD: No synchronization for concurrent access\npublic void writeToLog(String message) {\n    try (FileWriter writer = new FileWriter(\"log.txt\", true)) {\n        writer.write(message + \"\\n\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n// GOOD: Using file locking\npublic void writeToLog(String message) {\n    try (FileChannel channel = FileChannel.open(\n            Paths.get(\"log.txt\"), \n            StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n\n        FileLock lock = channel.lock();\n        try {\n            ByteBuffer buffer = ByteBuffer.wrap((message + \"\\n\").getBytes());\n            channel.write(buffer);\n        } finally {\n            lock.release();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre></p> </li> <li> <p>Incorrect path handling:    <pre><code>// BAD: Platform-dependent path separator\nString filePath = \"directory\" + \"/\" + \"file.txt\";\n\n// GOOD: Using Path.resolve()\nPath filePath = Paths.get(\"directory\").resolve(\"file.txt\");\n</code></pre></p> </li> <li> <p>Not checking file existence before operations:    <pre><code>// BAD: Assuming file exists\nFiles.delete(Paths.get(\"file.txt\")); // May throw NoSuchFileException\n\n// GOOD: Check first or use deleteIfExists\nPath path = Paths.get(\"file.txt\");\nif (Files.exists(path)) {\n    Files.delete(path);\n}\n// OR\nFiles.deleteIfExists(path);\n</code></pre></p> </li> <li> <p>Serialization versioning issues:     <pre><code>// BAD: No serialVersionUID\npublic class Person implements Serializable {\n    private String name;\n    private int age;\n}\n\n// GOOD: With serialVersionUID\npublic class Person implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String name;\n    private int age;\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-io/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>Java I/O Tutorial</li> <li>Java NIO Documentation</li> <li> <p>Java NIO.2 API</p> </li> <li> <p>Books:</p> </li> <li>\"Java NIO\" by Ron Hitchens</li> <li>\"Java I/O, NIO and NIO.2\" by Jeff Friesen</li> <li> <p>\"Effective Java\" by Joshua Bloch (Chapter on Serialization)</p> </li> <li> <p>Online Resources:</p> </li> <li>Baeldung Java I/O Tutorials</li> <li>Java NIO vs IO</li> <li> <p>Java NIO2 Path API</p> </li> <li> <p>Video Courses:</p> </li> <li>\"Java Fundamentals: NIO and NIO.2\" on Pluralsight</li> <li>\"Java I/O Fundamentals\" on LinkedIn Learning</li> </ol>"},{"location":"java/java-io/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>File Copier:    Create a program that copies files from one directory to another, supporting both small text files and large binary files efficiently.</p> </li> <li> <p>Directory Size Calculator:    Implement a utility that calculates the total size of all files in a directory and its subdirectories.</p> </li> <li> <p>CSV Parser:    Build a parser that reads CSV files and converts the data into a list of objects using appropriate I/O techniques.</p> </li> <li> <p>File Search Utility:    Create a file search utility that can find files based on name patterns, content, size, or creation/modification dates.</p> </li> <li> <p>Simple Text Editor:    Implement a basic text editor that can open, edit, and save text files with proper character encoding support.</p> </li> <li> <p>File Compression Tool:    Build a tool that compresses and decompresses files using Java's I/O streams and a compression library.</p> </li> <li> <p>Network File Transfer:    Create a client-server application that allows file transfer over a network using NIO non-blocking I/O.</p> </li> <li> <p>Object Serialization Framework:    Develop a framework that handles automatic serialization and deserialization of complex object graphs.</p> </li> <li> <p>Log File Analyzer:    Build a tool that reads and analyzes log files, extracting statistics and identifying patterns.</p> </li> <li> <p>File Watcher Service:     Implement a service that monitors a directory for file changes and triggers actions when files are created, modified, or deleted. </p> </li> </ol>"},{"location":"java/java-memory-management/","title":"Java Memory Management","text":""},{"location":"java/java-memory-management/#overview","title":"Overview","text":"<p>Java Memory Management is a critical aspect of the Java Virtual Machine (JVM) that handles the allocation and deallocation of memory for Java applications. Unlike languages like C and C++ that require manual memory management, Java provides automatic memory management through garbage collection. Understanding how Java manages memory is essential for developing efficient, high-performance applications, especially for large-scale systems where memory optimization becomes crucial for maintaining responsiveness and minimizing resource consumption.</p>"},{"location":"java/java-memory-management/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Java programming knowledge</li> <li>Understanding of JVM concepts</li> <li>Familiarity with object-oriented programming</li> <li>Basic knowledge of data structures and algorithms</li> </ul>"},{"location":"java/java-memory-management/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the JVM memory architecture</li> <li>Master how Java allocates and deallocates memory</li> <li>Learn about different garbage collection algorithms and strategies</li> <li>Identify common memory leak patterns and their solutions</li> <li>Explore memory monitoring and profiling tools</li> <li>Apply memory optimization techniques in real-world applications</li> <li>Configure JVM parameters for optimal performance</li> <li>Implement best practices for efficient memory management</li> </ul>"},{"location":"java/java-memory-management/#table-of-contents","title":"Table of Contents","text":"<ol> <li>JVM Memory Structure</li> <li>Object Lifecycle</li> <li>Garbage Collection Fundamentals</li> <li>Garbage Collection Algorithms</li> <li>Memory Leaks</li> <li>Monitoring and Profiling Tools</li> <li>JVM Tuning</li> <li>Memory Optimization Techniques</li> <li>Performance Best Practices</li> <li>Special Considerations for Large Applications</li> </ol>"},{"location":"java/java-memory-management/#jvm-memory-structure","title":"JVM Memory Structure","text":"<p>The Java Virtual Machine (JVM) memory structure is divided into several key areas, each with specific purposes and characteristics:</p>"},{"location":"java/java-memory-management/#heap-memory","title":"Heap Memory","text":"<p>The heap is the runtime data area where all objects and arrays are allocated. It is created when the JVM starts and may increase or decrease in size during application execution.</p> <pre><code>JVM Heap Structure (Java 8+):\n+---------------------+\n|      Heap Memory    |\n|                     |\n| +----------------+  |\n| |  Young         |  |\n| |  Generation    |  |\n| | +------------+ |  |\n| | | Eden Space  | |  |\n| | +------------+ |  |\n| | | Survivor   | |  |\n| | | Spaces     | |  |\n| | +------------+ |  |\n| +----------------+  |\n|                     |\n| +----------------+  |\n| |     Old        |  |\n| |  Generation    |  |\n| +----------------+  |\n+---------------------+\n</code></pre>"},{"location":"java/java-memory-management/#young-generation","title":"Young Generation","text":"<ul> <li>Eden Space: Initial allocation of most objects</li> <li>Survivor Spaces: Two spaces (S0 and S1) for objects that survive garbage collections</li> <li>Objects are promoted from Young to Old generation after surviving a threshold number of GC cycles</li> </ul>"},{"location":"java/java-memory-management/#old-generation","title":"Old Generation","text":"<ul> <li>Contains objects that have persisted for longer periods</li> <li>Subject to less frequent but more thorough garbage collections</li> </ul>"},{"location":"java/java-memory-management/#non-heap-memory","title":"Non-Heap Memory","text":""},{"location":"java/java-memory-management/#stack-memory","title":"Stack Memory","text":"<p>Each thread has its own stack, which contains method-specific values and references to objects: - Local variables - Method parameters - Method call and return information - Object references</p> <pre><code>public void methodA() {\n    int localVar = 42;        // Stored on stack\n    Object obj = new Object(); // Reference on stack, actual object on heap\n    methodB(localVar);        // Call information on stack\n}\n</code></pre>"},{"location":"java/java-memory-management/#metaspace-java-8","title":"Metaspace (Java 8+)","text":"<p>Replaced PermGen in Java 8 and stores class metadata: - Class definitions - Method bytecode - Static variables - Method tables - Interned strings (in Java 7+)</p>"},{"location":"java/java-memory-management/#code-cache","title":"Code Cache","text":"<p>Stores compiled native code generated by the Just-In-Time (JIT) compiler.</p>"},{"location":"java/java-memory-management/#direct-memory","title":"Direct Memory","text":"<p>Memory allocated outside the JVM heap, commonly used for native I/O operations.</p>"},{"location":"java/java-memory-management/#object-lifecycle","title":"Object Lifecycle","text":"<p>Understanding an object's lifecycle in Java is crucial for efficient memory management:</p>"},{"location":"java/java-memory-management/#1-object-creation","title":"1. Object Creation","text":"<p>When an object is created with the <code>new</code> keyword, the JVM: 1. Allocates memory for the object (usually in Eden space) 2. Initializes instance variables to default values 3. Invokes constructors</p> <pre><code>// Memory allocation and initialization\nPerson person = new Person(\"John\", 30);\n</code></pre>"},{"location":"java/java-memory-management/#2-object-usage","title":"2. Object Usage","text":"<p>The object remains in memory as long as it's reachable - meaning there's a chain of references from a GC root (like a static field, local variable in an active thread, or JNI reference).</p> <pre><code>// Object is reachable through the 'person' reference\nperson.setAge(31);\nSystem.out.println(person.getName());\n</code></pre>"},{"location":"java/java-memory-management/#3-object-death","title":"3. Object Death","text":"<p>An object becomes eligible for garbage collection when it's no longer reachable from any GC roots.</p> <pre><code>// Object becomes unreachable and eligible for GC\nperson = null;  // Removing the reference\n// or when 'person' goes out of scope\n</code></pre>"},{"location":"java/java-memory-management/#4-finalization","title":"4. Finalization","text":"<p>Before reclaiming memory, the JVM may call the object's <code>finalize()</code> method (though this is not guaranteed and generally discouraged in modern Java).</p>"},{"location":"java/java-memory-management/#5-memory-reclamation","title":"5. Memory Reclamation","text":"<p>Garbage collection reclaims the memory, making it available for future allocations.</p>"},{"location":"java/java-memory-management/#garbage-collection-fundamentals","title":"Garbage Collection Fundamentals","text":"<p>Garbage Collection (GC) is the process of automatically reclaiming memory occupied by unused objects.</p>"},{"location":"java/java-memory-management/#core-principles","title":"Core Principles","text":"<ol> <li>Identify live objects: Find all objects reachable from GC roots</li> <li>Remove dead objects: Reclaim memory from unreachable objects</li> </ol>"},{"location":"java/java-memory-management/#gc-roots","title":"GC Roots","text":"<p>Objects that serve as starting points for the garbage collector's reachability analysis: - Local variables in the stack of any thread - Active Java threads - Static variables - JNI references - References from the JVM for class loading and reflection</p>"},{"location":"java/java-memory-management/#gc-process-steps","title":"GC Process Steps","text":"<ol> <li>Marking: Identifies and marks all reachable objects</li> <li>Sweeping/Compacting: Reclaims memory from unreachable objects and potentially rearranges memory</li> </ol>"},{"location":"java/java-memory-management/#stop-the-world-pauses","title":"Stop-the-World Pauses","text":"<p>During certain phases of garbage collection, the JVM suspends all application threads, causing application pauses. These are called \"Stop-the-World\" (STW) events.</p>"},{"location":"java/java-memory-management/#generational-hypothesis","title":"Generational Hypothesis","text":"<p>Java's GC is designed based on the empirical observation that most objects die young. This leads to the generational design with more frequent collections of younger objects.</p>"},{"location":"java/java-memory-management/#garbage-collection-algorithms","title":"Garbage Collection Algorithms","text":"<p>The JVM offers several garbage collection algorithms, each with specific strengths and trade-offs:</p>"},{"location":"java/java-memory-management/#serial-collector","title":"Serial Collector","text":"<ul> <li>Single-threaded collector</li> <li>Simple and with low overhead</li> <li>Suitable for small applications or single-processor environments</li> <li>Activated with <code>-XX:+UseSerialGC</code></li> </ul>"},{"location":"java/java-memory-management/#parallel-collector","title":"Parallel Collector","text":"<ul> <li>Uses multiple threads for GC operations</li> <li>Faster than Serial for multi-processor systems</li> <li>Still causes stop-the-world pauses</li> <li>Focused on throughput rather than latency</li> <li>Activated with <code>-XX:+UseParallelGC</code></li> </ul>"},{"location":"java/java-memory-management/#concurrent-mark-sweep-cms-collector","title":"Concurrent Mark Sweep (CMS) Collector","text":"<ul> <li>Minimizes pause times by doing most work concurrently with application threads</li> <li>Higher CPU utilization</li> <li>Complex and can suffer from fragmentation</li> <li>Good for applications requiring low latency</li> <li>Activated with <code>-XX:+UseConcMarkSweepGC</code> (deprecated in Java 9+)</li> </ul>"},{"location":"java/java-memory-management/#garbage-first-g1-collector","title":"Garbage-First (G1) Collector","text":"<ul> <li>Default collector since Java 9</li> <li>Divides the heap into regions for more efficient collection</li> <li>Aims to meet a user-defined pause time goal</li> <li>Balances throughput and latency</li> <li>Activated with <code>-XX:+UseG1GC</code></li> </ul>"},{"location":"java/java-memory-management/#z-garbage-collector-zgc","title":"Z Garbage Collector (ZGC)","text":"<ul> <li>Low-latency collector introduced in Java 11</li> <li>Designed for applications requiring low pause times (&lt; 10ms)</li> <li>Scales well with increasing heap sizes</li> <li>Activated with <code>-XX:+UseZGC</code></li> </ul>"},{"location":"java/java-memory-management/#shenandoah-collector","title":"Shenandoah Collector","text":"<ul> <li>Low-pause collector with concurrent compaction</li> <li>Similar goals to ZGC but with different implementation</li> <li>Activated with <code>-XX:+UseShenandoahGC</code></li> </ul>"},{"location":"java/java-memory-management/#comparison-table","title":"Comparison Table","text":"Collector Pause Time Throughput Memory Overhead Heap Size Serial High Low Low Small Parallel Medium High Low Medium CMS Low Medium High Medium G1 Low Medium Medium Large ZGC Very Low Medium High Very Large Shenandoah Very Low Medium High Very Large"},{"location":"java/java-memory-management/#memory-leaks","title":"Memory Leaks","text":"<p>Even though Java has automatic garbage collection, memory leaks can still occur when objects remain referenced but aren't actually needed.</p>"},{"location":"java/java-memory-management/#common-causes-of-memory-leaks","title":"Common Causes of Memory Leaks","text":""},{"location":"java/java-memory-management/#1-unclosed-resources","title":"1. Unclosed Resources","text":"<pre><code>public void processFile(String path) throws IOException {\n    // LEAK: FileInputStream is never closed\n    FileInputStream fis = new FileInputStream(path);\n    // process file...\n\n    // FIX: use try-with-resources\n    try (FileInputStream fis2 = new FileInputStream(path)) {\n        // process file...\n    }\n}\n</code></pre>"},{"location":"java/java-memory-management/#2-static-collections","title":"2. Static Collections","text":"<pre><code>// LEAK: Static collection that grows unbounded\npublic class Cache {\n    private static final Map&lt;String, Data&gt; cache = new HashMap&lt;&gt;();\n\n    public static void store(String key, Data data) {\n        cache.put(key, data);  // Objects are never removed\n    }\n\n    // FIX: Use WeakHashMap or implement explicit cleanup\n    private static final Map&lt;String, Data&gt; betterCache = \n        Collections.synchronizedMap(new WeakHashMap&lt;&gt;());\n}\n</code></pre>"},{"location":"java/java-memory-management/#3-improper-equalshashcode-implementation","title":"3. Improper equals/hashCode Implementation","text":"<pre><code>// LEAK: Objects with changing hash codes in HashMaps\npublic class MutableKey {\n    private int id;\n\n    // PROBLEM: hashCode depends on mutable field\n    @Override\n    public int hashCode() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;  // Changes hash code\n    }\n\n    // FIX: Use immutable fields for hash code or don't use as keys\n}\n</code></pre>"},{"location":"java/java-memory-management/#4-inner-class-references","title":"4. Inner Class References","text":"<pre><code>// LEAK: Non-static inner class holds implicit reference to outer instance\npublic class Outer {\n    private byte[] largeArray = new byte[1000000];\n\n    public Object getInnerInstance() {\n        // Inner instance holds reference to Outer\n        return new Inner();\n    }\n\n    private class Inner {}\n\n    // FIX: Make inner class static to avoid reference to outer\n    private static class StaticInner {}\n}\n</code></pre>"},{"location":"java/java-memory-management/#5-thread-local-variables","title":"5. Thread Local Variables","text":"<pre><code>// LEAK: ThreadLocal variables not removed\nprivate static ThreadLocal&lt;LargeObject&gt; threadLocal = new ThreadLocal&lt;&gt;();\n\npublic void process() {\n    threadLocal.set(new LargeObject());\n    // process...\n    // MISSING: threadLocal.remove();  \n}\n\n// FIX: Always call remove() when done with ThreadLocal\n</code></pre>"},{"location":"java/java-memory-management/#detecting-memory-leaks","title":"Detecting Memory Leaks","text":"<ol> <li>Monitoring heap usage over time</li> <li>Taking heap dumps with tools like jmap, VisualVM, or JConsole</li> <li>Analyzing heap dumps with tools like Eclipse Memory Analyzer (MAT)</li> <li>Watching for symptoms like OutOfMemoryError, increasing GC time, or degrading performance</li> </ol>"},{"location":"java/java-memory-management/#heap-dump-analysis-example","title":"Heap Dump Analysis Example","text":"<ol> <li>Take a heap dump: <code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code></li> <li>Analyze with Eclipse MAT:</li> <li>Look for dominator objects</li> <li>Check for large collections</li> <li>Analyze retained heap size</li> <li>Investigate suspicious reference paths</li> </ol>"},{"location":"java/java-memory-management/#monitoring-and-profiling-tools","title":"Monitoring and Profiling Tools","text":""},{"location":"java/java-memory-management/#command-line-tools","title":"Command-Line Tools","text":""},{"location":"java/java-memory-management/#jstat","title":"jstat","text":"<p>Monitors JVM statistics: <pre><code>jstat -gc &lt;pid&gt; 1000 10  # GC stats every 1 second, 10 times\n</code></pre></p>"},{"location":"java/java-memory-management/#jmap","title":"jmap","text":"<p>Takes heap dumps and shows memory statistics: <pre><code>jmap -heap &lt;pid&gt;  # Show heap summary\njmap -dump:format=b,file=heap.hprof &lt;pid&gt;  # Create heap dump\n</code></pre></p>"},{"location":"java/java-memory-management/#jstack","title":"jstack","text":"<p>Prints thread stack traces: <pre><code>jstack &lt;pid&gt;  # Get thread dump\n</code></pre></p>"},{"location":"java/java-memory-management/#jcmd","title":"jcmd","text":"<p>Diagnostic tool with multiple functions: <pre><code>jcmd &lt;pid&gt; GC.heap_info  # Heap information\njcmd &lt;pid&gt; Thread.print   # Thread dump\njcmd &lt;pid&gt; GC.class_histogram  # Class histogram\n</code></pre></p>"},{"location":"java/java-memory-management/#visual-tools","title":"Visual Tools","text":""},{"location":"java/java-memory-management/#java-mission-control-jmc-flight-recorder-jfr","title":"Java Mission Control (JMC) &amp; Flight Recorder (JFR)","text":"<p>Provides low-overhead profiling of CPU, memory, and more: <pre><code># Start recording\njcmd &lt;pid&gt; JFR.start settings=profile duration=60s filename=recording.jfr\n</code></pre></p>"},{"location":"java/java-memory-management/#visualvm","title":"VisualVM","text":"<p>All-in-one monitoring and profiling tool with plugins: - CPU profiling - Memory profiling - Thread monitoring - Heap dumps</p>"},{"location":"java/java-memory-management/#eclipse-memory-analyzer-mat","title":"Eclipse Memory Analyzer (MAT)","text":"<p>Specialized tool for heap dump analysis: - Memory leak detection - Object retention analysis - Comparison of multiple heap dumps</p>"},{"location":"java/java-memory-management/#yourkit-java-profiler","title":"YourKit Java Profiler","text":"<p>Commercial profiler with advanced features: - CPU profiling - Memory profiling - Thread profiling - SQL query analysis</p>"},{"location":"java/java-memory-management/#async-profiler","title":"Async Profiler","text":"<p>Low-overhead sampling profiler: <pre><code>./profiler.sh -d 30 -f profile.html &lt;pid&gt;  # 30 second CPU profile\n</code></pre></p>"},{"location":"java/java-memory-management/#metrics-and-apm-systems","title":"Metrics and APM Systems","text":"<ul> <li>JMX: Java Management Extensions for exposing metrics</li> <li>Micrometer: Application metrics facade</li> <li>Prometheus + Grafana: Metrics collection and visualization</li> <li>New Relic/Dynatrace/AppDynamics: Commercial APM solutions</li> </ul>"},{"location":"java/java-memory-management/#jvm-tuning","title":"JVM Tuning","text":""},{"location":"java/java-memory-management/#heap-size-configuration","title":"Heap Size Configuration","text":"<pre><code># Set initial and maximum heap size\njava -Xms2g -Xmx8g -jar application.jar\n\n# Set survivor ratio\njava -XX:SurvivorRatio=8 -jar application.jar\n\n# Set young generation size\njava -Xmn1g -jar application.jar\n</code></pre>"},{"location":"java/java-memory-management/#garbage-collector-selection","title":"Garbage Collector Selection","text":"<pre><code># Use G1GC (default in Java 9+)\njava -XX:+UseG1GC -jar application.jar\n\n# Use ZGC for ultra-low latency\njava -XX:+UseZGC -jar application.jar\n</code></pre>"},{"location":"java/java-memory-management/#gc-tuning-parameters","title":"GC Tuning Parameters","text":"<pre><code># G1GC pause time goal (milliseconds)\njava -XX:MaxGCPauseMillis=200 -jar application.jar\n\n# Percentage of heap to use for young generation\njava -XX:NewRatio=2 -jar application.jar  # 1:2 young:old\n\n# CMS initiating occupancy fraction\njava -XX:CMSInitiatingOccupancyFraction=70 -jar application.jar\n</code></pre>"},{"location":"java/java-memory-management/#memory-related-flags","title":"Memory-Related Flags","text":"<pre><code># Print GC details\njava -XX:+PrintGCDetails -jar application.jar\n\n# Print GC timestamps\njava -XX:+PrintGCDateStamps -jar application.jar\n\n# Log GC to file (Java 9+)\njava -Xlog:gc*:file=gc.log:time,uptime:filecount=5,filesize=10m -jar application.jar\n\n# Metaspace size\njava -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m -jar application.jar\n</code></pre>"},{"location":"java/java-memory-management/#stack-size-configuration","title":"Stack Size Configuration","text":"<pre><code># Set thread stack size\njava -Xss256k -jar application.jar\n</code></pre>"},{"location":"java/java-memory-management/#common-jvm-tuning-scenarios","title":"Common JVM Tuning Scenarios","text":""},{"location":"java/java-memory-management/#high-throughput-batch-processing","title":"High-Throughput Batch Processing","text":"<pre><code>java -Xms4g -Xmx4g -XX:+UseParallelGC -XX:ParallelGCThreads=8 -jar batch.jar\n</code></pre>"},{"location":"java/java-memory-management/#low-latency-web-application","title":"Low-Latency Web Application","text":"<pre><code>java -Xms2g -Xmx2g -XX:+UseG1GC -XX:MaxGCPauseMillis=50 -jar webapp.jar\n</code></pre>"},{"location":"java/java-memory-management/#large-in-memory-database","title":"Large In-Memory Database","text":"<pre><code>java -Xms16g -Xmx16g -XX:+UseG1GC -XX:G1HeapRegionSize=16m -jar database.jar\n</code></pre>"},{"location":"java/java-memory-management/#memory-optimization-techniques","title":"Memory Optimization Techniques","text":""},{"location":"java/java-memory-management/#object-pooling","title":"Object Pooling","text":"<p>For expensive-to-create or frequently used objects:</p> <pre><code>public class ConnectionPool {\n    private final BlockingQueue&lt;Connection&gt; pool;\n\n    public ConnectionPool(int size) {\n        pool = new ArrayBlockingQueue&lt;&gt;(size);\n        for (int i = 0; i &lt; size; i++) {\n            pool.add(createConnection());\n        }\n    }\n\n    public Connection getConnection() throws InterruptedException {\n        return pool.take();\n    }\n\n    public void releaseConnection(Connection conn) {\n        pool.offer(conn);\n    }\n\n    private Connection createConnection() {\n        // Create and return a new database connection\n    }\n}\n</code></pre>"},{"location":"java/java-memory-management/#lazy-initialization","title":"Lazy Initialization","text":"<p>Defer object creation until needed:</p> <pre><code>public class ExpensiveResource {\n    private static class Holder {\n        static final ExpensiveResource INSTANCE = new ExpensiveResource();\n    }\n\n    // Lazy initialization using class holder pattern\n    public static ExpensiveResource getInstance() {\n        return Holder.INSTANCE;\n    }\n}\n</code></pre>"},{"location":"java/java-memory-management/#caching","title":"Caching","text":"<p>Store results of expensive operations:</p> <pre><code>public class DataService {\n    private final Map&lt;String, Data&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\n    public Data getData(String key) {\n        // Check cache first\n        return cache.computeIfAbsent(key, this::loadData);\n    }\n\n    private Data loadData(String key) {\n        // Expensive operation to load data\n    }\n}\n</code></pre>"},{"location":"java/java-memory-management/#reducing-object-size","title":"Reducing Object Size","text":"<p>Minimize the memory footprint of frequently instantiated objects:</p> <pre><code>// BEFORE: 32+ bytes per instance (header + 3 refs + padding)\nclass Customer {\n    private String firstName;\n    private String lastName;\n    private String email;\n}\n\n// AFTER: Combine related data into a single object\nclass CustomerInfo {\n    private final String[] data; // firstName, lastName, email\n\n    public CustomerInfo(String firstName, String lastName, String email) {\n        this.data = new String[]{firstName, lastName, email};\n    }\n\n    public String getFirstName() { return data[0]; }\n    public String getLastName() { return data[1]; }\n    public String getEmail() { return data[2]; }\n}\n</code></pre>"},{"location":"java/java-memory-management/#using-primitive-arrays","title":"Using Primitive Arrays","text":"<p>Prefer primitive arrays over collections for large datasets:</p> <pre><code>// Less memory efficient\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;(1000000);\nfor (int i = 0; i &lt; 1000000; i++) {\n    list.add(i);  // Autoboxing to Integer objects\n}\n\n// More memory efficient\nint[] array = new int[1000000];\nfor (int i = 0; i &lt; 1000000; i++) {\n    array[i] = i;  // No boxing, just primitives\n}\n</code></pre>"},{"location":"java/java-memory-management/#flyweight-pattern","title":"Flyweight Pattern","text":"<p>Share common parts of objects:</p> <pre><code>public class CharacterFactory {\n    private static final Character[] cache = new Character[128];\n\n    static {\n        for (int i = 0; i &lt; cache.length; i++) {\n            cache[i] = new Character((char) i);\n        }\n    }\n\n    public static Character getCharacter(char c) {\n        if (c &lt; 128) {\n            return cache[c];\n        } else {\n            return new Character(c);\n        }\n    }\n\n    public static class Character {\n        private final char value;\n\n        private Character(char value) {\n            this.value = value;\n        }\n\n        public char getValue() {\n            return value;\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-memory-management/#string-interning","title":"String Interning","text":"<p>Use string interning for frequently used strings:</p> <pre><code>String s1 = new String(\"hello\").intern();\nString s2 = \"hello\";\nSystem.out.println(s1 == s2);  // true, same reference\n</code></pre>"},{"location":"java/java-memory-management/#softweak-references","title":"Soft/Weak References","text":"<p>Use for caching that adjusts to memory pressure:</p> <pre><code>public class SoftCache&lt;K, V&gt; {\n    private final Map&lt;K, SoftReference&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\n    public V get(K key) {\n        SoftReference&lt;V&gt; ref = cache.get(key);\n        if (ref != null) {\n            V value = ref.get();\n            if (value != null) {\n                return value;\n            } else {\n                // Value was garbage collected\n                cache.remove(key);\n            }\n        }\n        return null;\n    }\n\n    public void put(K key, V value) {\n        cache.put(key, new SoftReference&lt;&gt;(value));\n    }\n}\n</code></pre>"},{"location":"java/java-memory-management/#off-heap-storage","title":"Off-Heap Storage","text":"<p>For very large data sets that exceed heap capacity:</p> <pre><code>// Using ByteBuffer for direct (off-heap) memory\nByteBuffer buffer = ByteBuffer.allocateDirect(1024 * 1024 * 1024); // 1GB\n\n// Write data\nbuffer.putInt(0, 42);\n\n// Read data\nint value = buffer.getInt(0);\n</code></pre>"},{"location":"java/java-memory-management/#performance-best-practices","title":"Performance Best Practices","text":""},{"location":"java/java-memory-management/#memory-allocation","title":"Memory Allocation","text":"<ol> <li> <p>Minimize object creation in critical paths:    <pre><code>// Inefficient: creates objects in a loop\nfor (int i = 0; i &lt; 1000000; i++) {\n    String s = \"Value: \" + i;  // Creates new String each iteration\n    process(s);\n}\n\n// Better: reuse objects\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i &lt; 1000000; i++) {\n    sb.setLength(0);\n    sb.append(\"Value: \").append(i);\n    process(sb.toString());\n}\n</code></pre></p> </li> <li> <p>Prefer bulk operations:    <pre><code>// Less efficient: individual adds\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nfor (String item : items) {\n    list.add(item);\n}\n\n// More efficient: bulk operation\nList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(items));\n</code></pre></p> </li> <li> <p>Pre-size collections:    <pre><code>// Without pre-sizing: multiple resizing operations\nMap&lt;String, User&gt; users = new HashMap&lt;&gt;();  // Default initial capacity\n\n// With pre-sizing: avoids resizing\nMap&lt;String, User&gt; users = new HashMap&lt;&gt;(expectedSize);\n</code></pre></p> </li> <li> <p>Consider object allocation rate:</p> </li> <li>High allocation rates trigger more frequent GC</li> <li>Reduce temporary object creation</li> <li>Use object pooling for expensive objects</li> </ol>"},{"location":"java/java-memory-management/#collection-efficiency","title":"Collection Efficiency","text":"<ol> <li>Choose the right collection:</li> <li><code>ArrayList</code> for random access</li> <li><code>LinkedList</code> for frequent insertions/deletions</li> <li><code>HashSet</code> for fast membership testing</li> <li> <p><code>EnumSet</code> for enum-based sets (very memory efficient)</p> </li> <li> <p>Use specialized collections for primitives:    <pre><code>// Standard collection with boxing overhead\nList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();\n\n// Specialized primitive collection (e.g., with Trove or Fastutil)\nTIntList numbers = new TIntArrayList();\n</code></pre></p> </li> <li> <p>Clear collections proactively:    <pre><code>// Help GC by clearing when done\nlargeTemporaryList.clear();\n</code></pre></p> </li> </ol>"},{"location":"java/java-memory-management/#resource-management","title":"Resource Management","text":"<ol> <li> <p>Always close resources:    <pre><code>// Using try-with-resources\ntry (InputStream in = new FileInputStream(file);\n     OutputStream out = new FileOutputStream(output)) {\n    // Use resources\n}\n</code></pre></p> </li> <li> <p>Dispose of native resources explicitly:    <pre><code>// Native resource releasing\nBufferedImage image = createLargeImage();\n// Use image...\nimage.flush();  // Release native resources\n</code></pre></p> </li> <li> <p>Manage thread lifecycle:</p> </li> <li>Shut down thread pools when no longer needed</li> <li>Use daemon threads for background services</li> <li>Prefer higher-level abstractions like ExecutorService</li> </ol>"},{"location":"java/java-memory-management/#efficient-string-handling","title":"Efficient String Handling","text":"<ol> <li> <p>Use StringBuilder for concatenation:    <pre><code>// Inefficient: creates multiple temporary strings\nString result = \"\";\nfor (int i = 0; i &lt; 100; i++) {\n    result += i;\n}\n\n// Efficient: reuses the same buffer\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i &lt; 100; i++) {\n    sb.append(i);\n}\nString result = sb.toString();\n</code></pre></p> </li> <li> <p>Avoid unnecessary string conversions:    <pre><code>// Inefficient: unnecessary conversion\nif (string.toString().equals(\"value\")) { ... }\n\n// Efficient: direct comparison\nif (string.equals(\"value\")) { ... }\n</code></pre></p> </li> </ol>"},{"location":"java/java-memory-management/#memory-conscious-algorithms","title":"Memory-Conscious Algorithms","text":"<ol> <li> <p>Streaming for large datasets:    <pre><code>// Memory intensive: loads all data at once\nList&lt;Record&gt; records = loadAllRecords();\nList&lt;Result&gt; results = process(records);\n\n// Memory efficient: processes one record at a time\ntry (Stream&lt;Record&gt; recordStream = streamRecords()) {\n    return recordStream\n        .map(this::processRecord)\n        .collect(Collectors.toList());\n}\n</code></pre></p> </li> <li> <p>Pagination for large result sets:    <pre><code>// Instead of fetching all records at once\nList&lt;Record&gt; records = repository.findAllByUserId(userId);\n\n// Use pagination\nPage&lt;Record&gt; page = repository.findByUserId(userId, PageRequest.of(0, 100));\n</code></pre></p> </li> <li> <p>In-place modifications:    <pre><code>// Sorts in place without creating new arrays\nArrays.sort(data);\n\n// In-place collection operations\nCollections.sort(list);\n</code></pre></p> </li> </ol>"},{"location":"java/java-memory-management/#special-considerations-for-large-applications","title":"Special Considerations for Large Applications","text":""},{"location":"java/java-memory-management/#managing-large-heaps","title":"Managing Large Heaps","text":"<ol> <li>Heap size considerations:</li> <li>Larger heaps allow more caching and reduce GC frequency</li> <li>But increase GC pause duration (except with ZGC/Shenandoah)</li> <li> <p>Find balance between throughput and latency requirements</p> </li> <li> <p>Tuning for large heaps:    <pre><code># G1GC for large heaps\njava -Xms10g -Xmx10g -XX:+UseG1GC -XX:G1HeapRegionSize=32m -jar app.jar\n\n# ZGC for large heaps with low latency\njava -Xms20g -Xmx20g -XX:+UseZGC -XX:ZAllocationSpikeTolerance=2.0 -jar app.jar\n</code></pre></p> </li> <li> <p>Distributed caching:</p> </li> <li>Use external caching systems like Redis or Memcached</li> <li>Offload memory pressure from the JVM heap</li> </ol>"},{"location":"java/java-memory-management/#multi-tenant-applications","title":"Multi-Tenant Applications","text":"<ol> <li>Isolation strategies:</li> <li>Separate classloaders per tenant</li> <li>Tenant-specific thread pools</li> <li> <p>Memory quotas per tenant</p> </li> <li> <p>Resource monitoring:</p> </li> <li>Track memory usage per tenant</li> <li>Implement circuit breakers for runaway tenants</li> </ol>"},{"location":"java/java-memory-management/#memory-usage-in-frameworks","title":"Memory Usage in Frameworks","text":"<ol> <li>Web frameworks:</li> <li>Session size limitations</li> <li>Request/response buffering strategies</li> <li> <p>Connection pooling configuration</p> </li> <li> <p>ORM frameworks:</p> </li> <li>Entity caching configuration</li> <li>Batch processing for large datasets</li> <li> <p>Lazy loading vs eager fetching</p> </li> <li> <p>Message brokers:</p> </li> <li>Consumer prefetch settings</li> <li>Producer buffering configuration</li> <li>Dead letter handling</li> </ol>"},{"location":"java/java-memory-management/#containerized-applications","title":"Containerized Applications","text":"<ol> <li> <p>Container memory limits:    <pre><code># Set JVM to use container memory limits (Java 11+)\njava -XX:+UseContainerSupport -jar app.jar\n</code></pre></p> </li> <li> <p>Memory reservation strategies:</p> </li> <li>Reserve memory for non-heap usages</li> <li>Account for off-heap memory usage</li> <li> <p>Reserve memory for native code</p> </li> <li> <p>Kubernetes considerations:    <pre><code>resources:\n  requests:\n    memory: \"1Gi\"\n  limits:\n    memory: \"2Gi\"\n</code></pre></p> </li> </ol>"},{"location":"java/java-memory-management/#best-practices-and-common-pitfalls","title":"Best Practices and Common Pitfalls","text":""},{"location":"java/java-memory-management/#memory-management-best-practices","title":"Memory Management Best Practices","text":"<ol> <li>Design for predictable memory usage:</li> <li>Understand your application's memory profile</li> <li>Set upper bounds on caches and collections</li> <li> <p>Design data structures with memory efficiency in mind</p> </li> <li> <p>Regular monitoring and profiling:</p> </li> <li>Implement memory usage monitoring</li> <li>Schedule periodic profiling</li> <li> <p>Establish baselines and alert on deviations</p> </li> <li> <p>Preemptive memory leak detection:</p> </li> <li>Code reviews focused on potential leaks</li> <li>Memory leak detection in testing environments</li> <li> <p>Historical trend analysis of memory usage</p> </li> <li> <p>Documentation and knowledge sharing:</p> </li> <li>Document memory tuning parameters</li> <li>Share memory optimization techniques</li> <li>Create run books for memory-related incidents</li> </ol>"},{"location":"java/java-memory-management/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ol> <li>Premature optimization:</li> <li>Focus on the areas with proven memory issues</li> <li>Measure before and after optimization</li> <li> <p>Balance code readability with optimization</p> </li> <li> <p>Excessive tuning:</p> </li> <li>Too many JVM flags can cause unpredictable behavior</li> <li>Tune important parameters first, then refine</li> <li> <p>Document reasons for each tuning parameter</p> </li> <li> <p>Ignoring non-heap memory:</p> </li> <li>DirectBuffer allocation</li> <li>Native library memory usage</li> <li> <p>Memory-mapped files</p> </li> <li> <p>One-size-fits-all solutions:</p> </li> <li>GC tuning is workload-dependent</li> <li>Development vs. production settings may differ</li> <li> <p>Different applications have different memory profiles</p> </li> <li> <p>Missing holistic view:</p> </li> <li>Memory is just one system resource</li> <li>Consider interaction with CPU, disk, network, etc.</li> <li>Look at end-to-end system performance</li> </ol>"},{"location":"java/java-memory-management/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>JVM Guide</li> <li>Memory Management Whitepaper</li> <li> <p>JDK Tools Reference</p> </li> <li> <p>Books:</p> </li> <li>\"Java Performance: The Definitive Guide\" by Scott Oaks</li> <li>\"Optimizing Java\" by Benjamin Evans, James Gough, and Chris Newland</li> <li> <p>\"Java Performance Companion\" by Charlie Hunt et al.</p> </li> <li> <p>Online Resources:</p> </li> <li>GC Handbook</li> <li>Baeldung Memory Management Articles</li> <li> <p>Java Performance Tuning</p> </li> <li> <p>Tools Documentation:</p> </li> <li>Eclipse Memory Analyzer</li> <li>Java Mission Control</li> <li>VisualVM Documentation</li> </ol>"},{"location":"java/java-memory-management/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>Memory Leak Detection:    Create a program with a deliberate memory leak, then use profiling tools to detect and fix it.</p> </li> <li> <p>GC Tuning Comparison:    Experiment with different GC algorithms and settings for a simple benchmark application.</p> </li> <li> <p>Memory Footprint Optimization:    Optimize a data structure for memory efficiency while maintaining performance.</p> </li> <li> <p>Heap Dump Analysis:    Analyze a provided heap dump to identify memory usage patterns and potential issues.</p> </li> <li> <p>Off-Heap Storage Implementation:    Design a cache that uses direct ByteBuffers for large data storage.</p> </li> <li> <p>Resource Pool Implementation:    Create a reusable resource pool with configurable capacity and timeout handling.</p> </li> <li> <p>Memory Monitoring Dashboard:    Set up a Prometheus/Grafana dashboard for JVM memory metrics.</p> </li> <li> <p>Cache Eviction Strategies:    Implement and compare different cache eviction policies (LRU, LFU, time-based).</p> </li> <li> <p>Large Dataset Processing:    Implement memory-efficient processing of a large dataset using streams and pagination.</p> </li> <li> <p>Container Memory Optimization:     Configure a Spring Boot application for optimal memory usage in a container environment. </p> </li> </ol>"},{"location":"java/java-multithreading/","title":"Java Multithreading","text":""},{"location":"java/java-multithreading/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Multithreading</li> <li>Thread Creation and Management</li> <li>Thread Synchronization</li> <li>Thread Communication</li> <li>Concurrent Collections</li> <li>Thread Pools and Executors</li> <li>Best Practices</li> </ol>"},{"location":"java/java-multithreading/#introduction","title":"Introduction","text":"<p>Multithreading in Java allows concurrent execution of two or more parts of a program for maximum utilization of CPU.</p>"},{"location":"java/java-multithreading/#benefits-of-multithreading","title":"Benefits of Multithreading","text":"<ul> <li>Better resource utilization</li> <li>Enhanced performance</li> <li>Improved responsiveness</li> <li>Ability to perform multiple tasks simultaneously</li> </ul>"},{"location":"java/java-multithreading/#thread-creation","title":"Thread Creation","text":""},{"location":"java/java-multithreading/#1-extending-thread-class","title":"1. Extending Thread Class","text":"<pre><code>public class ThreadExample extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running: \" + Thread.currentThread().getName());\n    }\n\n    public static void main(String[] args) {\n        ThreadExample thread = new ThreadExample();\n        thread.start();\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#2-implementing-runnable-interface","title":"2. Implementing Runnable Interface","text":"<pre><code>public class RunnableExample implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running: \" + Thread.currentThread().getName());\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new RunnableExample());\n        thread.start();\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#3-using-lambda-expressions","title":"3. Using Lambda Expressions","text":"<pre><code>public class LambdaThreadExample {\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -&gt; {\n            System.out.println(\"Thread running: \" + Thread.currentThread().getName());\n        });\n        thread.start();\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#thread-synchronization","title":"Thread Synchronization","text":""},{"location":"java/java-multithreading/#1-synchronized-methods","title":"1. Synchronized Methods","text":"<pre><code>public class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized void decrement() {\n        count--;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#2-synchronized-blocks","title":"2. Synchronized Blocks","text":"<pre><code>public class SynchronizedBlockExample {\n    private List&lt;String&gt; items = new ArrayList&lt;&gt;();\n    private final Object lock = new Object();\n\n    public void addItem(String item) {\n        synchronized(lock) {\n            items.add(item);\n        }\n    }\n\n    public void removeItem(String item) {\n        synchronized(lock) {\n            items.remove(item);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#3-lock-interface","title":"3. Lock Interface","text":"<pre><code>public class LockExample {\n    private final ReentrantLock lock = new ReentrantLock();\n    private int count = 0;\n\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int getCount() {\n        lock.lock();\n        try {\n            return count;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#thread-communication","title":"Thread Communication","text":""},{"location":"java/java-multithreading/#1-wait-and-notify","title":"1. wait() and notify()","text":"<pre><code>public class ProducerConsumer {\n    private Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n    private final int CAPACITY = 10;\n\n    public synchronized void produce(int item) throws InterruptedException {\n        while (queue.size() == CAPACITY) {\n            wait();\n        }\n        queue.add(item);\n        notify();\n    }\n\n    public synchronized int consume() throws InterruptedException {\n        while (queue.isEmpty()) {\n            wait();\n        }\n        int item = queue.remove();\n        notify();\n        return item;\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#2-countdownlatch","title":"2. CountDownLatch","text":"<pre><code>public class CountDownLatchExample {\n    public void executeParallelTasks() {\n        CountDownLatch latch = new CountDownLatch(3);\n\n        // Start multiple threads\n        new Thread(() -&gt; {\n            performTask();\n            latch.countDown();\n        }).start();\n\n        // Wait for all threads to complete\n        try {\n            latch.await();\n            System.out.println(\"All tasks completed\");\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#3-cyclicbarrier","title":"3. CyclicBarrier","text":"<pre><code>public class CyclicBarrierExample {\n    private CyclicBarrier barrier = new CyclicBarrier(3, () -&gt; {\n        System.out.println(\"All threads reached barrier\");\n    });\n\n    public void executeTask() {\n        try {\n            // Perform task\n            barrier.await();\n            // Continue after all threads reach barrier\n        } catch (InterruptedException | BrokenBarrierException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#concurrent-collections","title":"Concurrent Collections","text":""},{"location":"java/java-multithreading/#1-concurrenthashmap","title":"1. ConcurrentHashMap","text":"<pre><code>public class ConcurrentMapExample {\n    private ConcurrentMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();\n\n    public void updateMap(String key, Integer value) {\n        map.put(key, value);\n    }\n\n    public Integer getValue(String key) {\n        return map.get(key);\n    }\n\n    public void computeIfAbsent(String key) {\n        map.computeIfAbsent(key, k -&gt; calculateValue(k));\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#2-copyonwritearraylist","title":"2. CopyOnWriteArrayList","text":"<pre><code>public class CopyOnWriteExample {\n    private List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n\n    public void addItem(String item) {\n        list.add(item);\n    }\n\n    public void removeItem(String item) {\n        list.remove(item);\n    }\n\n    public void iterate() {\n        // Safe iteration while modifications are happening\n        for (String item : list) {\n            System.out.println(item);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#thread-pools-and-executors","title":"Thread Pools and Executors","text":""},{"location":"java/java-multithreading/#1-fixed-thread-pool","title":"1. Fixed Thread Pool","text":"<pre><code>public class ThreadPoolExample {\n    private ExecutorService executor = Executors.newFixedThreadPool(5);\n\n    public void executeTask(Runnable task) {\n        executor.submit(task);\n    }\n\n    public void shutdown() {\n        executor.shutdown();\n        try {\n            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#2-callable-and-future","title":"2. Callable and Future","text":"<pre><code>public class CallableExample {\n    private ExecutorService executor = Executors.newFixedThreadPool(5);\n\n    public Future&lt;Integer&gt; calculateResult() {\n        return executor.submit(() -&gt; {\n            // Perform computation\n            return computeValue();\n        });\n    }\n\n    public void processResult() {\n        Future&lt;Integer&gt; future = calculateResult();\n        try {\n            Integer result = future.get(1, TimeUnit.SECONDS);\n            System.out.println(\"Result: \" + result);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n            future.cancel(true);\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#3-completablefuture","title":"3. CompletableFuture","text":"<pre><code>public class CompletableFutureExample {\n    public void processAsync() {\n        CompletableFuture&lt;String&gt; future = CompletableFuture\n            .supplyAsync(() -&gt; fetchData())\n            .thenApply(data -&gt; processData(data))\n            .thenAccept(result -&gt; saveResult(result));\n\n        future.exceptionally(throwable -&gt; {\n            handleError(throwable);\n            return null;\n        });\n    }\n\n    public void combineFutures() {\n        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; \"Hello\");\n        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; \"World\");\n\n        CompletableFuture&lt;String&gt; combined = future1\n            .thenCombine(future2, (s1, s2) -&gt; s1 + \" \" + s2);\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#best-practices","title":"Best Practices","text":""},{"location":"java/java-multithreading/#1-thread-safety","title":"1. Thread Safety","text":"<pre><code>public class ThreadSafeExample {\n    // Use volatile for shared flags\n    private volatile boolean running = true;\n\n    // Use atomic classes for counters\n    private AtomicInteger counter = new AtomicInteger(0);\n\n    // Use immutable objects when possible\n    private final String name;\n\n    public ThreadSafeExample(String name) {\n        this.name = name;\n    }\n\n    public void increment() {\n        counter.incrementAndGet();\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#2-resource-management","title":"2. Resource Management","text":"<pre><code>public class ResourceManagement {\n    private ExecutorService executor;\n\n    public void initializePool() {\n        executor = Executors.newFixedThreadPool(\n            Runtime.getRuntime().availableProcessors()\n        );\n    }\n\n    @PreDestroy\n    public void cleanup() {\n        if (executor != null) {\n            executor.shutdown();\n            try {\n                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n                    executor.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                executor.shutdownNow();\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#3-exception-handling","title":"3. Exception Handling","text":"<pre><code>public class ThreadExceptionHandling {\n    private ExecutorService executor = Executors.newFixedThreadPool(5);\n\n    public void handleExceptions() {\n        Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -&gt; {\n            System.err.println(\"Thread \" + thread.getName() + \" threw exception: \" + throwable.getMessage());\n        });\n\n        executor.submit(() -&gt; {\n            try {\n                // Risky operation\n            } catch (Exception e) {\n                // Handle exception\n                Thread.currentThread().getUncaughtExceptionHandler()\n                    .uncaughtException(Thread.currentThread(), e);\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#testing-multithreaded-code","title":"Testing Multithreaded Code","text":"<pre><code>public class MultithreadingTest {\n    @Test\n    public void testConcurrentExecution() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(100);\n        AtomicInteger counter = new AtomicInteger(0);\n\n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(() -&gt; {\n                counter.incrementAndGet();\n                latch.countDown();\n            }).start();\n        }\n\n        latch.await(1, TimeUnit.SECONDS);\n        assertEquals(100, counter.get());\n    }\n}\n</code></pre>"},{"location":"java/java-multithreading/#summary","title":"Summary","text":"<ul> <li>Use appropriate synchronization mechanisms</li> <li>Choose the right concurrent collections</li> <li>Implement proper thread pool management</li> <li>Handle exceptions in threads</li> <li>Test multithreaded code thoroughly</li> <li>Follow thread safety best practices</li> <li>Clean up resources properly </li> </ul>"},{"location":"java/java-oop/","title":"Object-Oriented Programming in Java","text":""},{"location":"java/java-oop/#overview","title":"Overview","text":"<p>This guide explores Object-Oriented Programming (OOP) in Java, covering key concepts like classes, objects, inheritance, polymorphism, encapsulation, and abstraction. OOP is a programming paradigm that organizes code around data (objects) rather than functions and logic, making Java programs more modular, flexible, and maintainable.</p>"},{"location":"java/java-oop/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Java syntax and language fundamentals</li> <li>Understanding of variables, methods, and control flow in Java</li> <li>Java Development Kit (JDK) 17 or later installed</li> </ul>"},{"location":"java/java-oop/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the principles of Object-Oriented Programming</li> <li>Create and use classes and objects in Java</li> <li>Implement inheritance hierarchies effectively</li> <li>Apply polymorphism through method overriding and interfaces</li> <li>Design well-encapsulated classes with proper access modifiers</li> <li>Utilize abstraction using abstract classes and interfaces</li> <li>Work with Java constructors, this keyword, and static members</li> <li>Understand object lifecycle and memory management</li> </ul>"},{"location":"java/java-oop/#table-of-contents","title":"Table of Contents","text":"<ol> <li>OOP Fundamentals</li> <li>Classes and Objects</li> <li>Constructors</li> <li>Encapsulation and Access Control</li> <li>Inheritance</li> <li>Polymorphism</li> <li>Abstraction</li> <li>Interfaces</li> <li>Advanced OOP Concepts</li> <li>Best Practices</li> </ol>"},{"location":"java/java-oop/#oop-fundamentals","title":"OOP Fundamentals","text":"<p>Object-Oriented Programming is built on four main principles:</p> <ol> <li> <p>Encapsulation: Bundling data and methods that operate on that data within a single unit (class), and restricting direct access to some of the object's components.</p> </li> <li> <p>Inheritance: The ability of a class to inherit properties and behavior from another class, promoting code reuse.</p> </li> <li> <p>Polymorphism: The ability of different classes to be treated as instances of the same class through inheritance, enabling a single interface to represent different underlying forms.</p> </li> <li> <p>Abstraction: Simplifying complex reality by modeling classes based on the essential properties and behaviors relevant to the application's context.</p> </li> </ol>"},{"location":"java/java-oop/#classes-and-objects","title":"Classes and Objects","text":""},{"location":"java/java-oop/#classes","title":"Classes","text":"<p>A class is a blueprint or template for creating objects. It defines the properties (attributes) and behaviors (methods) that the objects created from the class will have.</p> <pre><code>// Basic class structure\npublic class Car {\n    // Fields (attributes)\n    private String make;\n    private String model;\n    private int year;\n    private double mileage;\n\n    // Methods (behaviors)\n    public void drive(double distance) {\n        mileage += distance;\n        System.out.println(\"Driving \" + distance + \" miles\");\n    }\n\n    public void displayInfo() {\n        System.out.println(year + \" \" + make + \" \" + model);\n        System.out.println(\"Mileage: \" + mileage);\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#objects","title":"Objects","text":"<p>An object is an instance of a class, representing a specific entity with its own set of values for the attributes defined in the class.</p> <pre><code>// Creating objects (instances) of the Car class\nCar myCar = new Car();\nCar yourCar = new Car();\n\n// Each object has its own state\nmyCar.drive(100);\nyourCar.drive(50);\n</code></pre>"},{"location":"java/java-oop/#constructors","title":"Constructors","text":"<p>Constructors are special methods that initialize objects. They have the same name as the class and don't have a return type.</p>"},{"location":"java/java-oop/#types-of-constructors","title":"Types of Constructors","text":"<ol> <li> <p>Default Constructor: Created by Java if no constructor is defined, initializes attributes to default values.</p> </li> <li> <p>Parameterized Constructor: Takes parameters to initialize object attributes.</p> </li> <li> <p>Copy Constructor: Creates a new object with the same attribute values as an existing object.</p> </li> </ol> <pre><code>public class Car {\n    private String make;\n    private String model;\n    private int year;\n    private double mileage;\n\n    // Default constructor\n    public Car() {\n        make = \"Unknown\";\n        model = \"Unknown\";\n        year = 2023;\n        mileage = 0;\n    }\n\n    // Parameterized constructor\n    public Car(String make, String model, int year) {\n        this.make = make;\n        this.model = model;\n        this.year = year;\n        this.mileage = 0;\n    }\n\n    // Copy constructor\n    public Car(Car otherCar) {\n        this.make = otherCar.make;\n        this.model = otherCar.model;\n        this.year = otherCar.year;\n        this.mileage = otherCar.mileage;\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#constructor-overloading","title":"Constructor Overloading","text":"<p>Multiple constructors with different parameter lists:</p> <pre><code>// Using the constructors\nCar car1 = new Car();  // Default constructor\nCar car2 = new Car(\"Toyota\", \"Corolla\", 2022);  // Parameterized constructor\nCar car3 = new Car(car2);  // Copy constructor\n</code></pre>"},{"location":"java/java-oop/#the-this-keyword","title":"The <code>this</code> Keyword","text":"<p><code>this</code> refers to the current object instance and is used to: - Distinguish between class attributes and parameters with the same name - Invoke other constructors - Pass the current object as a parameter to other methods</p> <pre><code>public class Person {\n    private String name;\n    private int age;\n\n    // Using this to refer to instance variables\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Using this to call another constructor\n    public Person(String name) {\n        this(name, 0);  // Calls the constructor that takes name and age\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#encapsulation-and-access-control","title":"Encapsulation and Access Control","text":"<p>Encapsulation is the bundling of data and methods that operate on that data within a single unit (class), and restricting direct access to some components.</p>"},{"location":"java/java-oop/#access-modifiers","title":"Access Modifiers","text":"<p>Java provides four access modifiers to control the visibility of classes, fields, methods, and constructors:</p> <ol> <li>private: Accessible only within the same class</li> <li>default (no modifier): Accessible within the same package</li> <li>protected: Accessible within the same package and by subclasses</li> <li>public: Accessible from anywhere</li> </ol> <pre><code>public class BankAccount {\n    // Private fields - not directly accessible from outside\n    private String accountNumber;\n    private double balance;\n\n    // Public getters and setters - controlled access\n    public String getAccountNumber() {\n        return accountNumber;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n        }\n    }\n\n    public boolean withdraw(double amount) {\n        if (amount &gt; 0 &amp;&amp; balance &gt;= amount) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#benefits-of-encapsulation","title":"Benefits of Encapsulation","text":"<ul> <li>Data hiding: Prevents unauthorized access to internal implementation details</li> <li>Flexibility: Implementation can change without affecting client code</li> <li>Validation: Can enforce rules on how data is modified</li> <li>Maintainability: Easier to modify internal implementation without breaking dependent code</li> </ul>"},{"location":"java/java-oop/#inheritance","title":"Inheritance","text":"<p>Inheritance allows a class to inherit attributes and behaviors from another class, facilitating code reuse and establishing an \"is-a\" relationship.</p>"},{"location":"java/java-oop/#types-of-inheritance","title":"Types of Inheritance","text":"<ul> <li>Single inheritance: A class inherits from one superclass</li> <li>Multilevel inheritance: A class inherits from a class that inherits from another class</li> <li>Hierarchical inheritance: Multiple classes inherit from a single superclass</li> </ul> <p>Java does not support multiple inheritance directly (a class cannot extend multiple classes), but it can be achieved through interfaces.</p>"},{"location":"java/java-oop/#syntax","title":"Syntax","text":"<pre><code>// Parent/superclass/base class\npublic class Vehicle {\n    protected String make;\n    protected String model;\n    protected int year;\n\n    public Vehicle(String make, String model, int year) {\n        this.make = make;\n        this.model = model;\n        this.year = year;\n    }\n\n    public void displayInfo() {\n        System.out.println(year + \" \" + make + \" \" + model);\n    }\n}\n\n// Child/subclass/derived class\npublic class Car extends Vehicle {\n    private int numDoors;\n\n    public Car(String make, String model, int year, int numDoors) {\n        super(make, model, year);  // Call to parent constructor\n        this.numDoors = numDoors;\n    }\n\n    // Override parent method\n    @Override\n    public void displayInfo() {\n        super.displayInfo();  // Call parent method\n        System.out.println(\"Number of doors: \" + numDoors);\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#the-super-keyword","title":"The <code>super</code> Keyword","text":"<p>The <code>super</code> keyword is used to: - Call the superclass constructor - Access superclass methods and fields - Distinguish between superclass and subclass members with the same name</p>"},{"location":"java/java-oop/#method-overriding","title":"Method Overriding","text":"<p>Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.</p> <pre><code>@Override  // Annotation to ensure proper overriding\npublic void displayInfo() {\n    // New implementation\n}\n</code></pre>"},{"location":"java/java-oop/#the-final-keyword","title":"The <code>final</code> Keyword","text":"<p>The <code>final</code> modifier can be used with: - Classes: Prevents the class from being extended - Methods: Prevents the method from being overridden in subclasses - Variables: Creates constants whose values cannot be changed</p> <pre><code>// Final class that cannot be extended\npublic final class ImmutableClass {\n    // Final variable (constant)\n    public final double PI = 3.14159;\n\n    // Final method that cannot be overridden\n    public final void display() {\n        System.out.println(\"This method cannot be overridden\");\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism allows objects of different types to be treated as objects of a common supertype, enabling a single interface to represent different underlying forms.</p>"},{"location":"java/java-oop/#types-of-polymorphism","title":"Types of Polymorphism","text":"<ol> <li>Compile-time Polymorphism (Method Overloading):    Multiple methods with the same name but different parameters in the same class.</li> </ol> <pre><code>public class Calculator {\n    // Method overloading\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n\n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n</code></pre> <ol> <li>Runtime Polymorphism (Method Overriding):    Subclass provides a specific implementation of a method already defined in its superclass.</li> </ol> <pre><code>// Using runtime polymorphism\nVehicle vehicle1 = new Car(\"Toyota\", \"Corolla\", 2022, 4);\nVehicle vehicle2 = new Motorcycle(\"Honda\", \"CBR\", 2023);\n\nvehicle1.displayInfo();  // Calls Car's implementation\nvehicle2.displayInfo();  // Calls Motorcycle's implementation\n</code></pre>"},{"location":"java/java-oop/#benefits-of-polymorphism","title":"Benefits of Polymorphism","text":"<ul> <li>Flexibility: Code can work with objects of different classes through a common interface</li> <li>Extensibility: New classes can be added without changing existing code</li> <li>Simplicity: Reduces complex conditional logic by using the right method implementation for each object type</li> </ul>"},{"location":"java/java-oop/#abstraction","title":"Abstraction","text":"<p>Abstraction focuses on essential qualities rather than specific characteristics, hiding complex implementation details and showing only the necessary features.</p>"},{"location":"java/java-oop/#abstract-classes","title":"Abstract Classes","text":"<p>An abstract class is a class that cannot be instantiated and is meant to be subclassed. It can contain abstract methods (methods without implementation) that must be implemented by concrete subclasses.</p> <pre><code>// Abstract class\npublic abstract class Shape {\n    // Abstract method - no implementation\n    public abstract double calculateArea();\n\n    // Concrete method - has implementation\n    public void display() {\n        System.out.println(\"This is a shape with area: \" + calculateArea());\n    }\n}\n\n// Concrete subclass\npublic class Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#key-points","title":"Key Points","text":"<ul> <li>Abstract classes can have both abstract and concrete methods</li> <li>Abstract classes cannot be instantiated directly (<code>new Shape()</code> would be illegal)</li> <li>A class that extends an abstract class must implement all abstract methods, or itself be declared abstract</li> <li>Abstract classes can have constructors, fields, and non-abstract methods</li> </ul>"},{"location":"java/java-oop/#interfaces","title":"Interfaces","text":"<p>An interface is a reference type that defines a contract of methods that implementing classes must provide. It represents a capability or behavior that classes can implement.</p>"},{"location":"java/java-oop/#syntax_1","title":"Syntax","text":"<pre><code>// Interface definition\npublic interface Drivable {\n    // Abstract methods (implicitly public and abstract)\n    void start();\n    void stop();\n    void accelerate(double speed);\n\n    // Default method (Java 8+)\n    default void park() {\n        System.out.println(\"Parking the vehicle\");\n    }\n\n    // Static method (Java 8+)\n    static double convertMilesToKm(double miles) {\n        return miles * 1.60934;\n    }\n}\n\n// Implementing an interface\npublic class Car implements Drivable {\n    @Override\n    public void start() {\n        System.out.println(\"Starting the car\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Stopping the car\");\n    }\n\n    @Override\n    public void accelerate(double speed) {\n        System.out.println(\"Accelerating to \" + speed + \" mph\");\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#interface-vs-abstract-class","title":"Interface vs. Abstract Class","text":"Feature Interface Abstract Class Multiple Inheritance A class can implement multiple interfaces A class can extend only one abstract class State Cannot have state (fields) before Java 8 Can have fields with any access modifier Constructor Cannot have constructors Can have constructors Method Implementation Can have default and static methods (Java 8+) Can have both abstract and concrete methods Access Modifiers Methods are implicitly public Methods can have any access modifier Purpose Defines behavior Provides a base for subclasses"},{"location":"java/java-oop/#functional-interfaces-java-8","title":"Functional Interfaces (Java 8+)","text":"<p>A functional interface has exactly one abstract method and can be implemented using lambda expressions.</p> <pre><code>// Functional interface\n@FunctionalInterface\npublic interface Calculable {\n    int calculate(int a, int b);\n}\n\n// Using lambda expressions\nCalculable addition = (a, b) -&gt; a + b;\nCalculable subtraction = (a, b) -&gt; a - b;\n\nSystem.out.println(addition.calculate(5, 3));      // 8\nSystem.out.println(subtraction.calculate(5, 3));   // 2\n</code></pre>"},{"location":"java/java-oop/#advanced-oop-concepts","title":"Advanced OOP Concepts","text":""},{"location":"java/java-oop/#static-members","title":"Static Members","text":"<p>Static members belong to the class rather than to any instance of the class.</p> <pre><code>public class MathUtils {\n    // Static variable (shared across all instances)\n    public static final double PI = 3.14159;\n\n    // Static method\n    public static int add(int a, int b) {\n        return a + b;\n    }\n\n    // Static block - executed when the class is loaded\n    static {\n        System.out.println(\"MathUtils class loaded\");\n    }\n}\n\n// Using static members\ndouble area = MathUtils.PI * radius * radius;\nint sum = MathUtils.add(5, 3);\n</code></pre>"},{"location":"java/java-oop/#inner-classes","title":"Inner Classes","text":"<p>A class defined within another class to logically group classes and increase encapsulation.</p> <pre><code>public class OuterClass {\n    private int outerField;\n\n    // Inner class - has access to all members of the outer class\n    public class InnerClass {\n        public void display() {\n            System.out.println(\"Outer field: \" + outerField);\n        }\n    }\n\n    // Static nested class - doesn't have access to instance members of the outer class\n    public static class StaticNestedClass {\n        public void display() {\n            // Cannot access outerField directly\n            System.out.println(\"Static nested class\");\n        }\n    }\n\n    public void createLocalClass() {\n        // Local class - defined within a method\n        class LocalClass {\n            public void display() {\n                System.out.println(\"Local class\");\n            }\n        }\n\n        LocalClass local = new LocalClass();\n        local.display();\n    }\n}\n</code></pre>"},{"location":"java/java-oop/#anonymous-classes","title":"Anonymous Classes","text":"<p>Creating a one-time use class without defining a new named class.</p> <pre><code>// Anonymous class implementing an interface\nRunnable runner = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Running in anonymous class\");\n    }\n};\n\n// Starting a thread with the anonymous class\nnew Thread(runner).start();\n\n// More concise with lambda expression (Java 8+)\nnew Thread(() -&gt; System.out.println(\"Running with lambda\")).start();\n</code></pre>"},{"location":"java/java-oop/#records-java-16","title":"Records (Java 16+)","text":"<p>Records are immutable data classes that require minimal code to create simple data carriers.</p> <pre><code>// Record declaration\npublic record Person(String name, int age) {\n    // Compact constructor\n    public Person {\n        if (age &lt; 0) {\n            throw new IllegalArgumentException(\"Age cannot be negative\");\n        }\n    }\n\n    // Additional methods\n    public boolean isAdult() {\n        return age &gt;= 18;\n    }\n}\n\n// Using a record\nPerson person = new Person(\"John\", 25);\nSystem.out.println(person.name());  // \"John\"\nSystem.out.println(person.age());   // 25\nSystem.out.println(person.isAdult()); // true\n</code></pre>"},{"location":"java/java-oop/#sealed-classes-java-17","title":"Sealed Classes (Java 17+)","text":"<p>Sealed classes restrict which other classes can extend them, providing more control over the inheritance hierarchy.</p> <pre><code>// Sealed class with permitted subclasses\npublic sealed class Shape permits Circle, Rectangle, Triangle {\n    // Common shape methods\n}\n\n// Permitted subclasses must be final, sealed, or non-sealed\npublic final class Circle extends Shape {\n    // Circle implementation\n}\n\npublic sealed class Rectangle extends Shape permits Square {\n    // Rectangle implementation\n}\n\npublic final class Square extends Rectangle {\n    // Square implementation\n}\n\npublic non-sealed class Triangle extends Shape {\n    // Triangle implementation\n}\n</code></pre>"},{"location":"java/java-oop/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Follow Single Responsibility Principle: A class should have only one reason to change.</p> </li> <li> <p>Use Encapsulation: Make fields private and provide getters/setters only when necessary.</p> </li> <li> <p>Favor Composition over Inheritance: \"Has-a\" relationships are often more flexible than \"is-a\" relationships.</p> </li> <li> <p>Program to Interfaces: Depend on abstractions, not concrete implementations.</p> </li> <li> <p>Keep Inheritance Hierarchies Shallow: Deep inheritance hierarchies become difficult to understand and maintain.</p> </li> <li> <p>Override <code>toString()</code>, <code>equals()</code>, and <code>hashCode()</code>: Makes your classes more usable and integrates better with Java collections.</p> </li> </ol> <pre><code>@Override\npublic String toString() {\n    return \"Car{make='\" + make + \"', model='\" + model + \"', year=\" + year + \"}\";\n}\n\n@Override\npublic boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null || getClass() != obj.getClass()) return false;\n    Car car = (Car) obj;\n    return year == car.year &amp;&amp;\n           Objects.equals(make, car.make) &amp;&amp;\n           Objects.equals(model, car.model);\n}\n\n@Override\npublic int hashCode() {\n    return Objects.hash(make, model, year);\n}\n</code></pre> <ol> <li> <p>Use Appropriate Access Modifiers: Don't make everything public.</p> </li> <li> <p>Use Final When Appropriate: Mark classes, methods, or variables as final when they shouldn't be changed or overridden.</p> </li> <li> <p>Implement Interfaces Rather Than Extending Abstract Classes when you want to define a contract without imposing class hierarchy.</p> </li> <li> <p>Use Records for simple data containers (Java 16+).</p> </li> </ol>"},{"location":"java/java-oop/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":"<ol> <li> <p>Excessive Inheritance: Use inheritance only when a true \"is-a\" relationship exists.</p> </li> <li> <p>Overuse of Getters and Setters: Not all fields need accessors; consider what operations the object should expose.</p> </li> <li> <p>Ignoring Access Control: Proper encapsulation prevents unintended changes to object state.</p> </li> <li> <p>Not Using Override Annotation: The <code>@Override</code> annotation catches errors at compile time.</p> </li> <li> <p>Memory Leaks with Inner Classes: Anonymous and non-static inner classes hold references to their enclosing instances.</p> </li> <li> <p>Equals/HashCode Contract Violations: When overriding <code>equals()</code>, always override <code>hashCode()</code> as well.</p> </li> <li> <p>Type Checking with instanceof: Excessive type checking often indicates a design problem; consider polymorphism instead.</p> </li> </ol>"},{"location":"java/java-oop/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>Java Language Specification: Classes</li> <li> <p>Java Tutorials: Classes and Objects</p> </li> <li> <p>Books:</p> </li> <li>\"Effective Java\" by Joshua Bloch</li> <li>\"Head First Object-Oriented Analysis and Design\"</li> <li> <p>\"Clean Code\" by Robert C. Martin</p> </li> <li> <p>Online Courses:</p> </li> <li>Coursera - Object Oriented Programming in Java</li> <li> <p>Udemy - Java Object-Oriented Programming</p> </li> <li> <p>Design Patterns:</p> </li> <li>Refactoring Guru: Design Patterns</li> <li>\"Design Patterns: Elements of Reusable Object-Oriented Software\" by the Gang of Four</li> </ol>"},{"location":"java/java-oop/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>Bank Account System:    Create a system with a base <code>Account</code> class and derived classes like <code>SavingsAccount</code> and <code>CheckingAccount</code>. Implement methods for deposit, withdrawal, and interest calculation.</p> </li> <li> <p>Shape Hierarchy:    Design a class hierarchy for geometric shapes with a common interface for calculating area and perimeter.</p> </li> <li> <p>Employee Management:    Create a system to track different types of employees (full-time, part-time, contractor) with appropriate payroll calculations.</p> </li> <li> <p>Animal Kingdom:    Model an animal hierarchy showcasing inheritance and polymorphism with different animal types and behaviors.</p> </li> <li> <p>E-commerce System:    Design classes for products, customers, orders, and payment methods in an online shopping system.</p> </li> <li> <p>Media Library:    Create a library system for different types of media (books, movies, music) with common operations.</p> </li> <li> <p>Vehicle Rental System:    Design classes for a vehicle rental service with different vehicle types and rental options.</p> </li> <li> <p>Smart Home System:    Model a smart home with various devices that can be controlled through a common interface.</p> </li> <li> <p>Game Character System:    Create a class hierarchy for different game character types with unique abilities and common attributes.</p> </li> <li> <p>Publishing System:     Design classes for a publishing system with authors, editors, books, articles, and publications.</p> </li> </ol>"},{"location":"java/java-streams-lambdas/","title":"Java Streams and Lambdas","text":""},{"location":"java/java-streams-lambdas/#overview","title":"Overview","text":"<p>This guide explores Java's functional programming capabilities through lambdas, streams, and functional interfaces. Introduced in Java 8, these features enable more concise, expressive code and facilitate parallel data processing. Streams provide a functional approach to processing collections of objects, while lambdas allow you to write inline, anonymous functions.</p>"},{"location":"java/java-streams-lambdas/#prerequisites","title":"Prerequisites","text":"<ul> <li>Solid understanding of Java core concepts</li> <li>Experience with Java collections</li> <li>Familiarity with object-oriented programming</li> <li>Basic understanding of method references</li> </ul>"},{"location":"java/java-streams-lambdas/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand lambda expressions and their syntax</li> <li>Master functional interfaces in the java.util.function package</li> <li>Apply method references for more concise code</li> <li>Create and utilize Stream pipelines for data processing</li> <li>Transform data collections using map, filter, and reduce operations</li> <li>Apply terminal operations to produce results from streams</li> <li>Leverage parallel streams for improved performance</li> <li>Understand optional values and their proper usage</li> <li>Combine multiple functional operations for complex data transformations</li> <li>Recognize appropriate use cases for functional vs imperative approaches</li> </ul>"},{"location":"java/java-streams-lambdas/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Lambda Expressions</li> <li>Functional Interfaces</li> <li>Method References</li> <li>Introduction to Streams</li> <li>Intermediate Operations</li> <li>Terminal Operations</li> <li>Optional Class</li> <li>Parallel Streams</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ol>"},{"location":"java/java-streams-lambdas/#lambda-expressions","title":"Lambda Expressions","text":""},{"location":"java/java-streams-lambdas/#lambda-syntax","title":"Lambda Syntax","text":"<p>Lambda expressions provide a concise way to express instances of single-method interfaces (functional interfaces).</p> <p>Basic syntax: <code>(parameters) -&gt; expression</code> or <code>(parameters) -&gt; { statements; }</code></p> <pre><code>// Lambda with no parameters\nRunnable runnable = () -&gt; System.out.println(\"Hello, World!\");\n\n// Lambda with one parameter (type inferred)\nConsumer&lt;String&gt; consumer = message -&gt; System.out.println(message);\n\n// Lambda with multiple parameters\nComparator&lt;String&gt; comparator = (s1, s2) -&gt; s1.length() - s2.length();\n\n// Lambda with explicit parameter types\nBiFunction&lt;Integer, Integer, Integer&gt; add = (Integer a, Integer b) -&gt; a + b;\n\n// Multi-line lambda with block\nConsumer&lt;String&gt; printer = message -&gt; {\n    String formattedMessage = \"Message: \" + message;\n    System.out.println(formattedMessage);\n};\n</code></pre>"},{"location":"java/java-streams-lambdas/#variable-capture","title":"Variable Capture","text":"<p>Lambdas can access variables from the surrounding scope:</p> <pre><code>String prefix = \"User: \";\n\n// Lambda capturing the prefix variable\nConsumer&lt;String&gt; printUser = name -&gt; System.out.println(prefix + name);\n\n// Using the lambda\nprintUser.accept(\"John\"); // Outputs: User: John\n</code></pre> <p>Variables used in lambda expressions must be effectively final (not changed after initialization).</p> <pre><code>int count = 0;\n\n// Incorrect: trying to modify a captured variable\nRunnable runnable = () -&gt; {\n    count++; // Compile error: Variable used in lambda should be final or effectively final\n};\n\n// Correct: using AtomicInteger for mutable counter\nAtomicInteger atomicCount = new AtomicInteger(0);\nRunnable correctRunnable = () -&gt; {\n    atomicCount.incrementAndGet(); // Works fine\n};\n</code></pre>"},{"location":"java/java-streams-lambdas/#lambda-vs-anonymous-classes","title":"Lambda vs Anonymous Classes","text":"<p>Lambdas are more concise than anonymous inner classes:</p> <pre><code>// Anonymous class approach\nRunnable anonymousRunnable = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Anonymous class\");\n    }\n};\n\n// Lambda approach\nRunnable lambdaRunnable = () -&gt; System.out.println(\"Lambda expression\");\n</code></pre> <p>Key differences: - <code>this</code> refers to the enclosing instance in a lambda, but to the anonymous class instance in an anonymous class - Lambdas don't introduce a new scope for variables - Lambdas are more memory-efficient</p>"},{"location":"java/java-streams-lambdas/#functional-interfaces","title":"Functional Interfaces","text":""},{"location":"java/java-streams-lambdas/#core-functional-interfaces","title":"Core Functional Interfaces","text":"<p>Java 8 introduced several predefined functional interfaces in the <code>java.util.function</code> package:</p>"},{"location":"java/java-streams-lambdas/#function","title":"Function <p>Represents a function that takes one argument and produces a result.</p> <pre><code>Function&lt;String, Integer&gt; stringLength = s -&gt; s.length();\nInteger length = stringLength.apply(\"Hello\"); // returns 5\n\n// Function composition\nFunction&lt;Integer, Integer&gt; multiply = n -&gt; n * 2;\nFunction&lt;Integer, Integer&gt; add = n -&gt; n + 3;\n\nFunction&lt;Integer, Integer&gt; multiplyThenAdd = multiply.andThen(add);\nInteger result1 = multiplyThenAdd.apply(5); // (5 * 2) + 3 = 13\n\nFunction&lt;Integer, Integer&gt; addThenMultiply = multiply.compose(add);\nInteger result2 = addThenMultiply.apply(5); // (5 + 3) * 2 = 16\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#predicate","title":"Predicate <p>Represents a function that takes one argument and returns a boolean.</p> <pre><code>Predicate&lt;String&gt; isEmpty = s -&gt; s.isEmpty();\nboolean result = isEmpty.test(\"\"); // returns true\n\n// Predicate composition\nPredicate&lt;String&gt; isNotEmpty = isEmpty.negate();\nPredicate&lt;String&gt; isLong = s -&gt; s.length() &gt; 10;\nPredicate&lt;String&gt; isLongAndNotEmpty = isNotEmpty.and(isLong);\n\nboolean test1 = isLongAndNotEmpty.test(\"Hello World!\"); // true\nboolean test2 = isLongAndNotEmpty.test(\"\"); // false\nboolean test3 = isLongAndNotEmpty.test(\"Hello\"); // false\n\nPredicate&lt;String&gt; isShortOrEmpty = isLong.negate().or(isEmpty);\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#consumer","title":"Consumer <p>Represents an operation that takes one argument and returns no result.</p> <pre><code>Consumer&lt;String&gt; print = s -&gt; System.out.println(s);\nprint.accept(\"Hello\"); // prints \"Hello\"\n\n// Consumer chaining\nConsumer&lt;String&gt; log = s -&gt; System.out.println(\"Log: \" + s);\nConsumer&lt;String&gt; printThenLog = print.andThen(log);\nprintThenLog.accept(\"Hello\");\n// Prints:\n// Hello\n// Log: Hello\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#supplier","title":"Supplier <p>Represents a supplier of results, takes no input but returns a value.</p> <pre><code>Supplier&lt;Double&gt; randomValue = () -&gt; Math.random();\nDouble value = randomValue.get(); // returns a random double\n\nSupplier&lt;List&lt;String&gt;&gt; listSupplier = () -&gt; new ArrayList&lt;&gt;();\nList&lt;String&gt; newList = listSupplier.get(); // returns a new empty ArrayList\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#bifunction","title":"BiFunction <p>Takes two arguments and produces a result.</p> <pre><code>BiFunction&lt;String, String, String&gt; concat = (a, b) -&gt; a + b;\nString result = concat.apply(\"Hello, \", \"World!\"); // \"Hello, World!\"\n\nBiFunction&lt;Integer, Integer, Integer&gt; multiply = (a, b) -&gt; a * b;\nInteger product = multiply.apply(5, 7); // 35\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#specialized-functional-interfaces","title":"Specialized Functional Interfaces","text":"<p>Java provides specialized interfaces for primitive types to avoid boxing/unboxing:</p> <pre><code>// For int operations\nIntPredicate isEven = n -&gt; n % 2 == 0;\nboolean check = isEven.test(4); // true\n\nIntFunction&lt;String&gt; intToString = n -&gt; String.valueOf(n);\nString str = intToString.apply(123); // \"123\"\n\nIntConsumer printInt = n -&gt; System.out.println(n);\nprintInt.accept(42); // prints 42\n\nIntSupplier randomInt = () -&gt; new Random().nextInt(100);\nint value = randomInt.getAsInt(); // random int between 0-99\n\nIntUnaryOperator square = n -&gt; n * n;\nint squared = square.applyAsInt(5); // 25\n\nIntBinaryOperator sum = (a, b) -&gt; a + b;\nint total = sum.applyAsInt(10, 20); // 30\n\n// Similar interfaces exist for long and double:\n// LongPredicate, LongFunction, LongConsumer, etc.\n// DoublePredicate, DoubleFunction, DoubleConsumer, etc.\n</code></pre>"},{"location":"java/java-streams-lambdas/#creating-custom-functional-interfaces","title":"Creating Custom Functional Interfaces","text":"<p>You can define your own functional interfaces:</p> <pre><code>@FunctionalInterface\npublic interface TriFunction&lt;T, U, V, R&gt; {\n    R apply(T t, U u, V v);\n}\n\n// Using custom functional interface\nTriFunction&lt;Integer, Integer, Integer, Integer&gt; sum3 = \n    (a, b, c) -&gt; a + b + c;\nInteger result = sum3.apply(1, 2, 3); // 6\n</code></pre> <p>The <code>@FunctionalInterface</code> annotation enforces that the interface has exactly one abstract method.</p>"},{"location":"java/java-streams-lambdas/#method-references","title":"Method References","text":"<p>Method references provide a shorthand notation for lambdas that simply call an existing method.</p>"},{"location":"java/java-streams-lambdas/#types-of-method-references","title":"Types of Method References","text":""},{"location":"java/java-streams-lambdas/#1-reference-to-a-static-method-classnamestaticmethod","title":"1. Reference to a static method: <code>ClassName::staticMethod</code> <pre><code>// Instead of: Function&lt;String, Integer&gt; parser = s -&gt; Integer.parseInt(s);\nFunction&lt;String, Integer&gt; parser = Integer::parseInt;\n\nInteger value = parser.apply(\"123\"); // 123\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#2-reference-to-an-instance-method-of-a-particular-object-instanceinstancemethod","title":"2. Reference to an instance method of a particular object: <code>instance::instanceMethod</code> <pre><code>String greeting = \"Hello\";\n// Instead of: Supplier&lt;String&gt; supplier = () -&gt; greeting.toUpperCase();\nSupplier&lt;String&gt; supplier = greeting::toUpperCase;\n\nString result = supplier.get(); // \"HELLO\"\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#3-reference-to-an-instance-method-of-an-arbitrary-object-of-a-particular-type-classnameinstancemethod","title":"3. Reference to an instance method of an arbitrary object of a particular type: <code>ClassName::instanceMethod</code> <pre><code>// Instead of: Function&lt;String, Integer&gt; lengthFunc = s -&gt; s.length();\nFunction&lt;String, Integer&gt; lengthFunc = String::length;\n\nInteger length = lengthFunc.apply(\"Hello\"); // 5\n\n// Instead of: BiPredicate&lt;String, String&gt; contains = (s, substr) -&gt; s.contains(substr);\nBiPredicate&lt;String, String&gt; contains = String::contains;\n\nboolean result = contains.test(\"Hello World\", \"World\"); // true\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#4-reference-to-a-constructor-classnamenew","title":"4. Reference to a constructor: <code>ClassName::new</code> <pre><code>// Instead of: Supplier&lt;List&lt;String&gt;&gt; listSupplier = () -&gt; new ArrayList&lt;&gt;();\nSupplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new;\n\nList&lt;String&gt; list = listSupplier.get(); // new ArrayList\n\n// With a parameter\n// Instead of: Function&lt;Integer, List&lt;String&gt;&gt; sizedListCreator = n -&gt; new ArrayList&lt;&gt;(n);\nFunction&lt;Integer, List&lt;String&gt;&gt; sizedListCreator = ArrayList::new;\n\nList&lt;String&gt; sizedList = sizedListCreator.apply(10); // ArrayList with initial capacity 10\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#introduction-to-streams","title":"Introduction to Streams","text":""},{"location":"java/java-streams-lambdas/#what-is-a-stream","title":"What is a Stream?","text":"<p>A stream is a sequence of elements that supports sequential and parallel aggregate operations. It is not a data structure but a view of the data from a source like collections, arrays, or I/O channels.</p> <pre><code>// Creating streams from different sources\nList&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Adam\", \"Eve\");\n\n// From a collection\nStream&lt;String&gt; streamFromCollection = names.stream();\n\n// From an array\nString[] namesArray = {\"John\", \"Jane\", \"Adam\", \"Eve\"};\nStream&lt;String&gt; streamFromArray = Arrays.stream(namesArray);\n\n// From individual values\nStream&lt;String&gt; streamOfValues = Stream.of(\"John\", \"Jane\", \"Adam\", \"Eve\");\n\n// Empty stream\nStream&lt;String&gt; emptyStream = Stream.empty();\n\n// Infinite streams\nStream&lt;Integer&gt; infiniteIntegers = Stream.iterate(0, n -&gt; n + 1);\nStream&lt;Double&gt; infiniteRandoms = Stream.generate(Math::random);\n</code></pre>"},{"location":"java/java-streams-lambdas/#stream-pipeline","title":"Stream Pipeline","text":"<p>A stream pipeline consists of: 1. A source 2. Zero or more intermediate operations 3. A terminal operation</p> <pre><code>List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Adam\", \"Eve\");\n\nlong count = names.stream()    // Source\n                .filter(s -&gt; s.startsWith(\"J\"))  // Intermediate operation\n                .map(String::toUpperCase)        // Intermediate operation\n                .count();                        // Terminal operation\n\nSystem.out.println(\"Count: \" + count); // 2\n</code></pre>"},{"location":"java/java-streams-lambdas/#stream-characteristics","title":"Stream Characteristics","text":"<ul> <li>Laziness: Intermediate operations are lazy and only executed when a terminal operation is invoked</li> <li>Once-use: A stream can only be used once</li> <li>Non-interference: Data sources should not be modified during stream operations</li> <li>Stateless behavior: For best performance, operations should not depend on any state outside the operation</li> </ul> <pre><code>Stream&lt;String&gt; stream = names.stream();\nstream.forEach(System.out::println);\n// stream.count(); // Throws IllegalStateException: stream has already been operated upon or closed\n</code></pre>"},{"location":"java/java-streams-lambdas/#intermediate-operations","title":"Intermediate Operations","text":"<p>Intermediate operations transform a stream into another stream and are lazy (not executed until a terminal operation is invoked).</p>"},{"location":"java/java-streams-lambdas/#filtering-operations","title":"Filtering Operations","text":""},{"location":"java/java-streams-lambdas/#filter","title":"filter <p>Filters elements based on a predicate.</p> <pre><code>List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Adam\", \"Eve\", \"Alice\");\n\nList&lt;String&gt; filteredNames = names.stream()\n    .filter(name -&gt; name.length() &gt; 3)\n    .collect(Collectors.toList());\n// filteredNames: [John, Jane, Adam, Alice]\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#distinct","title":"distinct <p>Returns a stream with distinct elements.</p> <pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5, 5);\n\nList&lt;Integer&gt; distinctNumbers = numbers.stream()\n    .distinct()\n    .collect(Collectors.toList());\n// distinctNumbers: [1, 2, 3, 4, 5]\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#limit","title":"limit <p>Limits the stream to a specified size.</p> <pre><code>List&lt;Integer&gt; first3Numbers = numbers.stream()\n    .limit(3)\n    .collect(Collectors.toList());\n// first3Numbers: [1, 2, 2]\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#skip","title":"skip <p>Skips the first n elements.</p> <pre><code>List&lt;Integer&gt; skipFirst2 = numbers.stream()\n    .skip(2)\n    .collect(Collectors.toList());\n// skipFirst2: [2, 3, 3, 3, 4, 5, 5]\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#transformation-operations","title":"Transformation Operations","text":""},{"location":"java/java-streams-lambdas/#map","title":"map <p>Transforms each element using a function.</p> <pre><code>List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Adam\");\n\nList&lt;Integer&gt; nameLengths = names.stream()\n    .map(String::length)\n    .collect(Collectors.toList());\n// nameLengths: [4, 4, 4]\n\nList&lt;String&gt; upperCaseNames = names.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n// upperCaseNames: [JOHN, JANE, ADAM]\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#maptoint-maptolong-maptodouble","title":"mapToInt, mapToLong, mapToDouble <p>Maps to primitive streams.</p> <pre><code>List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Adam\");\n\n// Using mapToInt to avoid boxing\nint totalLength = names.stream()\n    .mapToInt(String::length)\n    .sum();\n// totalLength: 12\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#flatmap","title":"flatMap <p>Flattens nested streams into a single stream.</p> <pre><code>List&lt;List&lt;Integer&gt;&gt; nestedLists = Arrays.asList(\n    Arrays.asList(1, 2, 3),\n    Arrays.asList(4, 5, 6),\n    Arrays.asList(7, 8, 9)\n);\n\nList&lt;Integer&gt; flattenedList = nestedLists.stream()\n    .flatMap(Collection::stream)\n    .collect(Collectors.toList());\n// flattenedList: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n// Another example with strings\nList&lt;String&gt; words = Arrays.asList(\"Hello\", \"World\");\n\nList&lt;String&gt; letters = words.stream()\n    .flatMap(word -&gt; Arrays.stream(word.split(\"\")))\n    .collect(Collectors.toList());\n// letters: [H, e, l, l, o, W, o, r, l, d]\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#ordering-operations","title":"Ordering Operations","text":""},{"location":"java/java-streams-lambdas/#sorted","title":"sorted <p>Sorts the elements of the stream.</p> <pre><code>List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Adam\", \"Eve\");\n\n// Natural order\nList&lt;String&gt; sortedNames = names.stream()\n    .sorted()\n    .collect(Collectors.toList());\n// sortedNames: [Adam, Eve, Jane, John]\n\n// Custom order\nList&lt;String&gt; sortedByLength = names.stream()\n    .sorted(Comparator.comparing(String::length).thenComparing(Comparator.naturalOrder()))\n    .collect(Collectors.toList());\n// sortedByLength: [Eve, Adam, Jane, John]\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#peek","title":"peek <p>Allows operations to be performed on elements as they flow through a stream, mainly for debugging.</p> <pre><code>List&lt;String&gt; result = names.stream()\n    .filter(name -&gt; name.length() &gt; 3)\n    .peek(name -&gt; System.out.println(\"Filtered: \" + name))\n    .map(String::toUpperCase)\n    .peek(name -&gt; System.out.println(\"Mapped: \" + name))\n    .collect(Collectors.toList());\n\n// Output:\n// Filtered: John\n// Mapped: JOHN\n// Filtered: Jane\n// Mapped: JANE\n// Filtered: Adam\n// Mapped: ADAM\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#terminal-operations","title":"Terminal Operations","text":"<p>Terminal operations produce a result or side effect and cause the Stream pipeline to be executed.</p>"},{"location":"java/java-streams-lambdas/#reduction-operations","title":"Reduction Operations","text":""},{"location":"java/java-streams-lambdas/#reduce","title":"reduce <p>Combines elements into a single result.</p> <pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// Sum using reduce\nint sum = numbers.stream()\n    .reduce(0, (a, b) -&gt; a + b);\n// or\nint sum2 = numbers.stream()\n    .reduce(0, Integer::sum);\n// sum and sum2: 15\n\n// Finding maximum\nOptional&lt;Integer&gt; max = numbers.stream()\n    .reduce(Integer::max);\n// max.get(): 5\n\n// Concatenating strings\nString concatenated = Stream.of(\"a\", \"b\", \"c\")\n    .reduce(\"\", (a, b) -&gt; a + b);\n// concatenated: \"abc\"\n\n// More complex reduction\nint sumOfSquares = numbers.stream()\n    .reduce(0, (sum, num) -&gt; sum + num * num, Integer::sum);\n// sumOfSquares: 55 (1 + 4 + 9 + 16 + 25)\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#collection-operations","title":"Collection Operations","text":""},{"location":"java/java-streams-lambdas/#collect","title":"collect <p>Gathers elements into a collection or other data structure.</p> <pre><code>List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Adam\", \"Eve\");\n\n// Collecting to different collections\nList&lt;String&gt; namesList = names.stream()\n    .collect(Collectors.toList());\n\nSet&lt;String&gt; namesSet = names.stream()\n    .collect(Collectors.toSet());\n\n// Joining elements\nString joined = names.stream()\n    .collect(Collectors.joining(\", \"));\n// joined: \"John, Jane, Adam, Eve\"\n\n// Grouping\nMap&lt;Integer, List&lt;String&gt;&gt; groupedByLength = names.stream()\n    .collect(Collectors.groupingBy(String::length));\n// groupedByLength: {3=[Eve], 4=[John, Jane, Adam]}\n\n// Partitioning\nMap&lt;Boolean, List&lt;String&gt;&gt; partitioned = names.stream()\n    .collect(Collectors.partitioningBy(name -&gt; name.startsWith(\"J\")));\n// partitioned: {false=[Adam, Eve], true=[John, Jane]}\n\n// Statistics for numeric streams\nIntSummaryStatistics stats = names.stream()\n    .collect(Collectors.summarizingInt(String::length));\n// stats.getAverage(), stats.getSum(), stats.getMin(), stats.getMax(), stats.getCount()\n\n// Custom collector for calculating average length\nDouble averageLength = names.stream()\n    .collect(Collectors.averagingInt(String::length));\n// averageLength: 3.75\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#iteration-and-search-operations","title":"Iteration and Search Operations","text":""},{"location":"java/java-streams-lambdas/#foreach","title":"forEach <p>Performs an action on each element.</p> <pre><code>names.stream()\n    .forEach(System.out::println);\n\n// For parallel streams, forEachOrdered preserves the encounter order\nnames.parallelStream()\n    .forEachOrdered(System.out::println);\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#findfirst-findany","title":"findFirst, findAny <p>Find the first element or any element that matches.</p> <pre><code>Optional&lt;String&gt; first = names.stream()\n    .findFirst();\n// first.get(): \"John\"\n\nOptional&lt;String&gt; any = names.stream()\n    .findAny();\n// any.get(): could be any element, but typically \"John\" for sequential streams\n\n// Finding first element that matches a condition\nOptional&lt;String&gt; firstWithJ = names.stream()\n    .filter(name -&gt; name.startsWith(\"J\"))\n    .findFirst();\n// firstWithJ.get(): \"John\"\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#anymatch-allmatch-nonematch","title":"anyMatch, allMatch, noneMatch <p>Check if any, all, or no elements match a predicate.</p> <pre><code>boolean hasJ = names.stream()\n    .anyMatch(name -&gt; name.startsWith(\"J\"));\n// hasJ: true\n\nboolean allShort = names.stream()\n    .allMatch(name -&gt; name.length() &lt; 5);\n// allShort: true\n\nboolean noZ = names.stream()\n    .noneMatch(name -&gt; name.startsWith(\"Z\"));\n// noZ: true\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#count","title":"count <p>Counts the elements in the stream.</p> <pre><code>long count = names.stream()\n    .filter(name -&gt; name.contains(\"a\"))\n    .count();\n// count: 2 (Jane, Adam)\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#min-max","title":"min, max <p>Find the minimum or maximum element according to a comparator.</p> <pre><code>Optional&lt;String&gt; shortest = names.stream()\n    .min(Comparator.comparing(String::length));\n// shortest.get(): \"Eve\"\n\nOptional&lt;String&gt; alphabeticallyFirst = names.stream()\n    .min(String::compareTo);\n// alphabeticallyFirst.get(): \"Adam\"\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#toarray","title":"toArray <p>Converts the stream to an array.</p> <pre><code>String[] namesArray = names.stream()\n    .toArray(String[]::new);\n</code></pre>","text":""},{"location":"java/java-streams-lambdas/#optional-class","title":"Optional Class","text":"<p><code>Optional&lt;T&gt;</code> is a container object that may or may not contain a non-null value, helping to avoid <code>NullPointerException</code>.</p>"},{"location":"java/java-streams-lambdas/#creating-optionals","title":"Creating Optionals","text":"<pre><code>// Empty Optional\nOptional&lt;String&gt; empty = Optional.empty();\n\n// From a non-null value\nOptional&lt;String&gt; withValue = Optional.of(\"Hello\");\n\n// From a potentially null value\nString nullableValue = getValueThatMightBeNull();\nOptional&lt;String&gt; withNullable = Optional.ofNullable(nullableValue);\n</code></pre>"},{"location":"java/java-streams-lambdas/#checking-for-values","title":"Checking for Values","text":"<pre><code>Optional&lt;String&gt; optional = Optional.ofNullable(getValue());\n\n// Check if a value is present\nif (optional.isPresent()) {\n    System.out.println(\"Value: \" + optional.get());\n}\n\n// Check if empty\nif (optional.isEmpty()) { // Java 11+\n    System.out.println(\"No value present\");\n}\n</code></pre>"},{"location":"java/java-streams-lambdas/#working-with-optional-values","title":"Working with Optional Values","text":"<pre><code>Optional&lt;String&gt; optional = Optional.ofNullable(getValue());\n\n// Execute if present\noptional.ifPresent(value -&gt; System.out.println(\"Value: \" + value));\n\n// Get if present, otherwise return default\nString result = optional.orElse(\"Default\");\n\n// Get if present, otherwise compute default\nString computed = optional.orElseGet(() -&gt; computeDefault());\n\n// Get if present, otherwise throw exception\nString value = optional.orElseThrow(() -&gt; new NoSuchElementException(\"No value\"));\n\n// Transform if present\nOptional&lt;Integer&gt; length = optional.map(String::length);\n\n// Filter values\nOptional&lt;String&gt; filtered = optional.filter(s -&gt; s.length() &gt; 5);\n\n// FlatMap for when the mapping function returns an Optional\nOptional&lt;String&gt; upperCase = optional.flatMap(this::toUpperCaseOptional);\n</code></pre>"},{"location":"java/java-streams-lambdas/#example-stream-with-optional-results","title":"Example: Stream with Optional Results","text":"<pre><code>List&lt;Optional&lt;String&gt;&gt; optionals = Arrays.asList(\n    Optional.of(\"Hello\"),\n    Optional.empty(),\n    Optional.of(\"World\")\n);\n\n// Filter out empty Optionals and get the values\nList&lt;String&gt; filteredValues = optionals.stream()\n    .filter(Optional::isPresent)\n    .map(Optional::get)\n    .collect(Collectors.toList());\n// filteredValues: [Hello, World]\n\n// Using flatMap with Optional (Java 9+)\nList&lt;String&gt; flatMappedValues = optionals.stream()\n    .flatMap(Optional::stream)\n    .collect(Collectors.toList());\n// flatMappedValues: [Hello, World]\n</code></pre>"},{"location":"java/java-streams-lambdas/#parallel-streams","title":"Parallel Streams","text":"<p>Parallel streams distribute work across multiple threads for potential performance improvements.</p>"},{"location":"java/java-streams-lambdas/#creating-parallel-streams","title":"Creating Parallel Streams","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Method 1: From a sequential stream\nStream&lt;Integer&gt; parallelStream1 = numbers.stream().parallel();\n\n// Method 2: Directly from a collection\nStream&lt;Integer&gt; parallelStream2 = numbers.parallelStream();\n</code></pre>"},{"location":"java/java-streams-lambdas/#performance-considerations","title":"Performance Considerations","text":"<pre><code>// Example: Sum calculation\nlong start = System.currentTimeMillis();\n\n// Sequential sum\nlong sequentialSum = LongStream.rangeClosed(1, 100_000_000)\n    .sum();\n\nlong sequentialTime = System.currentTimeMillis() - start;\nSystem.out.println(\"Sequential sum: \" + sequentialTime + \" ms\");\n\n// Parallel sum\nstart = System.currentTimeMillis();\nlong parallelSum = LongStream.rangeClosed(1, 100_000_000)\n    .parallel()\n    .sum();\n\nlong parallelTime = System.currentTimeMillis() - start;\nSystem.out.println(\"Parallel sum: \" + parallelTime + \" ms\");\n</code></pre>"},{"location":"java/java-streams-lambdas/#maintaining-order","title":"Maintaining Order","text":"<pre><code>// Order is preserved by default, even in parallel streams\nList&lt;String&gt; orderedResult = names.parallelStream()\n    .sorted()\n    .collect(Collectors.toList());\n\n// For operations where order doesn't matter\nSet&lt;String&gt; unorderedResult = names.parallelStream()\n    .collect(Collectors.toSet());\n</code></pre>"},{"location":"java/java-streams-lambdas/#when-to-use-parallel-streams","title":"When to Use Parallel Streams","text":"<p>Good candidates for parallel streams: - Large datasets - Computationally intensive operations - Easily divisible problems - No shared mutable state</p> <p>Poor candidates: - Small datasets - Operations with dependencies - I/O-bound operations - Operations requiring order</p> <pre><code>// Good: Computationally intensive with large dataset\nList&lt;BigInteger&gt; results = LongStream.rangeClosed(1, 10_000)\n    .parallel()\n    .mapToObj(BigInteger::valueOf)\n    .map(n -&gt; n.pow(100000))\n    .collect(Collectors.toList());\n\n// Bad: Small dataset with simple operation\nList&lt;String&gt; upperCaseNames = names.parallelStream() // Overhead likely exceeds benefit\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n</code></pre>"},{"location":"java/java-streams-lambdas/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Prefer method references over lambdas when possible <pre><code>// Good\nlist.stream().map(String::toUpperCase);\n\n// Less concise\nlist.stream().map(s -&gt; s.toUpperCase());\n</code></pre></p> </li> <li> <p>Use specialized stream types for primitives <pre><code>// Better performance\nIntStream.range(1, 100).sum();\n\n// Boxing/unboxing overhead\nStream.iterate(1, n -&gt; n + 1).limit(99).mapToInt(Integer::intValue).sum();\n</code></pre></p> </li> <li> <p>Consider the right collector for the job <pre><code>// Collecting to the right data structure matters\nMap&lt;Boolean, List&lt;Person&gt;&gt; peopleByGender = people.stream()\n    .collect(Collectors.partitioningBy(Person::isMale));\n</code></pre></p> </li> <li> <p>Avoid side effects in stream operations <pre><code>// Bad: Side effects in lambda\nList&lt;String&gt; results = new ArrayList&lt;&gt;();\nstream.forEach(item -&gt; results.add(item.toUpperCase())); // Mutation!\n\n// Good: No side effects\nList&lt;String&gt; results = stream.map(String::toUpperCase)\n                            .collect(Collectors.toList());\n</code></pre></p> </li> <li> <p>Choose streams for functional operations, loops for imperative code <pre><code>// Good use of streams for functional transformation\nList&lt;String&gt; upperCaseNames = names.stream()\n                                 .map(String::toUpperCase)\n                                 .collect(Collectors.toList());\n\n// Better as a for loop if doing imperative operations\nfor (String name : names) {\n    System.out.println(\"Processing: \" + name);\n    // Complex imperative logic...\n}\n</code></pre></p> </li> <li> <p>Use parallel streams judiciously <pre><code>// Only parallelize when it makes sense\nStream&lt;String&gt; parallelStream = hugeList.parallelStream();\n</code></pre></p> </li> <li> <p>Limit the use of distinct() on large streams <pre><code>// Can be memory-intensive on large streams\nStream&lt;String&gt; uniqueItems = hugeStream.distinct();\n</code></pre></p> </li> <li> <p>Break down complex operations <pre><code>// Hard to read and debug\nresult = people.stream()\n    .filter(p -&gt; p.getAge() &gt; 20)\n    .map(Person::getName)\n    .filter(name -&gt; name.startsWith(\"A\"))\n    .map(String::toUpperCase)\n    .sorted()\n    .collect(Collectors.joining(\", \"));\n\n// More readable when broken down\nStream&lt;Person&gt; adultsStream = people.stream()\n    .filter(p -&gt; p.getAge() &gt; 20);\nStream&lt;String&gt; namesStream = adultsStream.map(Person::getName);\nStream&lt;String&gt; filteredNamesStream = namesStream.filter(name -&gt; name.startsWith(\"A\"));\nStream&lt;String&gt; processedNamesStream = filteredNamesStream.map(String::toUpperCase)\n                                                      .sorted();\nresult = processedNamesStream.collect(Collectors.joining(\", \"));\n</code></pre></p> </li> <li> <p>Use Optional properly <pre><code>// Don't do this\nOptional&lt;String&gt; result = getOptionalString();\nif (result.isPresent()) {\n    return result.get();\n} else {\n    return \"default\";\n}\n\n// Do this instead\nreturn getOptionalString().orElse(\"default\");\n</code></pre></p> </li> <li> <p>Understand lazy evaluation <pre><code>// This doesn't print anything yet (lazy)\nStream&lt;String&gt; stream = names.stream()\n    .filter(name -&gt; {\n        System.out.println(\"Filtering: \" + name);\n        return name.startsWith(\"J\");\n    })\n    .map(name -&gt; {\n        System.out.println(\"Mapping: \" + name);\n        return name.toUpperCase();\n    });\n\n// This triggers evaluation\nList&lt;String&gt; result = stream.collect(Collectors.toList());\n</code></pre></p> </li> </ol>"},{"location":"java/java-streams-lambdas/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"java/java-streams-lambdas/#1-reusing-streams","title":"1. Reusing Streams","text":"<p>Problem: A stream can only be consumed once.</p> <pre><code>Stream&lt;String&gt; stream = names.stream();\nstream.forEach(System.out::println);\n// This will fail with IllegalStateException\nstream.filter(name -&gt; name.startsWith(\"J\")).forEach(System.out::println);\n</code></pre> <p>Solution: Create a new stream when needed. <pre><code>names.stream().forEach(System.out::println);\nnames.stream().filter(name -&gt; name.startsWith(\"J\")).forEach(System.out::println);\n</code></pre></p>"},{"location":"java/java-streams-lambdas/#2-side-effects-in-lambdas","title":"2. Side Effects in Lambdas","text":"<p>Problem: Modifying variables from lambda expressions can cause unexpected behavior.</p> <pre><code>// Avoid this!\nList&lt;String&gt; filteredList = new ArrayList&lt;&gt;();\nnames.stream().filter(name -&gt; {\n    if (name.startsWith(\"J\")) {\n        filteredList.add(name); // Side effect!\n        return false;\n    }\n    return true;\n}).forEach(System.out::println);\n</code></pre> <p>Solution: Use proper stream methods. <pre><code>List&lt;String&gt; startsWithJ = names.stream()\n    .filter(name -&gt; name.startsWith(\"J\"))\n    .collect(Collectors.toList());\n\nList&lt;String&gt; doesNotStartWithJ = names.stream()\n    .filter(name -&gt; !name.startsWith(\"J\"))\n    .collect(Collectors.toList());\n</code></pre></p>"},{"location":"java/java-streams-lambdas/#3-ignoring-return-values-of-stream-operations","title":"3. Ignoring Return Values of Stream Operations","text":"<p>Problem: Stream operations return new streams that must be captured.</p> <pre><code>// This doesn't modify the original stream\nnames.stream().filter(name -&gt; name.startsWith(\"J\"));\n// No terminal operation, nothing happens\n</code></pre> <p>Solution: Capture the result and use a terminal operation. <pre><code>List&lt;String&gt; filtered = names.stream()\n    .filter(name -&gt; name.startsWith(\"J\"))\n    .collect(Collectors.toList());\n</code></pre></p>"},{"location":"java/java-streams-lambdas/#4-misunderstanding-parallel-stream-behavior","title":"4. Misunderstanding Parallel Stream Behavior","text":"<p>Problem: Parallel streams don't always improve performance and can cause issues with stateful operations.</p> <pre><code>// May not be faster, adds thread coordination overhead\nList&lt;String&gt; result = smallList.parallelStream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n\n// Problematic: stateful operation with shared mutable state\nList&lt;String&gt; collected = new ArrayList&lt;&gt;();\nnames.parallelStream().forEach(collected::add); // Order not guaranteed, potential thread safety issues\n</code></pre> <p>Solution: Use parallel streams only when appropriate and ensure thread safety. <pre><code>// For stateful operations, use a concurrent collection or proper collector\nList&lt;String&gt; collected = names.parallelStream()\n    .collect(Collectors.toList()); // Thread-safe collection operation\n</code></pre></p>"},{"location":"java/java-streams-lambdas/#5-incorrect-use-of-optional","title":"5. Incorrect Use of Optional","text":"<p>Problem: Using Optional incorrectly negates its benefits.</p> <pre><code>// Don't do this\nOptional&lt;String&gt; opt = findName();\nif (opt.isPresent()) {\n    String name = opt.get();\n    // Use name\n} else {\n    // Handle empty case\n}\n\n// Even worse\nString name = findName().get(); // May throw NoSuchElementException\n</code></pre> <p>Solution: Use Optional's methods. <pre><code>findName().ifPresent(name -&gt; {\n    // Use name\n});\n\nString name = findName().orElse(\"Default\");\n\nfindName().ifPresentOrElse(\n    name -&gt; { /* Use name */ },\n    () -&gt; { /* Handle empty case */ }\n);\n</code></pre></p>"},{"location":"java/java-streams-lambdas/#6-memory-issues-with-large-streams","title":"6. Memory Issues with Large Streams","text":"<p>Problem: Some operations can consume large amounts of memory.</p> <pre><code>// This loads all elements into memory for sorting\nList&lt;String&gt; sorted = hugeStream.sorted().collect(Collectors.toList());\n\n// This keeps all elements in memory for distinct operation\nList&lt;String&gt; unique = hugeStream.distinct().collect(Collectors.toList());\n</code></pre> <p>Solution: Process data in chunks or use appropriate data structures. <pre><code>// Process in batches\nAtomicInteger counter = new AtomicInteger();\nList&lt;List&lt;String&gt;&gt; batches = hugeStream\n    .collect(Collectors.groupingBy(item -&gt; counter.getAndIncrement() / BATCH_SIZE))\n    .values()\n    .stream()\n    .collect(Collectors.toList());\n\n// For distinct elements, consider using a Set if appropriate\nSet&lt;String&gt; uniqueItems = hugeStream.collect(Collectors.toSet());\n</code></pre></p>"},{"location":"java/java-streams-lambdas/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ol> <li>Official Documentation:</li> <li>Java Stream API Documentation</li> <li>Java Lambda Expressions</li> <li> <p>java.util.function Package</p> </li> <li> <p>Books:</p> </li> <li>\"Java 8 in Action\" by Raoul-Gabriel Urma, Mario Fusco, and Alan Mycroft</li> <li>\"Modern Java in Action\" (updated version of the above for Java 9+)</li> <li>\"Effective Java\" by Joshua Bloch (chapter on lambdas and streams)</li> <li> <p>\"Functional Programming in Java\" by Venkat Subramaniam</p> </li> <li> <p>Online Resources:</p> </li> <li>Baeldung's Java 8 Streams Tutorial</li> <li>Oracle's Lambda Expressions Tutorial</li> <li> <p>DZone's Java Streams Reference Guide</p> </li> <li> <p>Practice Platforms:</p> </li> <li>Coding Exercises on Java 8 Streams</li> <li>Java 8 Stream API Exercises on GitHub</li> </ol>"},{"location":"java/java-streams-lambdas/#practice-exercises","title":"Practice Exercises","text":"<ol> <li> <p>Basic Stream Operations:    Transform a list of strings to uppercase, filter those starting with 'A', and collect to a list.</p> </li> <li> <p>Grouping and Partitioning:    Given a list of people with age and gender, group them by age decades and gender.</p> </li> <li> <p>Numeric Streams:    Calculate statistics (min, max, average, sum) for a list of product prices.</p> </li> <li> <p>Collectors:    Use various collectors to transform a list of transactions into meaningful summaries.</p> </li> <li> <p>Parallel Stream Performance:    Compare performance of sequential and parallel streams for CPU-intensive operations.</p> </li> <li> <p>Composing Lambdas:    Create composite functions by combining multiple lambdas.</p> </li> <li> <p>Optional Handling:    Implement a chain of optional operations to safely navigate a complex object graph.</p> </li> <li> <p>Custom Collectors:    Create a custom collector to perform a specific aggregation operation not covered by standard collectors.</p> </li> <li> <p>Stream Generator:    Generate Fibonacci sequence using Stream.iterate.</p> </li> <li> <p>Real-world Application:     Process a large dataset (like CSV file) using streams for filtering, transformation, and aggregation. </p> </li> </ol>"},{"location":"java/java-testing/","title":"Java Testing","text":""},{"location":"java/java-testing/#overview","title":"Overview","text":"<p>Java Testing is a critical aspect of software development that ensures code quality, reliability, and correctness. Testing in Java encompasses a wide range of techniques and frameworks, from simple unit tests to complex integration and system tests. Effective testing reduces bugs, improves code design, facilitates refactoring, and provides documentation for how code should behave. This guide explores the comprehensive landscape of Java testing, focusing on both theoretical concepts and practical implementations using popular Java testing frameworks and tools.</p>"},{"location":"java/java-testing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Java programming knowledge</li> <li>Understanding of object-oriented programming concepts</li> <li>Familiarity with build tools (Maven/Gradle)</li> <li>Basic knowledge of software development lifecycle</li> </ul>"},{"location":"java/java-testing/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the fundamentals of software testing</li> <li>Master unit testing with JUnit and TestNG</li> <li>Learn mocking techniques with Mockito and other frameworks</li> <li>Implement test-driven development (TDD) practices</li> <li>Create effective integration tests</li> <li>Understand code coverage and quality metrics</li> <li>Explore performance and load testing techniques</li> <li>Implement automated testing practices</li> <li>Use specialized testing tools and frameworks</li> <li>Apply testing best practices in real-world Java applications</li> </ul>"},{"location":"java/java-testing/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Testing Fundamentals</li> <li>Unit Testing with JUnit</li> <li>Unit Testing with TestNG</li> <li>Mocking Frameworks</li> <li>Test-Driven Development (TDD)</li> <li>Behavior-Driven Development (BDD)</li> <li>Integration Testing</li> <li>Code Coverage</li> <li>Performance Testing</li> <li>Test Automation</li> <li>Testing Web Applications</li> <li>Testing Best Practices</li> <li>Common Testing Pitfalls</li> <li>Advanced Testing Techniques</li> </ol>"},{"location":"java/java-testing/#testing-fundamentals","title":"Testing Fundamentals","text":"<p>Testing is a systematic process of evaluating software to detect differences between actual and expected behaviors. Proper testing ensures software quality and reliability.</p>"},{"location":"java/java-testing/#types-of-tests","title":"Types of Tests","text":""},{"location":"java/java-testing/#based-on-scope","title":"Based on Scope","text":"<ul> <li>Unit Tests: Test individual components or methods in isolation</li> <li>Integration Tests: Test interactions between components</li> <li>System Tests: Test the complete application</li> <li>Acceptance Tests: Validate the application meets business requirements</li> </ul>"},{"location":"java/java-testing/#based-on-knowledge-of-internal-structure","title":"Based on Knowledge of Internal Structure","text":"<ul> <li>Black-box Testing: Tests functionality without knowing internal code</li> <li>White-box Testing: Tests with knowledge of internal code</li> <li>Gray-box Testing: Combines both approaches</li> </ul>"},{"location":"java/java-testing/#based-on-purpose","title":"Based on Purpose","text":"<ul> <li>Functional Testing: Tests what the system does</li> <li>Non-functional Testing: Tests how well the system performs (performance, usability, etc.)</li> <li>Regression Testing: Ensures new changes don't break existing functionality</li> <li>Smoke Testing: Basic tests to ensure core functionality works</li> </ul>"},{"location":"java/java-testing/#testing-principles","title":"Testing Principles","text":"<ol> <li>Testing shows the presence of defects, not their absence</li> <li>Exhaustive testing is impossible</li> <li>Early testing saves time and money</li> <li>Defects cluster together</li> <li>Tests should be repeatable and reusable</li> <li>Testing is context dependent</li> <li>Absence-of-errors is a fallacy</li> </ol>"},{"location":"java/java-testing/#the-testing-pyramid","title":"The Testing Pyramid","text":"<p>The testing pyramid represents the ideal distribution of tests in a project:</p> <pre><code>     /\\\n    /  \\\n   /    \\\n  / UI   \\\n /        \\\n/Integration\\\n/____________\\\n/   Unit Tests \\\n/________________\\\n</code></pre> <ul> <li>Unit Tests: Form the base - many small, fast tests</li> <li>Integration Tests: Middle layer - fewer, slightly slower tests</li> <li>UI/End-to-End Tests: Top layer - fewest, slowest tests</li> </ul>"},{"location":"java/java-testing/#test-case-design","title":"Test Case Design","text":"<p>A well-designed test case includes:</p> <ol> <li>Test ID and Name: Unique identifier</li> <li>Objective: What is being tested</li> <li>Preconditions: Setup required before execution</li> <li>Test Steps: Actions to perform</li> <li>Expected Results: What should happen</li> <li>Actual Results: What actually happened</li> <li>Pass/Fail Status: Test outcome</li> </ol>"},{"location":"java/java-testing/#test-fixtures","title":"Test Fixtures","text":"<p>Test fixtures provide a consistent environment for tests:</p> <ul> <li>Setup: Prepare the test environment (runs before each test)</li> <li>Teardown: Clean up after tests (runs after each test)</li> <li>BeforeAll/AfterAll: Run once before/after all tests in a class</li> </ul>"},{"location":"java/java-testing/#unit-testing-with-junit","title":"Unit Testing with JUnit","text":"<p>JUnit is the most widely used testing framework for Java applications. It provides annotations, assertions, and runners to create and execute tests.</p>"},{"location":"java/java-testing/#junit-5-architecture","title":"JUnit 5 Architecture","text":"<p>JUnit 5 consists of three main components:</p> <ol> <li>JUnit Platform: Foundation for test execution</li> <li>JUnit Jupiter: New programming model for writing tests</li> <li>JUnit Vintage: Support for running JUnit 3/4 tests</li> </ol>"},{"location":"java/java-testing/#setting-up-junit","title":"Setting Up JUnit","text":""},{"location":"java/java-testing/#maven-dependency","title":"Maven Dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n    &lt;version&gt;5.9.2&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#gradle-dependency","title":"Gradle Dependency","text":"<pre><code>testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'\ntestRuntimeOnly 'org.junit.platform:junit-platform-launcher'\n</code></pre>"},{"location":"java/java-testing/#basic-test-structure","title":"Basic Test Structure","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class CalculatorTest {\n\n    @Test\n    void addition() {\n        Calculator calculator = new Calculator();\n        assertEquals(5, calculator.add(2, 3), \"2 + 3 should equal 5\");\n    }\n\n    @Test\n    void division() {\n        Calculator calculator = new Calculator();\n        assertEquals(2, calculator.divide(6, 3), \"6 / 3 should equal 2\");\n    }\n\n    @Test\n    void divisionByZero() {\n        Calculator calculator = new Calculator();\n        assertThrows(ArithmeticException.class, () -&gt; {\n            calculator.divide(1, 0);\n        }, \"Division by zero should throw ArithmeticException\");\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#junit-annotations","title":"JUnit Annotations","text":"<ul> <li>@Test: Identifies a test method</li> <li>@BeforeEach: Executed before each test</li> <li>@AfterEach: Executed after each test</li> <li>@BeforeAll: Executed once before all tests (must be static)</li> <li>@AfterAll: Executed once after all tests (must be static)</li> <li>@Disabled: Disables a test</li> <li>@DisplayName: Provides a custom name for the test</li> <li>@ParameterizedTest: Runs a test multiple times with different arguments</li> <li>@Timeout: Fails a test if it exceeds a time limit</li> <li>@Tag: Categorizes tests for selective execution</li> </ul>"},{"location":"java/java-testing/#example-with-lifecycle-methods","title":"Example with Lifecycle Methods","text":"<pre><code>import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\n@DisplayName(\"Calculator Test Suite\")\npublic class CalculatorTest {\n\n    private Calculator calculator;\n\n    @BeforeAll\n    static void setUpAll() {\n        System.out.println(\"Initializing test suite\");\n    }\n\n    @BeforeEach\n    void setUp() {\n        System.out.println(\"Initializing test\");\n        calculator = new Calculator();\n    }\n\n    @Test\n    @DisplayName(\"Testing addition\")\n    void testAddition() {\n        assertEquals(5, calculator.add(2, 3), \"2 + 3 should equal 5\");\n    }\n\n    @Test\n    @DisplayName(\"Testing subtraction\")\n    void testSubtraction() {\n        assertEquals(1, calculator.subtract(3, 2), \"3 - 2 should equal 1\");\n    }\n\n    @AfterEach\n    void tearDown() {\n        System.out.println(\"Test completed\");\n    }\n\n    @AfterAll\n    static void tearDownAll() {\n        System.out.println(\"Test suite completed\");\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#assertions","title":"Assertions","text":"<p>JUnit provides a variety of assertion methods:</p> <ul> <li>assertEquals(expected, actual): Tests if two values are equal</li> <li>assertTrue(condition): Tests if a condition is true</li> <li>assertFalse(condition): Tests if a condition is false</li> <li>assertNull(object): Tests if an object is null</li> <li>assertNotNull(object): Tests if an object is not null</li> <li>assertSame(expected, actual): Tests if two objects reference the same object</li> <li>assertNotSame(expected, actual): Tests if two objects don't reference the same object</li> <li>assertThrows(exceptionClass, executable): Tests if code throws an exception</li> <li>assertAll(executables...): Groups multiple assertions</li> <li>fail(message): Fails a test with the given message</li> </ul>"},{"location":"java/java-testing/#parameterized-tests","title":"Parameterized Tests","text":"<p>Run the same test with different parameters:</p> <pre><code>import org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ParameterizedCalculatorTest {\n\n    @ParameterizedTest\n    @CsvSource({\n        \"1, 1, 2\",\n        \"2, 3, 5\",\n        \"10, 15, 25\",\n        \"0, 0, 0\"\n    })\n    void testAddition(int a, int b, int expected) {\n        Calculator calculator = new Calculator();\n        assertEquals(expected, calculator.add(a, b),\n                () -&gt; a + \" + \" + b + \" should equal \" + expected);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2, 3, 4})\n    void testIsEven(int number) {\n        Calculator calculator = new Calculator();\n        assertEquals(number % 2 == 0, calculator.isEven(number));\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = MathOperation.class, names = {\"ADD\", \"SUBTRACT\", \"MULTIPLY\"})\n    void testSupportedOperations(MathOperation operation) {\n        Calculator calculator = new Calculator();\n        assertTrue(calculator.supportsOperation(operation));\n    }\n} \n</code></pre>"},{"location":"java/java-testing/#unit-testing-with-testng","title":"Unit Testing with TestNG","text":"<p>TestNG is a testing framework inspired by JUnit but with additional features designed to make testing more powerful and easier.</p>"},{"location":"java/java-testing/#setting-up-testng","title":"Setting Up TestNG","text":""},{"location":"java/java-testing/#maven-dependency_1","title":"Maven Dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.testng&lt;/groupId&gt;\n    &lt;artifactId&gt;testng&lt;/artifactId&gt;\n    &lt;version&gt;7.7.1&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#gradle-dependency_1","title":"Gradle Dependency","text":"<pre><code>testImplementation 'org.testng:testng:7.7.1'\n</code></pre>"},{"location":"java/java-testing/#basic-testng-test","title":"Basic TestNG Test","text":"<pre><code>import org.testng.annotations.*;\nimport static org.testng.Assert.*;\n\npublic class CalculatorTestNG {\n\n    private Calculator calculator;\n\n    @BeforeMethod\n    public void setUp() {\n        calculator = new Calculator();\n    }\n\n    @Test\n    public void testAddition() {\n        assertEquals(calculator.add(2, 3), 5, \"2 + 3 should equal 5\");\n    }\n\n    @Test\n    public void testDivision() {\n        assertEquals(calculator.divide(6, 3), 2, \"6 / 3 should equal 2\");\n    }\n\n    @Test(expectedExceptions = ArithmeticException.class)\n    public void testDivisionByZero() {\n        calculator.divide(1, 0);\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#key-testng-features","title":"Key TestNG Features","text":""},{"location":"java/java-testing/#test-groups","title":"Test Groups","text":"<pre><code>import org.testng.annotations.*;\nimport static org.testng.Assert.*;\n\npublic class UserServiceTest {\n\n    @Test(groups = {\"fast\", \"unit\"})\n    public void testUserCreation() {\n        // Fast unit test\n    }\n\n    @Test(groups = {\"slow\", \"integration\"})\n    public void testUserDatabaseInteraction() {\n        // Slow integration test\n    }\n\n    @Test(groups = {\"unit\", \"security\"})\n    public void testUserAuthentication() {\n        // Security-related unit test\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#running-specific-groups","title":"Running specific groups:","text":"<pre><code>&lt;test name=\"Unit Tests\"&gt;\n    &lt;groups&gt;\n        &lt;run&gt;\n            &lt;include name=\"unit\"/&gt;\n            &lt;exclude name=\"slow\"/&gt;\n        &lt;/run&gt;\n    &lt;/groups&gt;\n    &lt;classes&gt;\n        &lt;class name=\"com.example.UserServiceTest\"/&gt;\n    &lt;/classes&gt;\n&lt;/test&gt;\n</code></pre>"},{"location":"java/java-testing/#dependent-tests","title":"Dependent Tests","text":"<pre><code>@Test\npublic void testDatabaseConnection() {\n    // Test database connection\n    assertTrue(database.isConnected());\n}\n\n@Test(dependsOnMethods = {\"testDatabaseConnection\"})\npublic void testUserRetrieval() {\n    // This test only runs if testDatabaseConnection passes\n    User user = database.getUser(1);\n    assertNotNull(user);\n}\n</code></pre>"},{"location":"java/java-testing/#data-providers","title":"Data Providers","text":"<pre><code>@DataProvider(name = \"additionData\")\npublic Object[][] createAdditionData() {\n    return new Object[][] {\n        {1, 1, 2},\n        {2, 3, 5},\n        {10, 15, 25},\n        {-1, 1, 0}\n    };\n}\n\n@Test(dataProvider = \"additionData\")\npublic void testAddition(int a, int b, int expected) {\n    assertEquals(calculator.add(a, b), expected);\n}\n</code></pre>"},{"location":"java/java-testing/#parallel-execution","title":"Parallel Execution","text":"<pre><code>@Test(threadPoolSize = 3, invocationCount = 10, timeOut = 1000)\npublic void testConcurrent() {\n    // This test will be executed 10 times with 3 threads\n    assertTrue(calculator.isPrime(31));\n}\n</code></pre>"},{"location":"java/java-testing/#junit-vs-testng","title":"JUnit vs TestNG","text":"Feature JUnit 5 TestNG Annotations @Test, @BeforeEach, @AfterEach, etc. @Test, @BeforeMethod, @AfterMethod, etc. Parameterization @ParameterizedTest with providers @Test with @DataProvider Grouping @Tag groups attribute Dependencies Limited Comprehensive Parallelism Supported via extensions Built-in support Exception Testing assertThrows() expectedExceptions attribute Timeout @Timeout timeOut attribute Assumptions assumeTrue(), etc. Needs custom implementation Extensions Extension API Listeners and reporters"},{"location":"java/java-testing/#mocking-frameworks","title":"Mocking Frameworks","text":"<p>Mocking frameworks allow you to create test doubles for dependencies to isolate the code under test.</p>"},{"location":"java/java-testing/#types-of-test-doubles","title":"Types of Test Doubles","text":"<ol> <li>Dummy: Objects passed around but never used</li> <li>Fake: Working implementations with shortcuts (e.g., in-memory database)</li> <li>Stub: Provide canned answers to calls</li> <li>Spy: Partial mocks that track actual interactions</li> <li>Mock: Objects pre-programmed with expectations and verification</li> </ol>"},{"location":"java/java-testing/#mockito","title":"Mockito","text":"<p>Mockito is the most popular mocking framework for Java.</p>"},{"location":"java/java-testing/#setting-up-mockito","title":"Setting Up Mockito","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mockito&lt;/groupId&gt;\n    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;\n    &lt;version&gt;5.2.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;!-- For JUnit 5 integration --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mockito&lt;/groupId&gt;\n    &lt;artifactId&gt;mockito-junit-jupiter&lt;/artifactId&gt;\n    &lt;version&gt;5.2.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#basic-mocking","title":"Basic Mocking","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @Test\n    void testGetUser() {\n        // Arrange\n        User expectedUser = new User(1, \"John\");\n        when(userRepository.findById(1)).thenReturn(expectedUser);\n\n        UserService userService = new UserService(userRepository);\n\n        // Act\n        User actualUser = userService.getUserById(1);\n\n        // Assert\n        assertEquals(expectedUser, actualUser);\n        verify(userRepository).findById(1);\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#stubbing-methods","title":"Stubbing Methods","text":"<pre><code>// Return value\nwhen(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n// Throw exception\nwhen(userRepository.findById(999)).thenThrow(new UserNotFoundException());\n\n// Return different values on consecutive calls\nwhen(iterator.next())\n    .thenReturn(\"first\")\n    .thenReturn(\"second\")\n    .thenReturn(\"third\");\n\n// Do something when method is called\ndoAnswer(invocation -&gt; {\n    Object[] args = invocation.getArguments();\n    User user = (User) args[0];\n    user.setActive(true);\n    return null;\n}).when(userRepository).save(any(User.class));\n</code></pre>"},{"location":"java/java-testing/#verifying-interactions","title":"Verifying Interactions","text":"<pre><code>// Verify method was called\nverify(userRepository).save(any(User.class));\n\n// Verify method was never called\nverify(userRepository, never()).delete(any(User.class));\n\n// Verify method was called exactly n times\nverify(userRepository, times(2)).findAll();\n\n// Verify no more interactions\nverifyNoMoreInteractions(userRepository);\n\n// Verify order of calls\nInOrder inOrder = inOrder(userRepository, emailService);\ninOrder.verify(userRepository).findById(1);\ninOrder.verify(emailService).sendWelcomeEmail(any(User.class));\n</code></pre>"},{"location":"java/java-testing/#argument-matchers","title":"Argument Matchers","text":"<pre><code>// Any value of specific type\nwhen(userRepository.findById(anyInt())).thenReturn(new User());\n\n// Specific value\nwhen(userRepository.findByUsername(eq(\"admin\"))).thenReturn(new User());\n\n// Complex matcher\nwhen(userRepository.findByAgeGreaterThan(argThat(arg -&gt; arg &gt; 18))).thenReturn(userList);\n</code></pre>"},{"location":"java/java-testing/#spying-on-real-objects","title":"Spying on Real Objects","text":"<pre><code>@Test\nvoid testSpy() {\n    List&lt;String&gt; realList = new ArrayList&lt;&gt;();\n    List&lt;String&gt; spyList = spy(realList);\n\n    // Real method calls are used by default\n    spyList.add(\"one\");\n    spyList.add(\"two\");\n\n    assertEquals(2, spyList.size());\n\n    // Can stub specific methods\n    when(spyList.size()).thenReturn(100);\n    assertEquals(100, spyList.size());\n\n    // Original list is affected\n    assertEquals(2, realList.size());\n}\n</code></pre>"},{"location":"java/java-testing/#alternative-mocking-frameworks","title":"Alternative Mocking Frameworks","text":""},{"location":"java/java-testing/#easymock","title":"EasyMock","text":"<pre><code>import org.easymock.*;\nimport org.junit.jupiter.api.*;\n\nimport static org.easymock.EasyMock.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class EasyMockTest {\n\n    @Test\n    void testWithEasyMock() {\n        // Create mock\n        UserRepository mockRepository = createMock(UserRepository.class);\n\n        // Set expectations\n        expect(mockRepository.findById(1)).andReturn(new User(1, \"John\"));\n        replay(mockRepository);\n\n        // Use mock\n        UserService service = new UserService(mockRepository);\n        User user = service.getUserById(1);\n\n        // Verify\n        assertEquals(\"John\", user.getName());\n        verify(mockRepository);\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#powermock","title":"PowerMock","text":"<p>For mocking static methods, final classes, and private methods:</p> <pre><code>@RunWith(PowerMockRunner.class)\n@PrepareForTest({StaticUtility.class})\npublic class PowerMockTest {\n\n    @Test\n    public void testStaticMethod() {\n        // Mock static method\n        PowerMockito.mockStatic(StaticUtility.class);\n        when(StaticUtility.calculateSomething()).thenReturn(42);\n\n        // Use and verify\n        assertEquals(42, StaticUtility.calculateSomething());\n        PowerMockito.verifyStatic(StaticUtility.class);\n        StaticUtility.calculateSomething();\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#test-driven-development-tdd","title":"Test-Driven Development (TDD)","text":"<p>Test-Driven Development is a software development approach where tests are written before the actual code.</p>"},{"location":"java/java-testing/#the-tdd-cycle","title":"The TDD Cycle","text":"<ol> <li>Red: Write a failing test</li> <li>Green: Write the simplest code to make the test pass</li> <li>Refactor: Improve the code without changing functionality</li> </ol>"},{"location":"java/java-testing/#tdd-example","title":"TDD Example","text":""},{"location":"java/java-testing/#step-1-write-a-failing-test","title":"Step 1: Write a failing test","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StringCalculatorTest {\n\n    @Test\n    void emptyStringReturnsZero() {\n        StringCalculator calculator = new StringCalculator();\n        assertEquals(0, calculator.add(\"\"), \"Empty string should return 0\");\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#step-2-make-the-test-pass","title":"Step 2: Make the test pass","text":"<pre><code>public class StringCalculator {\n\n    public int add(String numbers) {\n        return 0;\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#step-3-add-another-test","title":"Step 3: Add another test","text":"<pre><code>@Test\nvoid singleNumberReturnsValue() {\n    StringCalculator calculator = new StringCalculator();\n    assertEquals(1, calculator.add(\"1\"), \"String with single number should return the number\");\n    assertEquals(5, calculator.add(\"5\"), \"String with single number should return the number\");\n}\n</code></pre>"},{"location":"java/java-testing/#step-4-update-implementation","title":"Step 4: Update implementation","text":"<pre><code>public int add(String numbers) {\n    if (numbers.isEmpty()) {\n        return 0;\n    }\n    return Integer.parseInt(numbers);\n}\n</code></pre>"},{"location":"java/java-testing/#step-5-add-test-for-multiple-numbers","title":"Step 5: Add test for multiple numbers","text":"<pre><code>@Test\nvoid twoNumbersReturnSum() {\n    StringCalculator calculator = new StringCalculator();\n    assertEquals(3, calculator.add(\"1,2\"), \"String with two numbers should return their sum\");\n    assertEquals(8, calculator.add(\"3,5\"), \"String with two numbers should return their sum\");\n}\n</code></pre>"},{"location":"java/java-testing/#step-6-update-implementation-again","title":"Step 6: Update implementation again","text":"<pre><code>public int add(String numbers) {\n    if (numbers.isEmpty()) {\n        return 0;\n    }\n\n    String[] parts = numbers.split(\",\");\n    if (parts.length == 1) {\n        return Integer.parseInt(parts[0]);\n    }\n\n    return Integer.parseInt(parts[0]) + Integer.parseInt(parts[1]);\n}\n</code></pre>"},{"location":"java/java-testing/#step-7-refactor-for-any-number-of-values","title":"Step 7: Refactor for any number of values","text":"<pre><code>@Test\nvoid anyNumberOfValuesReturnsSum() {\n    StringCalculator calculator = new StringCalculator();\n    assertEquals(6, calculator.add(\"1,2,3\"), \"Should handle any number of values\");\n    assertEquals(15, calculator.add(\"1,2,3,4,5\"), \"Should handle any number of values\");\n}\n</code></pre>"},{"location":"java/java-testing/#step-8-final-implementation","title":"Step 8: Final implementation","text":"<pre><code>public int add(String numbers) {\n    if (numbers.isEmpty()) {\n        return 0;\n    }\n\n    String[] parts = numbers.split(\",\");\n    int sum = 0;\n    for (String part : parts) {\n        sum += Integer.parseInt(part);\n    }\n\n    return sum;\n}\n</code></pre>"},{"location":"java/java-testing/#benefits-of-tdd","title":"Benefits of TDD","text":"<ol> <li>Improved design: Code is naturally more modular and testable</li> <li>Better understanding of requirements: Tests serve as specifications</li> <li>Faster debugging: Issues are detected earlier</li> <li>Regression safety: Existing tests catch regressions</li> <li>Documentation: Tests document expected behavior</li> <li>Confidence: Higher confidence in code changes</li> </ol>"},{"location":"java/java-testing/#behavior-driven-development-bdd","title":"Behavior-Driven Development (BDD)","text":"<p>Behavior-Driven Development extends TDD by focusing on the behavior of the application from the user's perspective rather than implementation details. It uses natural language constructs to express tests in a way that non-technical stakeholders can understand.</p>"},{"location":"java/java-testing/#bdd-frameworks-for-java","title":"BDD Frameworks for Java","text":""},{"location":"java/java-testing/#cucumber","title":"Cucumber","text":"<p>Cucumber allows specification of application behavior in plain text and supports multiple languages through Gherkin syntax.</p>"},{"location":"java/java-testing/#maven-dependency_2","title":"Maven Dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.cucumber&lt;/groupId&gt;\n    &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;\n    &lt;version&gt;7.11.2&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.cucumber&lt;/groupId&gt;\n    &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;\n    &lt;version&gt;7.11.2&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#feature-file-example-srctestresourcesfeaturescalculatorfeature","title":"Feature File Example (src/test/resources/features/calculator.feature)","text":"<pre><code>Feature: Calculator\n  As a user\n  I want to use a calculator\n  So that I can perform basic arithmetic operations\n\n  Scenario: Addition\n    Given I have a calculator\n    When I add 2 and 3\n    Then the result should be 5\n\n  Scenario Outline: Multiple additions\n    Given I have a calculator\n    When I add &lt;num1&gt; and &lt;num2&gt;\n    Then the result should be &lt;total&gt;\n\n    Examples:\n      | num1 | num2 | total |\n      | 1    | 1    | 2     |\n      | 2    | 3    | 5     |\n      | 10   | 15   | 25    |\n      | -5   | 5    | 0     |\n</code></pre>"},{"location":"java/java-testing/#step-definitions","title":"Step Definitions","text":"<pre><code>import io.cucumber.java.en.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class CalculatorSteps {\n\n    private Calculator calculator;\n    private int result;\n\n    @Given(\"I have a calculator\")\n    public void i_have_a_calculator() {\n        calculator = new Calculator();\n    }\n\n    @When(\"I add {int} and {int}\")\n    public void i_add_and(Integer num1, Integer num2) {\n        result = calculator.add(num1, num2);\n    }\n\n    @Then(\"the result should be {int}\")\n    public void the_result_should_be(Integer expected) {\n        assertEquals(expected, result);\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#test-runner","title":"Test Runner","text":"<pre><code>import org.junit.runner.RunWith;\nimport io.cucumber.junit.Cucumber;\nimport io.cucumber.junit.CucumberOptions;\n\n@RunWith(Cucumber.class)\n@CucumberOptions(\n    features = \"src/test/resources/features\",\n    glue = \"com.example.steps\",\n    plugin = {\"pretty\", \"html:target/cucumber-reports\"}\n)\npublic class CucumberTestRunner {\n}\n</code></pre>"},{"location":"java/java-testing/#jbehave","title":"JBehave","text":"<p>JBehave is another BDD framework for Java, similar to Cucumber.</p> <pre><code>@UsingSteps(instances = { CalculatorSteps.class })\npublic class CalculatorBehaviorTest extends JUnitStories {\n\n    @Override\n    public Configuration configuration() {\n        return new MostUsefulConfiguration()\n            .useStoryLoader(new LoadFromClasspath(this.getClass()))\n            .useStoryReporterBuilder(new StoryReporterBuilder()\n                .withDefaultFormats()\n                .withFormats(Format.CONSOLE, Format.HTML));\n    }\n\n    @Override\n    public List&lt;String&gt; storyPaths() {\n        return Arrays.asList(\"calculator.story\");\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#spock-framework","title":"Spock Framework","text":"<p>Spock combines testing and specification with a Groovy DSL.</p> <pre><code>class CalculatorSpec extends Specification {\n\n    def \"Adding two numbers should return their sum\"() {\n        given: \"A calculator\"\n        def calculator = new Calculator()\n\n        when: \"Adding two numbers\"\n        def result = calculator.add(a, b)\n\n        then: \"The result should be their sum\"\n        result == expected\n\n        where:\n        a  | b  | expected\n        1  | 1  | 2\n        2  | 3  | 5\n        10 | 15 | 25\n        -5 | 5  | 0\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#bdd-best-practices","title":"BDD Best Practices","text":"<ol> <li>Focus on behavior: Write scenarios from user's perspective</li> <li>Use domain language: Avoid technical terms in feature files</li> <li>Keep scenarios independent: Each scenario should run in isolation</li> <li>Maintain a living documentation: Update features as requirements change</li> <li>Collaborate: Include business stakeholders in feature writing</li> </ol>"},{"location":"java/java-testing/#integration-testing","title":"Integration Testing","text":"<p>Integration testing verifies that different components work together as expected.</p>"},{"location":"java/java-testing/#types-of-integration-tests","title":"Types of Integration Tests","text":"<ol> <li>Component Integration: Tests interactions between components</li> <li>System Integration: Tests the entire system</li> <li>Contract Testing: Tests integration points based on contracts</li> </ol>"},{"location":"java/java-testing/#spring-integration-testing","title":"Spring Integration Testing","text":"<p>The Spring Framework provides robust support for integration testing.</p>"},{"location":"java/java-testing/#maven-dependencies","title":"Maven Dependencies","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#testing-spring-mvc-controllers","title":"Testing Spring MVC Controllers","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.mockito.Mockito.*;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\n\n@WebMvcTest(UserController.class)\npublic class UserControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private UserService userService;\n\n    @Test\n    void testGetUser() throws Exception {\n        User user = new User(1, \"John Doe\");\n        when(userService.getUserById(1)).thenReturn(user);\n\n        mockMvc.perform(get(\"/api/users/1\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.id\").value(1))\n            .andExpect(jsonPath(\"$.name\").value(\"John Doe\"));\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#testing-rest-apis","title":"Testing REST APIs","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class UserControllerIntegrationTest {\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    void testCreateUser() {\n        UserDTO userDTO = new UserDTO(\"John Doe\", \"john@example.com\");\n\n        ResponseEntity&lt;User&gt; response = restTemplate.postForEntity(\n            \"/api/users\", userDTO, User.class);\n\n        assertEquals(HttpStatus.CREATED, response.getStatusCode());\n        assertNotNull(response.getBody());\n        assertNotNull(response.getBody().getId());\n        assertEquals(\"John Doe\", response.getBody().getName());\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#testing-with-an-in-memory-database","title":"Testing with an In-Memory Database","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n@DataJpaTest\npublic class UserRepositoryTest {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    void testSaveUser() {\n        // Given\n        User user = new User(\"John Doe\", \"john@example.com\");\n\n        // When\n        User savedUser = userRepository.save(user);\n\n        // Then\n        assertNotNull(savedUser.getId());\n        assertEquals(\"John Doe\", savedUser.getName());\n\n        // Verify it's in the database\n        assertTrue(userRepository.findById(savedUser.getId()).isPresent());\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#testing-with-testcontainers","title":"Testing with Testcontainers","text":"<p>Testcontainers is a Java library that provides lightweight, throwaway instances of databases, message brokers, web browsers, or anything else that can run in a Docker container.</p>"},{"location":"java/java-testing/#maven-dependency_3","title":"Maven Dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n    &lt;version&gt;1.17.6&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n    &lt;version&gt;1.17.6&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#postgresql-container-test","title":"PostgreSQL Container Test","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.DynamicPropertyRegistry;\nimport org.springframework.test.context.DynamicPropertySource;\nimport org.testcontainers.containers.PostgreSQLContainer;\nimport org.testcontainers.junit.jupiter.Container;\nimport org.testcontainers.junit.jupiter.Testcontainers;\n\n@SpringBootTest\n@Testcontainers\npublic class UserServiceIntegrationTest {\n\n    @Container\n    private static final PostgreSQLContainer&lt;?&gt; postgreSQLContainer = \n        new PostgreSQLContainer&lt;&gt;(\"postgres:13\")\n            .withDatabaseName(\"test-db\")\n            .withUsername(\"test\")\n            .withPassword(\"test\");\n\n    @DynamicPropertySource\n    static void databaseProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgreSQLContainer::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgreSQLContainer::getUsername);\n        registry.add(\"spring.datasource.password\", postgreSQLContainer::getPassword);\n    }\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    void testCreateUser() {\n        // Test with real PostgreSQL database in container\n        User user = userService.createUser(\"John\", \"john@example.com\");\n        assertNotNull(user.getId());\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#integration-testing-best-practices","title":"Integration Testing Best Practices","text":"<ol> <li>Isolate tests: Each test should run independently</li> <li>Control external dependencies: Use test doubles or controlled environments</li> <li>Test realistic scenarios: Cover actual user workflows</li> <li>Clean up after tests: Ensure no test data leaks between tests</li> <li>Focus on integration points: Test boundaries between components</li> <li>Maintain test data: Use seed data or test fixtures for consistency</li> </ol>"},{"location":"java/java-testing/#code-coverage","title":"Code Coverage","text":"<p>Code measures how much of your code is executed during tests, helping identify untested code sections.</p>"},{"location":"java/java-testing/#coverage-metrics","title":"Coverage Metrics","text":"<ol> <li>Line Coverage: Percentage of code lines executed</li> <li>Branch Coverage: Percentage of branches executed (if/else paths)</li> <li>Method Coverage: Percentage of methods called</li> <li>Class Coverage: Percentage of classes touched</li> </ol>"},{"location":"java/java-testing/#jacoco","title":"JaCoCo","text":"<p>JaCoCo is a popular code coverage library for Java.</p>"},{"location":"java/java-testing/#maven-configuration","title":"Maven Configuration","text":"<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.jacoco&lt;/groupId&gt;\n    &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;0.8.8&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;prepare-agent&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n        &lt;execution&gt;\n            &lt;id&gt;report&lt;/id&gt;\n            &lt;phase&gt;test&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;report&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n        &lt;execution&gt;\n            &lt;id&gt;check&lt;/id&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;check&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;rules&gt;\n                    &lt;rule&gt;\n                        &lt;element&gt;PACKAGE&lt;/element&gt;\n                        &lt;limits&gt;\n                            &lt;limit&gt;\n                                &lt;counter&gt;LINE&lt;/counter&gt;\n                                &lt;value&gt;COVEREDRATIO&lt;/value&gt;\n                                &lt;minimum&gt;0.80&lt;/minimum&gt;\n                            &lt;/limit&gt;\n                        &lt;/limits&gt;\n                    &lt;/rule&gt;\n                &lt;/rules&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"java/java-testing/#running-coverage","title":"Running Coverage","text":"<pre><code>mvn clean test jacoco:report\n</code></pre>"},{"location":"java/java-testing/#interpreting-coverage-reports","title":"Interpreting Coverage Reports","text":"<p>JaCoCo generates HTML reports with color-coded indicators: - Red: Lines not executed - Yellow: Branches partially executed - Green: Fully executed code</p> <p></p>"},{"location":"java/java-testing/#coverage-tools-integration","title":"Coverage Tools Integration","text":""},{"location":"java/java-testing/#sonarqube-integration","title":"SonarQube Integration","text":"<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.sonarsource.scanner.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;sonar-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.9.1.2184&lt;/version&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"java/java-testing/#running-with-sonarqube","title":"Running with SonarQube","text":"<pre><code>mvn clean verify sonar:sonar \\\n  -Dsonar.projectKey=my-project \\\n  -Dsonar.host.url=http://localhost:9000 \\\n  -Dsonar.login=myAuthToken\n</code></pre>"},{"location":"java/java-testing/#coverage-best-practices","title":"Coverage Best Practices","text":"<ol> <li>Don't aim for 100%: Focus on business-critical code</li> <li>Use coverage as a guide: Not as the only quality metric</li> <li>Combine with mutation testing: Ensure tests are meaningful</li> <li>Track coverage trends: Monitor changes over time</li> <li>Focus on uncovered high-risk areas: Prioritize critical components</li> </ol>"},{"location":"java/java-testing/#performance-testing","title":"Performance Testing","text":"<p>Performance testing evaluates how a system performs under a particular workload, focusing on responsiveness, stability, scalability, and resource usage.</p>"},{"location":"java/java-testing/#types-of-performance-tests","title":"Types of Performance Tests","text":"<ol> <li>Load Testing: Tests behavior under expected load</li> <li>Stress Testing: Tests behavior under extreme load</li> <li>Spike Testing: Tests behavior under sudden load increases</li> <li>Endurance/Soak Testing: Tests behavior over extended periods</li> <li>Scalability Testing: Tests how system scales with increased load</li> <li>Volume Testing: Tests with large amounts of data</li> </ol>"},{"location":"java/java-testing/#jmeter","title":"JMeter","text":"<p>Apache JMeter is a widely-used open-source load testing tool.</p>"},{"location":"java/java-testing/#basic-jmeter-test-plan","title":"Basic JMeter Test Plan","text":"<ol> <li>Create a Thread Group (simulated users)</li> <li>Add HTTP Request samplers</li> <li>Add listeners to collect results</li> <li>Configure assertions to validate responses</li> <li>Run the test and analyze results</li> </ol>"},{"location":"java/java-testing/#jmeter-maven-integration","title":"JMeter Maven Integration","text":"<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.lazerycode.jmeter&lt;/groupId&gt;\n    &lt;artifactId&gt;jmeter-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.6.0&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;jmeter-tests&lt;/id&gt;\n            &lt;phase&gt;verify&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;jmeter&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n    &lt;configuration&gt;\n        &lt;testFilesDirectory&gt;${project.basedir}/src/test/jmeter&lt;/testFilesDirectory&gt;\n        &lt;resultsDirectory&gt;${project.build.directory}/jmeter-results&lt;/resultsDirectory&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"java/java-testing/#gatling","title":"Gatling","text":"<p>Gatling is a modern load testing tool with a fluent DSL.</p>"},{"location":"java/java-testing/#maven-dependency_4","title":"Maven Dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.gatling.highcharts&lt;/groupId&gt;\n    &lt;artifactId&gt;gatling-charts-highcharts&lt;/artifactId&gt;\n    &lt;version&gt;3.9.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#basic-gatling-simulation","title":"Basic Gatling Simulation","text":"<pre><code>import io.gatling.core.Predef._\nimport io.gatling.http.Predef._\nimport scala.concurrent.duration._\n\nclass UserSimulation extends Simulation {\n\n  val httpProtocol = http\n    .baseUrl(\"http://localhost:8080\")\n    .acceptHeader(\"application/json\")\n    .userAgentHeader(\"Gatling/Performance Test\")\n\n  val scn = scenario(\"Get Users Scenario\")\n    .exec(http(\"Get All Users\")\n      .get(\"/api/users\")\n      .check(status.is(200)))\n    .pause(2)\n    .exec(http(\"Get User by ID\")\n      .get(\"/api/users/1\")\n      .check(status.is(200))\n      .check(jsonPath(\"$.name\").is(\"John Doe\")))\n\n  setUp(\n    scn.inject(\n      rampUsers(100).during(30.seconds)\n    )\n  ).protocols(httpProtocol)\n}\n</code></pre>"},{"location":"java/java-testing/#jmh-java-microbenchmark-harness","title":"JMH (Java Microbenchmark Harness)","text":"<p>JMH is used for benchmarking small code segments with high precision.</p>"},{"location":"java/java-testing/#maven-dependency_5","title":"Maven Dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;\n    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;\n    &lt;version&gt;1.36&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;\n    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;\n    &lt;version&gt;1.36&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"java/java-testing/#sample-jmh-benchmark","title":"Sample JMH Benchmark","text":"<pre><code>@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@Warmup(iterations = 5, time = 1)\n@Measurement(iterations = 5, time = 1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringConcatenationBenchmark {\n\n    @Param({\"10\", \"100\", \"1000\"})\n    private int iterations;\n\n    @Benchmark\n    public String stringConcatenation() {\n        String result = \"\";\n        for (int i = 0; i &lt; iterations; i++) {\n            result += i;\n        }\n        return result;\n    }\n\n    @Benchmark\n    public String stringBuilder() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; iterations; i++) {\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) throws Exception {\n        org.openjdk.jmh.Main.main(args);\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#performance-testing-best-practices","title":"Performance Testing Best Practices","text":"<ol> <li>Define clear metrics: Response time, throughput, error rate, etc.</li> <li>Use realistic data: Test with production-like data volumes</li> <li>Monitor resources: CPU, memory, disk, network during tests</li> <li>Identify bottlenecks: Focus optimization on actual constraints</li> <li>Test in production-like environment: Replicate actual deployment setup</li> <li>Establish baselines: Compare performance against known benchmarks</li> <li>Automate performance tests: Include in CI/CD pipeline</li> </ol>"},{"location":"java/java-testing/#test-automation","title":"Test Automation","text":"<p>Test automation involves using software tools to execute tests automatically and compare actual outcomes with expected outcomes.</p>"},{"location":"java/java-testing/#test-automation-frameworks","title":"Test Automation Frameworks","text":""},{"location":"java/java-testing/#selenium","title":"Selenium","text":"<p>For web UI testing:</p> <pre><code>import org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SeleniumTest {\n\n    private WebDriver driver;\n\n    @BeforeEach\n    void setUp() {\n        driver = new ChromeDriver();\n        driver.manage().window().maximize();\n    }\n\n    @Test\n    void testGoogleSearch() {\n        driver.get(\"https://www.google.com\");\n        WebElement searchBox = driver.findElement(By.name(\"q\"));\n        searchBox.sendKeys(\"selenium testing\");\n        searchBox.submit();\n\n        // Wait for results\n        WebElement results = driver.findElement(By.id(\"search\"));\n        assertTrue(results.isDisplayed());\n\n        // Check title contains the search query\n        assertTrue(driver.getTitle().contains(\"selenium testing\"));\n    }\n\n    @AfterEach\n    void tearDown() {\n        if (driver != null) {\n            driver.quit();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#rest-assured","title":"REST Assured","text":"<p>For API testing:</p> <pre><code>import io.restassured.RestAssured;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static io.restassured.RestAssured.*;\nimport static org.hamcrest.Matchers.*;\n\npublic class RestAssuredTest {\n\n    @BeforeEach\n    void setUp() {\n        RestAssured.baseURI = \"https://reqres.in\";\n        RestAssured.basePath = \"/api\";\n    }\n\n    @Test\n    void testGetUser() {\n        given()\n            .pathParam(\"id\", 2)\n        .when()\n            .get(\"/users/{id}\")\n        .then()\n            .statusCode(200)\n            .body(\"data.id\", equalTo(2))\n            .body(\"data.email\", equalTo(\"janet.weaver@reqres.in\"))\n            .body(\"data.first_name\", equalTo(\"Janet\"));\n    }\n\n    @Test\n    void testCreateUser() {\n        String user = \"{\\\"name\\\":\\\"morpheus\\\",\\\"job\\\":\\\"leader\\\"}\";\n\n        given()\n            .contentType(\"application/json\")\n            .body(user)\n        .when()\n            .post(\"/users\")\n        .then()\n            .statusCode(201)\n            .body(\"name\", equalTo(\"morpheus\"))\n            .body(\"job\", equalTo(\"leader\"))\n            .body(\"id\", not(emptyString()));\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#cucumber-with-selenium","title":"Cucumber with Selenium","text":"<p>For behavior-driven UI testing:</p> <pre><code>// Feature file: src/test/resources/features/login.feature\nFeature: Login Functionality\n  As a user\n  I want to be able to log in\n  So that I can access my account\n\n  Scenario: Successful login\n    Given I am on the login page\n    When I enter username \"user\" and password \"pass\"\n    And I click the login button\n    Then I should be redirected to the dashboard\n\n// Step definitions\npublic class LoginSteps {\n\n    private WebDriver driver;\n\n    @Before\n    public void setUp() {\n        driver = new ChromeDriver();\n    }\n\n    @Given(\"I am on the login page\")\n    public void i_am_on_the_login_page() {\n        driver.get(\"https://example.com/login\");\n    }\n\n    @When(\"I enter username {string} and password {string}\")\n    public void i_enter_username_and_password(String username, String password) {\n        driver.findElement(By.id(\"username\")).sendKeys(username);\n        driver.findElement(By.id(\"password\")).sendKeys(password);\n    }\n\n    @And(\"I click the login button\")\n    public void i_click_the_login_button() {\n        driver.findElement(By.id(\"login-button\")).click();\n    }\n\n    @Then(\"I should be redirected to the dashboard\")\n    public void i_should_be_redirected_to_the_dashboard() {\n        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n        wait.until(ExpectedConditions.urlContains(\"/dashboard\"));\n        assertEquals(\"Dashboard\", driver.getTitle());\n    }\n\n    @After\n    public void tearDown() {\n        driver.quit();\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"java/java-testing/#jenkins-pipeline-for-testing","title":"Jenkins Pipeline for Testing","text":"<pre><code>pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                sh 'mvn clean compile'\n            }\n        }\n        stage('Unit Tests') {\n            steps {\n                sh 'mvn test'\n            }\n            post {\n                always {\n                    junit '**/target/surefire-reports/*.xml'\n                }\n            }\n        }\n        stage('Integration Tests') {\n            steps {\n                sh 'mvn verify -DskipUnitTests'\n            }\n            post {\n                always {\n                    junit '**/target/failsafe-reports/*.xml'\n                }\n            }\n        }\n        stage('Code Coverage') {\n            steps {\n                sh 'mvn jacoco:report'\n                publishHTML([\n                    allowMissing: false,\n                    alwaysLinkToLastBuild: true,\n                    keepAll: true,\n                    reportDir: 'target/site/jacoco',\n                    reportFiles: 'index.html',\n                    reportName: 'JaCoCo Code Coverage'\n                ])\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#github-actions","title":"GitHub Actions","text":"<pre><code>name: Java Tests\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: '17'\n        distribution: 'temurin'\n        cache: maven\n    - name: Unit Tests\n      run: mvn test\n    - name: Integration Tests\n      run: mvn verify -DskipUnitTests\n    - name: Publish Test Report\n      uses: mikepenz/action-junit-report@v3\n      if: always()\n      with:\n        report_paths: '**/target/surefire-reports/TEST-*.xml, **/target/failsafe-reports/TEST-*.xml'\n</code></pre>"},{"location":"java/java-testing/#test-automation-best-practices","title":"Test Automation Best Practices","text":"<ol> <li>Choose the right tools: Select frameworks suited to your needs</li> <li>Automate at the right level: Prioritize unit and API tests over UI tests</li> <li>Keep tests independent: Avoid dependencies between tests</li> <li>Prioritize test reliability: Flaky tests undermine confidence</li> <li>Maintain test code: Treat test code with the same care as production code</li> <li>Use the test pyramid: More unit tests, fewer UI tests</li> <li>Fast feedback: Tests should run quickly</li> <li>Test data management: Control test data creation and cleanup</li> </ol>"},{"location":"java/java-testing/#testing-web-applications","title":"Testing Web Applications","text":"<p>Testing web applications involves multiple layers from front-end to back-end.</p>"},{"location":"java/java-testing/#front-end-testing","title":"Front-end Testing","text":""},{"location":"java/java-testing/#testing-javascript-with-jest","title":"Testing JavaScript with Jest","text":"<pre><code>// math.js\nexport function add(a, b) {\n  return a + b;\n}\n\n// math.test.js\nimport { add } from './math';\n\ntest('adds 1 + 2 to equal 3', () =&gt; {\n  expect(add(1, 2)).toBe(3);\n});\n</code></pre>"},{"location":"java/java-testing/#react-component-testing","title":"React Component Testing","text":"<pre><code>// Button.jsx\nimport React from 'react';\n\nconst Button = ({ onClick, text }) =&gt; (\n  &lt;button onClick={onClick}&gt;{text}&lt;/button&gt;\n);\n\nexport default Button;\n\n// Button.test.jsx\nimport React from 'react';\nimport { render, fireEvent } from '@testing-library/react';\nimport Button from './Button';\n\ntest('calls onClick when clicked', () =&gt; {\n  const handleClick = jest.fn();\n  const { getByText } = render(\n    &lt;Button onClick={handleClick} text=\"Click Me\" /&gt;\n  );\n\n  fireEvent.click(getByText('Click Me'));\n  expect(handleClick).toHaveBeenCalledTimes(1);\n});\n</code></pre>"},{"location":"java/java-testing/#angular-component-testing","title":"Angular Component Testing","text":"<pre><code>// counter.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    &lt;div&gt;Current Count: {{ count }}&lt;/div&gt;\n    &lt;button (click)=\"increment()\"&gt;Increment&lt;/button&gt;\n  `\n})\nexport class CounterComponent {\n  count = 0;\n\n  increment() {\n    this.count++;\n  }\n}\n\n// counter.component.spec.ts\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { CounterComponent } from './counter.component';\n\ndescribe('CounterComponent', () =&gt; {\n  let component: CounterComponent;\n  let fixture: ComponentFixture&lt;CounterComponent&gt;;\n  let compiled: HTMLElement;\n\n  beforeEach(async () =&gt; {\n    await TestBed.configureTestingModule({\n      declarations: [ CounterComponent ]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(CounterComponent);\n    component = fixture.componentInstance;\n    compiled = fixture.nativeElement;\n    fixture.detectChanges();\n  });\n\n  it('should create', () =&gt; {\n    expect(component).toBeTruthy();\n  });\n\n  it('should start with count 0', () =&gt; {\n    expect(compiled.textContent).toContain('Current Count: 0');\n  });\n\n  it('should increment count when button is clicked', () =&gt; {\n    const button = compiled.querySelector('button');\n    button?.click();\n    fixture.detectChanges();\n    expect(compiled.textContent).toContain('Current Count: 1');\n  });\n});\n</code></pre>"},{"location":"java/java-testing/#end-to-end-testing","title":"End-to-End Testing","text":""},{"location":"java/java-testing/#cypress","title":"Cypress","text":"<pre><code>// cypress/integration/login.spec.js\ndescribe('Login', () =&gt; {\n  beforeEach(() =&gt; {\n    cy.visit('/login');\n  });\n\n  it('should login with valid credentials', () =&gt; {\n    cy.get('#username').type('testuser');\n    cy.get('#password').type('password123');\n    cy.get('#login-button').click();\n\n    // Verify successful login\n    cy.url().should('include', '/dashboard');\n    cy.get('h1').should('contain', 'Welcome, testuser');\n  });\n\n  it('should display error with invalid credentials', () =&gt; {\n    cy.get('#username').type('wronguser');\n    cy.get('#password').type('wrongpass');\n    cy.get('#login-button').click();\n\n    // Verify error message\n    cy.get('.error-message').should('be.visible');\n    cy.get('.error-message').should('contain', 'Invalid username or password');\n  });\n});\n</code></pre>"},{"location":"java/java-testing/#playwright","title":"Playwright","text":"<pre><code>import com.microsoft.playwright.*;\nimport org.junit.jupiter.api.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PlaywrightTest {\n\n    private Playwright playwright;\n    private Browser browser;\n    private Page page;\n\n    @BeforeEach\n    void setUp() {\n        playwright = Playwright.create();\n        browser = playwright.chromium().launch();\n        page = browser.newPage();\n    }\n\n    @Test\n    void testLogin() {\n        page.navigate(\"https://example.com/login\");\n\n        page.fill(\"#username\", \"testuser\");\n        page.fill(\"#password\", \"password123\");\n        page.click(\"#login-button\");\n\n        // Wait for navigation\n        page.waitForURL(\"**/dashboard\");\n\n        // Verify successful login\n        assertTrue(page.url().contains(\"/dashboard\"));\n        assertEquals(\"Welcome, testuser\", page.textContent(\"h1\"));\n    }\n\n    @AfterEach\n    void tearDown() {\n        if (page != null) {\n            page.close();\n        }\n        if (browser != null) {\n            browser.close();\n        }\n        if (playwright != null) {\n            playwright.close();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#api-testing","title":"API Testing","text":""},{"location":"java/java-testing/#testing-spring-boot-rest-api","title":"Testing Spring Boot REST API","text":"<pre><code>import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\n\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class UserControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    void testGetAllUsers() throws Exception {\n        mockMvc.perform(get(\"/api/users\"))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n            .andExpect(jsonPath(\"$\").isArray())\n            .andExpect(jsonPath(\"$.length()\").isNumber());\n    }\n\n    @Test\n    void testCreateUser() throws Exception {\n        String userJson = \"{\\\"name\\\":\\\"Jane Doe\\\",\\\"email\\\":\\\"jane@example.com\\\"}\";\n\n        mockMvc.perform(post(\"/api/users\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(userJson))\n            .andExpect(status().isCreated())\n            .andExpect(jsonPath(\"$.id\").exists())\n            .andExpect(jsonPath(\"$.name\").value(\"Jane Doe\"))\n            .andExpect(jsonPath(\"$.email\").value(\"jane@example.com\"));\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#accessibility-testing","title":"Accessibility Testing","text":""},{"location":"java/java-testing/#using-axe-with-selenium","title":"Using Axe with Selenium","text":"<pre><code>import com.deque.html.axecore.selenium.AxeBuilder;\nimport com.deque.html.axecore.selenium.AxeReporter;\nimport com.deque.html.axecore.selenium.ResultType;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccessibilityTest {\n\n    private WebDriver driver;\n\n    @BeforeEach\n    void setUp() {\n        driver = new ChromeDriver();\n    }\n\n    @Test\n    void testHomePageAccessibility() {\n        driver.get(\"https://example.com\");\n\n        JSONObject results = new AxeBuilder()\n            .analyze(driver);\n\n        JSONArray violations = results.getJSONArray(\"violations\");\n\n        if (violations.length() &gt; 0) {\n            AxeReporter.writeResultsToJsonFile(\"accessibility-results\", results);\n            fail(\"Accessibility violations found: \" + violations.length());\n        }\n    }\n\n    @AfterEach\n    void tearDown() {\n        if (driver != null) {\n            driver.quit();\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#security-testing","title":"Security Testing","text":""},{"location":"java/java-testing/#owasp-zap-integration","title":"OWASP ZAP Integration","text":"<pre><code>import org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.zaproxy.clientapi.core.ApiResponse;\nimport org.zaproxy.clientapi.core.ClientApi;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SecurityTest {\n\n    private static ClientApi api;\n\n    @BeforeAll\n    static void setUp() {\n        // ZAP API client\n        api = new ClientApi(\"localhost\", 8080);\n    }\n\n    @Test\n    void testApiSecurity() throws Exception {\n        // Start a new session\n        api.core.newSession(\"\", \"\");\n\n        // Access the target\n        api.core.accessUrl(\"https://example.com/api\");\n\n        // Spider the target\n        ApiResponse response = api.spider.scan(\"https://example.com/api\", null, null, null, null);\n        String scanId = response.getString(\"scan\");\n\n        // Wait for the spider to complete\n        while (true) {\n            Thread.sleep(1000);\n            int progress = Integer.parseInt(api.spider.status(scanId).getString(\"status\"));\n            if (progress &gt;= 100) {\n                break;\n            }\n        }\n\n        // Run active scan\n        response = api.ascan.scan(\"https://example.com/api\", \"True\", \"False\", null, null, null);\n        scanId = response.getString(\"scan\");\n\n        // Wait for the scan to complete\n        while (true) {\n            Thread.sleep(1000);\n            int progress = Integer.parseInt(api.ascan.status(scanId).getString(\"status\"));\n            if (progress &gt;= 100) {\n                break;\n            }\n        }\n\n        // Get the alerts\n        ApiResponse alerts = api.core.alerts(\"https://example.com/api\", null, null);\n\n        // Verify high risk alerts\n        JSONObject alertsObj = new JSONObject(alerts.toString());\n        JSONArray alertsList = alertsObj.getJSONArray(\"alerts\");\n\n        int highRiskAlerts = 0;\n        for (int i = 0; i &lt; alertsList.length(); i++) {\n            JSONObject alert = alertsList.getJSONObject(i);\n            if (alert.getInt(\"risk\") &gt;= 3) {  // High risk (3)\n                highRiskAlerts++;\n            }\n        }\n\n        assertEquals(0, highRiskAlerts, \"High risk security vulnerabilities found\");\n    }\n\n    @AfterAll\n    static void tearDown() {\n        // Clean up\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#web-testing-best-practices","title":"Web Testing Best Practices","text":"<ol> <li>Test across browsers: Verify compatibility with major browsers</li> <li>Test responsive design: Check behavior across device sizes</li> <li>Automate regression testing: Catch UI regressions automatically</li> <li>Test accessibility: Ensure compliance with WCAG guidelines</li> <li>Security testing: Check for common vulnerabilities</li> <li>Performance testing: Measure load times and responsiveness</li> <li>Consider real user conditions: Test with throttled connections</li> <li>Visual regression testing: Compare screenshots for UI changes</li> </ol>"},{"location":"java/java-testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"java/java-testing/#general-testing-best-practices","title":"General Testing Best Practices","text":"<ol> <li>Test Early, Test Often</li> <li>Start testing as early as possible in development</li> <li>Integrate tests into your development workflow</li> <li> <p>Automate tests to run on every code change</p> </li> <li> <p>Follow the Testing Pyramid <pre><code>     /\\\n    /  \\\n   /    \\\n  / E2E  \\\n /        \\\n/Integration\\\n/____________\\\n/   Unit Tests \\\n/________________\\\n</code></pre></p> </li> <li>Many unit tests: fast, reliable, focused</li> <li>Fewer integration tests: verify component interactions</li> <li> <p>Fewest E2E tests: validate complete workflows</p> </li> <li> <p>Write Testable Code</p> </li> <li>Follow SOLID principles</li> <li>Use dependency injection</li> <li>Separate concerns (business logic from I/O)</li> <li> <p>Keep methods small and focused</p> </li> <li> <p>Maintain Test Independence</p> </li> <li>Tests should not depend on each other</li> <li>Each test should set up its own state</li> <li> <p>Clean up after tests to avoid affecting others</p> </li> <li> <p>Use Fresh Test Data</p> </li> <li>Avoid shared test data when possible</li> <li>Reset data between tests</li> <li> <p>Use test data builders or factories</p> </li> <li> <p>Make Tests Deterministic</p> </li> <li>Avoid random data without setting seeds</li> <li>Control external dependencies</li> <li> <p>Avoid time dependencies with clock injection</p> </li> <li> <p>Focus on Test Quality</p> </li> <li>Tests should be clear and readable</li> <li>Maintain tests like production code</li> <li> <p>Refactor tests when needed</p> </li> <li> <p>Consider Edge Cases</p> </li> <li>Test boundary conditions</li> <li>Test error scenarios</li> <li>Test with invalid inputs</li> </ol>"},{"location":"java/java-testing/#unit-testing-best-practices","title":"Unit Testing Best Practices","text":"<ol> <li> <p>Test One Thing at a Time <pre><code>// GOOD: Testing one behavior\n@Test\nvoid whenDivideByZero_thenThrowsException() {\n    assertThrows(ArithmeticException.class, () -&gt; calculator.divide(1, 0));\n}\n\n// BAD: Testing multiple behaviors\n@Test\nvoid testCalculator() {\n    assertEquals(5, calculator.add(2, 3));\n    assertEquals(2, calculator.subtract(5, 3));\n    assertThrows(ArithmeticException.class, () -&gt; calculator.divide(1, 0));\n}\n</code></pre></p> </li> <li> <p>Use Descriptive Test Names <pre><code>// GOOD: Descriptive name\n@Test\nvoid givenValidCredentials_whenLogin_thenSucceeds() {\n    // Test implementation\n}\n\n// BAD: Vague name\n@Test\nvoid testLogin() {\n    // Test implementation\n}\n</code></pre></p> </li> <li> <p>Follow Arrange-Act-Assert Pattern <pre><code>@Test\nvoid givenExistingUser_whenUpdateEmail_thenEmailUpdated() {\n    // Arrange\n    User user = new User(1, \"John\", \"john@example.com\");\n    when(userRepository.findById(1)).thenReturn(Optional.of(user));\n\n    // Act\n    userService.updateEmail(1, \"new@example.com\");\n\n    // Assert\n    assertEquals(\"new@example.com\", user.getEmail());\n    verify(userRepository).save(user);\n}\n</code></pre></p> </li> <li> <p>Test Behavior, Not Implementation <pre><code>// GOOD: Testing behavior\n@Test\nvoid givenInvalidEmail_whenValidate_thenReturnsFalse() {\n    assertFalse(validator.isValidEmail(\"not-an-email\"));\n}\n\n// BAD: Testing implementation\n@Test\nvoid checkEmailValidationRegex() {\n    Pattern pattern = (Pattern) ReflectionUtils.getField(\n        ValidatorClass.class.getDeclaredField(\"EMAIL_PATTERN\"), \n        validator);\n    assertTrue(pattern.matcher(\"email@example.com\").matches());\n}\n</code></pre></p> </li> <li> <p>Use Appropriate Assertions <pre><code>// GOOD: Clear assertions\n@Test\nvoid testUser() {\n    User user = new User(\"John\", 30);\n    assertEquals(\"John\", user.getName());\n    assertEquals(30, user.getAge());\n}\n\n// BETTER: AssertJ fluent assertions\n@Test\nvoid testUserWithAssertJ() {\n    User user = new User(\"John\", 30);\n    assertThat(user)\n        .extracting(User::getName, User::getAge)\n        .containsExactly(\"John\", 30);\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-testing/#integration-testing-best-practices_1","title":"Integration Testing Best Practices","text":"<ol> <li>Use Real Dependencies When Possible</li> <li>Test with real databases for data access layers</li> <li>Use embedded servers for testing microservices</li> <li> <p>Leverage test containers for external services</p> </li> <li> <p>Control External Services</p> </li> <li>Use WireMock for HTTP dependencies</li> <li>Use Embedded Kafka for messaging</li> <li> <p>Use Testcontainers for databases and other services</p> </li> <li> <p>Focus on Component Interactions</p> </li> <li>Test API contracts</li> <li>Test database interactions</li> <li> <p>Test messaging patterns</p> </li> <li> <p>Validate End-to-End Flows</p> </li> <li>Test complete business processes</li> <li>Verify system behavior as a whole</li> <li>Cover critical user journeys</li> </ol>"},{"location":"java/java-testing/#test-data-management","title":"Test Data Management","text":"<ol> <li> <p>Use Test Data Builders <pre><code>public class UserBuilder {\n    private int id = 1;\n    private String name = \"Default Name\";\n    private String email = \"default@example.com\";\n    private boolean active = true;\n\n    public UserBuilder withId(int id) {\n        this.id = id;\n        return this;\n    }\n\n    public UserBuilder withName(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public UserBuilder withEmail(String email) {\n        this.email = email;\n        return this;\n    }\n\n    public UserBuilder inactive() {\n        this.active = false;\n        return this;\n    }\n\n    public User build() {\n        User user = new User(name, email);\n        user.setId(id);\n        user.setActive(active);\n        return user;\n    }\n\n    public static UserBuilder aUser() {\n        return new UserBuilder();\n    }\n}\n\n// Usage in tests\n@Test\nvoid testInactiveUser() {\n    User user = UserBuilder.aUser()\n        .withName(\"John\")\n        .inactive()\n        .build();\n\n    assertFalse(user.isActive());\n}\n</code></pre></p> </li> <li> <p>Use Test Fixtures <pre><code>public class TestFixtures {\n    public static List&lt;User&gt; createSampleUsers() {\n        return List.of(\n            new User(1, \"John\", \"john@example.com\"),\n            new User(2, \"Jane\", \"jane@example.com\"),\n            new User(3, \"Bob\", \"bob@example.com\")\n        );\n    }\n\n    public static Order createSampleOrder() {\n        // Create and return sample order\n    }\n}\n</code></pre></p> </li> <li> <p>Database Test Data</p> </li> <li>Use database migrations (Flyway/Liquibase)</li> <li>Create test-specific datasets</li> <li>Reset database between tests</li> </ol>"},{"location":"java/java-testing/#common-testing-pitfalls","title":"Common Testing Pitfalls","text":""},{"location":"java/java-testing/#unit-testing-pitfalls","title":"Unit Testing Pitfalls","text":"<ol> <li> <p>Testing Implementation Details <pre><code>// PROBLEMATIC: Testing private methods\n@Test\nvoid testPrivateMethod() throws Exception {\n    Method method = UserService.class.getDeclaredMethod(\"validateEmail\", String.class);\n    method.setAccessible(true);\n    boolean result = (boolean) method.invoke(userService, \"user@example.com\");\n    assertTrue(result);\n}\n\n// BETTER: Test the public behavior\n@Test\nvoid givenInvalidEmail_whenCreateUser_thenThrowsException() {\n    assertThrows(IllegalArgumentException.class, \n        () -&gt; userService.createUser(\"John\", \"invalid-email\"));\n}\n</code></pre></p> </li> <li> <p>Over-mocking <pre><code>// PROBLEMATIC: Too many mocks\n@Test\nvoid testOverMocked() {\n    when(dependency1.method1()).thenReturn(\"value1\");\n    when(dependency2.method2(any())).thenReturn(\"value2\");\n    when(dependency3.method3(anyString(), anyInt())).thenReturn(\"value3\");\n    when(dependency4.method4()).thenReturn(\"value4\");\n    when(dependency5.method5()).thenReturn(\"value5\");\n\n    String result = service.doSomething();\n\n    assertEquals(\"expected\", result);\n}\n\n// BETTER: Test with real objects when possible\n@Test\nvoid testWithRealObjects() {\n    Dependency1 real1 = new Dependency1();\n    Dependency2 real2 = new Dependency2();\n\n    Service service = new Service(real1, real2, mockDep3);\n\n    String result = service.doSomething();\n\n    assertEquals(\"expected\", result);\n}\n</code></pre></p> </li> <li> <p>Inadequate Assertions <pre><code>// PROBLEMATIC: Missing assertions\n@Test\nvoid testNoAssertions() {\n    service.process(\"input\");\n    // No assertions!\n}\n\n// PROBLEMATIC: Too general assertions\n@Test\nvoid testVagueAssertions() {\n    List&lt;User&gt; users = userService.getAllUsers();\n    assertNotNull(users); // Not specific enough\n}\n\n// BETTER: Specific assertions\n@Test\nvoid testSpecificAssertions() {\n    List&lt;User&gt; users = userService.getAllUsers();\n    assertThat(users)\n        .isNotEmpty()\n        .hasSize(3)\n        .extracting(User::getEmail)\n        .contains(\"john@example.com\", \"jane@example.com\");\n}\n</code></pre></p> </li> <li> <p>Flaky Tests <pre><code>// PROBLEMATIC: Time-dependent test\n@Test\nvoid testTimeDependent() {\n    Order order = new Order();\n    order.setCreationTime(new Date());\n\n    boolean isNew = orderService.isNewOrder(order);\n\n    assertTrue(isNew); // Might fail near midnight\n}\n\n// BETTER: Inject clock\n@Test\nvoid testWithInjectedClock() {\n    Clock fixedClock = Clock.fixed(\n        Instant.parse(\"2023-01-01T12:00:00Z\"),\n        ZoneId.systemDefault());\n\n    OrderService orderService = new OrderService(fixedClock);\n\n    Order order = new Order();\n    order.setCreationTime(Date.from(fixedClock.instant()));\n\n    boolean isNew = orderService.isNewOrder(order);\n\n    assertTrue(isNew);\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-testing/#integration-testing-pitfalls","title":"Integration Testing Pitfalls","text":"<ol> <li> <p>Shared Mutable State <pre><code>// PROBLEMATIC: Static state affecting tests\npublic static class SharedCounter {\n    public static int count = 0;\n\n    public static void increment() {\n        count++;\n    }\n}\n\n@Test\nvoid test1() {\n    SharedCounter.count = 0;\n    SharedCounter.increment();\n    assertEquals(1, SharedCounter.count);\n}\n\n@Test\nvoid test2() {\n    SharedCounter.increment();\n    assertEquals(1, SharedCounter.count); // Might fail if test1 runs first\n}\n</code></pre></p> </li> <li> <p>Incomplete Environment Setup <pre><code>// PROBLEMATIC: Missing configuration\n@Test\nvoid testDatabaseWithoutSchema() {\n    // Assumes database schema exists\n    userRepository.save(new User(\"John\", \"john@example.com\"));\n}\n\n// BETTER: Ensure complete environment\n@Test\nvoid testWithProperSetup() {\n    // Use Flyway to create schema\n    flyway.migrate();\n\n    userRepository.save(new User(\"John\", \"john@example.com\"));\n}\n</code></pre></p> </li> <li> <p>Ignoring Cleanup <pre><code>// PROBLEMATIC: No cleanup\n@Test\nvoid testWithoutCleanup() {\n    File tempFile = new File(\"temp.txt\");\n    tempFile.createNewFile();\n    // Test file operations\n    // Forgot to delete the file\n}\n\n// BETTER: Ensure cleanup\n@Test\nvoid testWithCleanup() {\n    File tempFile = new File(\"temp.txt\");\n    try {\n        tempFile.createNewFile();\n        // Test file operations\n    } finally {\n        tempFile.delete();\n    }\n}\n</code></pre></p> </li> <li> <p>Race Conditions in Concurrent Tests <pre><code>// PROBLEMATIC: Race condition\n@Test\nvoid testConcurrentAccess() throws Exception {\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicBoolean failed = new AtomicBoolean(false);\n\n    Thread thread1 = new Thread(() -&gt; {\n        try {\n            latch.await();\n            service.increment();\n        } catch (Exception e) {\n            failed.set(true);\n        }\n    });\n\n    Thread thread2 = new Thread(() -&gt; {\n        try {\n            latch.await();\n            service.increment();\n        } catch (Exception e) {\n            failed.set(true);\n        }\n    });\n\n    thread1.start();\n    thread2.start();\n    latch.countDown();\n\n    thread1.join();\n    thread2.join();\n\n    assertFalse(failed.get());\n    assertEquals(2, service.getCount()); // Might fail\n}\n\n// BETTER: Use proper concurrency testing tools\n@Test\nvoid testWithJCStress() {\n    ConcurrentServiceStressTest stressTest = new ConcurrentServiceStressTest();\n    stressTest.run();\n    assertTrue(stressTest.passed());\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-testing/#system-testing-pitfalls","title":"System Testing Pitfalls","text":"<ol> <li> <p>Environment Differences <pre><code>// PROBLEMATIC: Hardcoded paths\n@Test\nvoid testFileProcessing() {\n    service.processFile(\"C:\\\\data\\\\input.txt\");\n    assertTrue(Files.exists(Paths.get(\"C:\\\\data\\\\output.txt\")));\n}\n\n// BETTER: Use relative paths or environment variables\n@Test\nvoid testFileProcessingPortable() {\n    String baseDir = System.getProperty(\"java.io.tmpdir\");\n    Path inputPath = Paths.get(baseDir, \"input.txt\");\n    Path outputPath = Paths.get(baseDir, \"output.txt\");\n\n    Files.write(inputPath, \"test data\".getBytes());\n\n    service.processFile(inputPath.toString());\n    assertTrue(Files.exists(outputPath));\n}\n</code></pre></p> </li> <li> <p>Insufficient Load Testing <pre><code>// PROBLEMATIC: Fixed small dataset\n@Test\nvoid testBatchProcessing() {\n    List&lt;Order&gt; orders = createSampleOrders(10); // Only 10 items\n    service.processBatch(orders);\n    // Assert results\n}\n\n// BETTER: Test with realistic volumes\n@Test\nvoid testLargeDatasetProcessing() {\n    List&lt;Order&gt; orders = createSampleOrders(10000);\n    service.processBatch(orders);\n    // Assert results and performance metrics\n}\n</code></pre></p> </li> </ol>"},{"location":"java/java-testing/#advanced-testing-techniques","title":"Advanced Testing Techniques","text":""},{"location":"java/java-testing/#property-based-testing","title":"Property-Based Testing","text":"<p>Property-based testing generates random input data to test properties that should hold for all inputs.</p>"},{"location":"java/java-testing/#using-junit-quickcheck","title":"Using JUnit-QuickCheck","text":"<pre><code>import com.pholser.junit.quickcheck.Property;\nimport com.pholser.junit.quickcheck.runner.JUnitQuickcheck;\nimport org.junit.runner.RunWith;\n\nimport static org.junit.Assert.*;\n\n@RunWith(JUnitQuickcheck.class)\npublic class StringReversePropertyTest {\n\n    @Property\n    public void reverseTwiceIsOriginal(String original) {\n        StringUtils stringUtils = new StringUtils();\n        String reversed = stringUtils.reverse(original);\n        String reversedTwice = stringUtils.reverse(reversed);\n\n        assertEquals(original, reversedTwice);\n    }\n\n    @Property\n    public void reversePreservesLength(String original) {\n        StringUtils stringUtils = new StringUtils();\n        String reversed = stringUtils.reverse(original);\n\n        assertEquals(original.length(), reversed.length());\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#mutation-testing","title":"Mutation Testing","text":"<p>Mutation testing assesses test quality by introducing bugs (mutations) and checking if tests catch them.</p>"},{"location":"java/java-testing/#using-pit-mutation-testing","title":"Using PIT Mutation Testing","text":"<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.pitest&lt;/groupId&gt;\n    &lt;artifactId&gt;pitest-maven&lt;/artifactId&gt;\n    &lt;version&gt;1.14.0&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.pitest&lt;/groupId&gt;\n            &lt;artifactId&gt;pitest-junit5-plugin&lt;/artifactId&gt;\n            &lt;version&gt;1.2.0&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;configuration&gt;\n        &lt;targetClasses&gt;\n            &lt;param&gt;com.example.service.*&lt;/param&gt;\n        &lt;/targetClasses&gt;\n        &lt;targetTests&gt;\n            &lt;param&gt;com.example.service.*&lt;/param&gt;\n        &lt;/targetTests&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"java/java-testing/#approval-testing","title":"Approval Testing","text":"<p>Approval testing compares test outputs with previously approved outputs.</p>"},{"location":"java/java-testing/#using-approvals","title":"Using Approvals","text":"<pre><code>import org.approvaltests.Approvals;\nimport org.junit.jupiter.api.Test;\n\npublic class ReportGeneratorTest {\n\n    @Test\n    void testComplexReportGeneration() {\n        ReportGenerator generator = new ReportGenerator();\n        String report = generator.generateReport();\n\n        Approvals.verify(report);\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#chaos-testing","title":"Chaos Testing","text":"<p>Chaos testing deliberately introduces failures to test system resilience.</p>"},{"location":"java/java-testing/#using-chaos-monkey-for-spring-boot","title":"Using Chaos Monkey for Spring Boot","text":"<pre><code>@SpringBootApplication\n@EnableChaos\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n// application.properties\nchaos.monkey.enabled=true\nchaos.monkey.watcher.service=true\nchaos.monkey.assaults.latencyActive=true\nchaos.monkey.assaults.latencyRangeStart=1000\nchaos.monkey.assaults.latencyRangeEnd=3000\n</code></pre>"},{"location":"java/java-testing/#consumer-driven-contract-testing","title":"Consumer-Driven Contract Testing","text":"<p>CDC testing validates that API providers meet consumer expectations.</p>"},{"location":"java/java-testing/#using-spring-cloud-contract","title":"Using Spring Cloud Contract","text":"<pre><code>// src/test/resources/contracts/shouldReturnUser.groovy\npackage contracts\n\nimport org.springframework.cloud.contract.spec.Contract\n\nContract.make {\n    description \"should return user by ID\"\n\n    request {\n        method GET()\n        url \"/api/users/1\"\n    }\n\n    response {\n        status 200\n        headers {\n            contentType('application/json')\n        }\n        body([\n            id: 1,\n            name: \"John Doe\",\n            email: \"john@example.com\"\n        ])\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#fuzz-testing","title":"Fuzz Testing","text":"<p>Fuzz testing provides random or invalid data to find exceptions or security issues.</p> <pre><code>import com.code_intelligence.jazzer.api.FuzzedDataProvider;\nimport com.code_intelligence.jazzer.junit.FuzzTest;\n\npublic class ParserFuzzTest {\n\n    @FuzzTest\n    void testJsonParser(FuzzedDataProvider data) {\n        String input = data.consumeRemainingAsString();\n        try {\n            JsonParser parser = new JsonParser();\n            parser.parse(input);\n        } catch (JsonParseException e) {\n            // Expected for invalid JSON\n        } catch (Throwable t) {\n            // Any other exception is a problem\n            throw t;\n        }\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#performance-profiling","title":"Performance Profiling","text":"<p>Performance profiling identifies bottlenecks and optimization opportunities.</p> <pre><code>import org.junit.jupiter.api.Test;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MemoryMXBean;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MemoryUsageTest {\n\n    @Test\n    void testMemoryUsage() {\n        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();\n        long beforeHeapMemory = memoryBean.getHeapMemoryUsage().getUsed();\n\n        // Execute code to be measured\n        List&lt;String&gt; data = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 1000000; i++) {\n            data.add(\"Item \" + i);\n        }\n\n        long afterHeapMemory = memoryBean.getHeapMemoryUsage().getUsed();\n        long memoryUsed = afterHeapMemory - beforeHeapMemory;\n\n        System.out.println(\"Memory used: \" + memoryUsed / (1024 * 1024) + \" MB\");\n    }\n}\n</code></pre>"},{"location":"java/java-testing/#resources-for-further-learning","title":"Resources for Further Learning","text":""},{"location":"java/java-testing/#books","title":"Books","text":"<ol> <li>\"Effective Unit Testing\" by Lasse Koskela</li> <li> <p>Comprehensive guide to writing maintainable unit tests</p> </li> <li> <p>\"Test Driven Development: By Example\" by Kent Beck</p> </li> <li> <p>The definitive guide to TDD from its creator</p> </li> <li> <p>\"Practical Unit Testing with JUnit and Mockito\" by Tomek Kaczanowski</p> </li> <li> <p>Practical approaches to unit testing in Java</p> </li> <li> <p>\"Growing Object-Oriented Software, Guided by Tests\" by Steve Freeman and Nat Pryce</p> </li> <li> <p>How to use TDD to build maintainable OO systems</p> </li> <li> <p>\"Java Testing with Spock\" by Konstantinos Kapelonis</p> </li> <li>Advanced testing using the Spock framework</li> </ol>"},{"location":"java/java-testing/#online-resources","title":"Online Resources","text":"<ol> <li>JUnit 5 User Guide</li> <li> <p>https://junit.org/junit5/docs/current/user-guide/</p> </li> <li> <p>Mockito Documentation</p> </li> <li> <p>https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html</p> </li> <li> <p>TestNG Documentation</p> </li> <li> <p>https://testng.org/doc/documentation-main.html</p> </li> <li> <p>Spring Testing Documentation</p> </li> <li> <p>https://docs.spring.io/spring-framework/reference/testing.html</p> </li> <li> <p>Baeldung Java Testing Articles</p> </li> <li> <p>https://www.baeldung.com/java-tests</p> </li> <li> <p>AssertJ Documentation</p> </li> <li> <p>https://assertj.github.io/doc/</p> </li> <li> <p>JMeter User Manual</p> </li> <li>https://jmeter.apache.org/usermanual/index.html</li> </ol>"},{"location":"java/java-testing/#courses","title":"Courses","text":"<ol> <li>Testing Java Applications (Pluralsight)</li> <li> <p>Comprehensive course on Java testing strategies</p> </li> <li> <p>Practical Test-Driven Development for Java Programmers (LinkedIn Learning)</p> </li> <li> <p>Hands-on TDD techniques for Java developers</p> </li> <li> <p>Spring: Test-Driven Development with JUnit (LinkedIn Learning)</p> </li> <li> <p>TDD specifically for Spring applications</p> </li> <li> <p>Automation Testing Masterclass with JUnit 5 &amp; Mockito (Udemy)</p> </li> <li>Detailed course on JUnit 5 and Mockito</li> </ol>"},{"location":"java/java-testing/#tools","title":"Tools","text":"<ol> <li>SonarQube</li> <li> <p>Code quality and security platform with test coverage analysis</p> </li> <li> <p>IntelliJ IDEA Test Runner</p> </li> <li> <p>Integrated test execution and debugging</p> </li> <li> <p>Eclipse Test &amp; Performance Tools Platform</p> </li> <li> <p>Test tools for Eclipse IDE</p> </li> <li> <p>Jenkins CI/CD</p> </li> <li> <p>Automation server for continuous integration and testing</p> </li> <li> <p>Gatling</p> </li> <li>Load and performance testing tool</li> </ol>"},{"location":"java/java-testing/#practice-exercises","title":"Practice Exercises","text":""},{"location":"java/java-testing/#basic-testing-exercises","title":"Basic Testing Exercises","text":"<ol> <li> <p>Calculator Testing    Create a Calculator class with basic operations (add, subtract, multiply, divide) and write comprehensive unit tests.</p> </li> <li> <p>String Manipulation Library    Implement a utility class for string operations (reverse, capitalize, truncate) using TDD.</p> </li> <li> <p>Collection Wrapper    Create a custom collection class with operations like filter, map, and reduce, and test it thoroughly.</p> </li> </ol>"},{"location":"java/java-testing/#intermediate-testing-exercises","title":"Intermediate Testing Exercises","text":"<ol> <li> <p>Bank Account System    Implement a simple bank account system with deposit, withdraw, and transfer operations, using TDD.</p> </li> <li> <p>REST API Testing    Create a small REST API with Spring Boot and write both unit and integration tests.</p> </li> <li> <p>Mock External Services    Build a weather service that calls an external API, and test it using mocks.</p> </li> </ol>"},{"location":"java/java-testing/#advanced-testing-exercises","title":"Advanced Testing Exercises","text":"<ol> <li> <p>Concurrent Data Structure    Implement a thread-safe data structure (e.g., blocking queue) and test its concurrency behavior.</p> </li> <li> <p>Performance Testing    Create JMH benchmarks to compare different implementations of a sorting algorithm.</p> </li> <li> <p>End-to-End Testing    Develop a small web application and create E2E tests using Selenium or Playwright.</p> </li> <li> <p>Property-Based Testing     Implement sorting algorithms and test them using property-based testing to verify correctness.</p> </li> </ol>"},{"location":"kubernetes/kubernetes-basics/","title":"Kubernetes Basics","text":""},{"location":"kubernetes/kubernetes-basics/#overview","title":"Overview","text":"<p>This guide introduces the fundamental concepts of Kubernetes, its architecture, and basic components for container orchestration.</p>"},{"location":"kubernetes/kubernetes-basics/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of containers and Docker</li> <li>Familiarity with command-line operations</li> <li>Basic knowledge of YAML</li> <li>Understanding of distributed systems concepts</li> </ul>"},{"location":"kubernetes/kubernetes-basics/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Kubernetes architecture</li> <li>Learn core Kubernetes concepts</li> <li>Master basic kubectl commands</li> <li>Implement basic deployments</li> <li>Understand pod lifecycle</li> </ul>"},{"location":"kubernetes/kubernetes-basics/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Core Concepts</li> <li>Architecture</li> <li>Basic Components</li> <li>kubectl Commands</li> <li>Pod Management</li> </ol>"},{"location":"kubernetes/kubernetes-basics/#core-concepts","title":"Core Concepts","text":""},{"location":"kubernetes/kubernetes-basics/#what-is-kubernetes","title":"What is Kubernetes?","text":"<p>Kubernetes is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications.</p>"},{"location":"kubernetes/kubernetes-basics/#key-features","title":"Key Features","text":"<ol> <li>Container Orchestration</li> <li>Self-healing</li> <li>Automatic scaling</li> <li>Load balancing</li> <li>Rolling updates</li> <li>Service discovery</li> <li>Configuration management</li> </ol>"},{"location":"kubernetes/kubernetes-basics/#architecture","title":"Architecture","text":""},{"location":"kubernetes/kubernetes-basics/#control-plane-components","title":"Control Plane Components","text":"<ol> <li>kube-apiserver: API server that exposes the Kubernetes API</li> <li>etcd: Consistent and highly-available key-value store</li> <li>kube-scheduler: Assigns nodes to newly created pods</li> <li>kube-controller-manager: Runs controller processes</li> <li>cloud-controller-manager: Integrates with cloud provider APIs</li> </ol>"},{"location":"kubernetes/kubernetes-basics/#node-components","title":"Node Components","text":"<ol> <li>kubelet: Ensures containers are running in a pod</li> <li>kube-proxy: Maintains network rules on nodes</li> <li>Container Runtime: Software responsible for running containers</li> </ol>"},{"location":"kubernetes/kubernetes-basics/#basic-components","title":"Basic Components","text":""},{"location":"kubernetes/kubernetes-basics/#pods","title":"Pods","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-pod\n  labels:\n    app: nginx\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.14.2\n    ports:\n    - containerPort: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-basics/#replicasets","title":"ReplicaSets","text":"<pre><code>apiVersion: apps/v1\nkind: ReplicaSet\nmetadata:\n  name: nginx-replicaset\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n</code></pre>"},{"location":"kubernetes/kubernetes-basics/#deployments","title":"Deployments","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-basics/#kubectl-commands","title":"kubectl Commands","text":""},{"location":"kubernetes/kubernetes-basics/#basic-commands","title":"Basic Commands","text":"<pre><code># Get information about cluster components\nkubectl get nodes\nkubectl get pods\nkubectl get services\n\n# Create resources\nkubectl create -f deployment.yaml\n\n# Apply configuration\nkubectl apply -f config.yaml\n\n# Delete resources\nkubectl delete pod nginx-pod\n</code></pre>"},{"location":"kubernetes/kubernetes-basics/#common-operations","title":"Common Operations","text":"<pre><code># Port forwarding\nkubectl port-forward pod/nginx-pod 8080:80\n\n# Get pod logs\nkubectl logs nginx-pod\n\n# Execute command in pod\nkubectl exec -it nginx-pod -- /bin/bash\n\n# Scale deployment\nkubectl scale deployment nginx-deployment --replicas=5\n</code></pre>"},{"location":"kubernetes/kubernetes-basics/#pod-management","title":"Pod Management","text":""},{"location":"kubernetes/kubernetes-basics/#pod-lifecycle","title":"Pod Lifecycle","text":"<ol> <li>Pending: Pod accepted but containers not running</li> <li>Running: Pod bound to node, all containers running</li> <li>Succeeded: All containers terminated successfully</li> <li>Failed: All containers terminated, at least one failed</li> <li>Unknown: Pod state cannot be obtained</li> </ol>"},{"location":"kubernetes/kubernetes-basics/#health-checks","title":"Health Checks","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-pod\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.14.2\n    livenessProbe:\n      httpGet:\n        path: /health\n        port: 80\n      initialDelaySeconds: 3\n      periodSeconds: 3\n    readinessProbe:\n      httpGet:\n        path: /ready\n        port: 80\n      initialDelaySeconds: 5\n      periodSeconds: 5\n</code></pre>"},{"location":"kubernetes/kubernetes-basics/#best-practices","title":"Best Practices","text":"<ol> <li>Use declarative configuration</li> <li>Implement proper labels and selectors</li> <li>Set resource requests and limits</li> <li>Use namespaces for organization</li> <li>Implement proper health checks</li> <li>Use configuration management</li> <li>Follow security best practices</li> </ol>"},{"location":"kubernetes/kubernetes-basics/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Not setting resource limits</li> <li>Poor label management</li> <li>Missing health checks</li> <li>Inadequate monitoring</li> <li>Poor security practices</li> <li>Insufficient logging</li> </ol>"},{"location":"kubernetes/kubernetes-basics/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-basics/#complete-pod-configuration","title":"Complete Pod Configuration","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-app\n  labels:\n    app: web\n    environment: production\nspec:\n  containers:\n  - name: web-app\n    image: nginx:1.14.2\n    ports:\n    - containerPort: 80\n    resources:\n      requests:\n        memory: \"64Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"128Mi\"\n        cpu: \"500m\"\n    livenessProbe:\n      httpGet:\n        path: /health\n        port: 80\n      initialDelaySeconds: 3\n      periodSeconds: 3\n    readinessProbe:\n      httpGet:\n        path: /ready\n        port: 80\n      initialDelaySeconds: 5\n      periodSeconds: 5\n    env:\n    - name: ENVIRONMENT\n      value: \"production\"\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config\n</code></pre>"},{"location":"kubernetes/kubernetes-basics/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Documentation</li> <li>Kubernetes GitHub Repository</li> <li>Kubernetes Patterns</li> <li>Kubernetes The Hard Way</li> </ul>"},{"location":"kubernetes/kubernetes-basics/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Create a basic pod configuration</li> <li>Deploy a multi-container pod</li> <li>Implement health checks</li> <li>Scale a deployment</li> <li>Configure pod resources </li> </ol>"},{"location":"kubernetes/kubernetes-best-practices/","title":"Kubernetes Best Practices","text":""},{"location":"kubernetes/kubernetes-best-practices/#overview","title":"Overview","text":"<p>This guide covers best practices for running Kubernetes in production, including security, scalability, reliability, and operational excellence.</p>"},{"location":"kubernetes/kubernetes-best-practices/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of container orchestration</li> <li>Familiarity with DevOps practices</li> <li>Understanding of cloud-native principles</li> </ul>"},{"location":"kubernetes/kubernetes-best-practices/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Kubernetes best practices</li> <li>Learn security hardening</li> <li>Master scalability patterns</li> <li>Implement reliability measures</li> <li>Configure operational excellence</li> </ul>"},{"location":"kubernetes/kubernetes-best-practices/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Security Best Practices</li> <li>Scalability Best Practices</li> <li>Reliability Best Practices</li> <li>Operational Best Practices</li> <li>Resource Management</li> </ol>"},{"location":"kubernetes/kubernetes-best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"kubernetes/kubernetes-best-practices/#pod-security-context","title":"Pod Security Context","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    runAsGroup: 3000\n    fsGroup: 2000\n  containers:\n  - name: secure-container\n    image: nginx\n    securityContext:\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      capabilities:\n        drop:\n        - ALL\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#network-policies","title":"Network Policies","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#rbac-configuration","title":"RBAC Configuration","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: minimal-access\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: minimal-access-binding\nsubjects:\n- kind: ServiceAccount\n  name: app-service-account\nroleRef:\n  kind: Role\n  name: minimal-access\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#scalability-best-practices","title":"Scalability Best Practices","text":""},{"location":"kubernetes/kubernetes-best-practices/#horizontal-pod-autoscaling","title":"Horizontal Pod Autoscaling","text":"<pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: app-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: app\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#resource-requests-and-limits","title":"Resource Requests and Limits","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: resource-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    resources:\n      requests:\n        memory: \"64Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"128Mi\"\n        cpu: \"500m\"\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#reliability-best-practices","title":"Reliability Best Practices","text":""},{"location":"kubernetes/kubernetes-best-practices/#liveness-and-readiness-probes","title":"Liveness and Readiness Probes","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: probe-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    livenessProbe:\n      httpGet:\n        path: /healthz\n        port: 8080\n      initialDelaySeconds: 3\n      periodSeconds: 3\n    readinessProbe:\n      httpGet:\n        path: /ready\n        port: 8080\n      initialDelaySeconds: 5\n      periodSeconds: 5\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#pod-disruption-budget","title":"Pod Disruption Budget","text":"<pre><code>apiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: app-pdb\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: web\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#operational-best-practices","title":"Operational Best Practices","text":""},{"location":"kubernetes/kubernetes-best-practices/#resource-quotas","title":"Resource Quotas","text":"<pre><code>apiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: compute-quota\nspec:\n  hard:\n    requests.cpu: \"4\"\n    requests.memory: 4Gi\n    limits.cpu: \"8\"\n    limits.memory: 8Gi\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#limit-ranges","title":"Limit Ranges","text":"<pre><code>apiVersion: v1\nkind: LimitRange\nmetadata:\n  name: default-limits\nspec:\n  limits:\n  - default:\n      memory: 256Mi\n      cpu: 500m\n    defaultRequest:\n      memory: 128Mi\n      cpu: 250m\n    type: Container\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#resource-management","title":"Resource Management","text":""},{"location":"kubernetes/kubernetes-best-practices/#namespace-configuration","title":"Namespace Configuration","text":"<pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: production\n  labels:\n    name: production\n    environment: prod\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#resource-labels-and-annotations","title":"Resource Labels and Annotations","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\n  labels:\n    app: web\n    environment: production\n    team: frontend\n  annotations:\n    description: \"Web application deployment\"\n    contact: \"team@example.com\"\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web\n  template:\n    metadata:\n      labels:\n        app: web\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-best-practices/#complete-production-setup","title":"Complete Production Setup","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: production-app\n  labels:\n    app: production\n    environment: prod\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: production\n  template:\n    metadata:\n      labels:\n        app: production\n    spec:\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1000\n      containers:\n      - name: app\n        image: nginx:1.21\n        ports:\n        - containerPort: 8080\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        securityContext:\n          allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n          capabilities:\n            drop:\n            - ALL\n---\napiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: production-pdb\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: production\n---\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: production-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: production-app\n  minReplicas: 3\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#monitoring-and-logging-setup","title":"Monitoring and Logging Setup","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: app-monitor\nspec:\n  selector:\n    matchLabels:\n      app: production\n  endpoints:\n  - port: metrics\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: fluentd-config\ndata:\n  fluent.conf: |\n    &lt;source&gt;\n      @type tail\n      path /var/log/containers/*.log\n      pos_file /var/log/fluentd-containers.log.pos\n      tag kubernetes.*\n      read_from_head true\n      &lt;parse&gt;\n        @type json\n      &lt;/parse&gt;\n    &lt;/source&gt;\n</code></pre>"},{"location":"kubernetes/kubernetes-best-practices/#best-practices-checklist","title":"Best Practices Checklist","text":""},{"location":"kubernetes/kubernetes-best-practices/#security","title":"Security","text":"<ol> <li>Enable RBAC</li> <li>Use Pod Security Contexts</li> <li>Implement Network Policies</li> <li>Secure Secrets Management</li> <li>Regular Security Updates</li> <li>Image Scanning</li> <li>Audit Logging</li> </ol>"},{"location":"kubernetes/kubernetes-best-practices/#scalability","title":"Scalability","text":"<ol> <li>Use HPA</li> <li>Set Resource Requests/Limits</li> <li>Implement Load Balancing</li> <li>Use Node Autoscaling</li> <li>Optimize Performance</li> <li>Cache Effectively</li> <li>Use CDN</li> </ol>"},{"location":"kubernetes/kubernetes-best-practices/#reliability","title":"Reliability","text":"<ol> <li>Use Health Checks</li> <li>Implement PodDisruptionBudgets</li> <li>Set Up Monitoring</li> <li>Configure Logging</li> <li>Backup Critical Data</li> <li>Disaster Recovery Plan</li> <li>High Availability Setup</li> </ol>"},{"location":"kubernetes/kubernetes-best-practices/#operations","title":"Operations","text":"<ol> <li>Use Resource Quotas</li> <li>Implement Limit Ranges</li> <li>Label Resources</li> <li>Document Everything</li> <li>Automate Deployments</li> <li>Monitor Costs</li> <li>Regular Maintenance</li> </ol>"},{"location":"kubernetes/kubernetes-best-practices/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Production Best Practices</li> <li>Security Best Practices</li> <li>Resource Management</li> <li>High Availability</li> </ul>"},{"location":"kubernetes/kubernetes-best-practices/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Implement security best practices</li> <li>Configure scalability features</li> <li>Set up reliability measures</li> <li>Establish operational procedures</li> <li>Create production checklist </li> </ol>"},{"location":"kubernetes/kubernetes-config-secrets/","title":"Kubernetes Configuration and Secrets","text":""},{"location":"kubernetes/kubernetes-config-secrets/#overview","title":"Overview","text":"<p>This guide covers configuration management and secrets handling in Kubernetes, including ConfigMaps, Secrets, and best practices for managing application configuration.</p>"},{"location":"kubernetes/kubernetes-config-secrets/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of YAML configuration</li> <li>Familiarity with security concepts</li> <li>Understanding of environment variables</li> </ul>"},{"location":"kubernetes/kubernetes-config-secrets/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand ConfigMaps and Secrets</li> <li>Learn configuration management</li> <li>Master secrets handling</li> <li>Implement secure practices</li> <li>Configure applications properly</li> </ul>"},{"location":"kubernetes/kubernetes-config-secrets/#table-of-contents","title":"Table of Contents","text":"<ol> <li>ConfigMaps</li> <li>Secrets</li> <li>Environment Variables</li> <li>Volume Mounts</li> <li>Security Best Practices</li> </ol>"},{"location":"kubernetes/kubernetes-config-secrets/#configmaps","title":"ConfigMaps","text":""},{"location":"kubernetes/kubernetes-config-secrets/#basic-configmap","title":"Basic ConfigMap","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"postgresql://db:5432\"\n  api_endpoint: \"http://api.example.com\"\n  app.properties: |\n    environment=production\n    log.level=info\n    max.connections=100\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#using-configmap-in-pod","title":"Using ConfigMap in Pod","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0\n    envFrom:\n    - configMapRef:\n        name: app-config\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#configmap-as-volume","title":"ConfigMap as Volume","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#secrets","title":"Secrets","text":""},{"location":"kubernetes/kubernetes-config-secrets/#basic-secret","title":"Basic Secret","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: app-secrets\ntype: Opaque\ndata:\n  db_password: base64encodedpassword\n  api_key: base64encodedapikey\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#using-secrets-in-pod","title":"Using Secrets in Pod","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0\n    env:\n    - name: DB_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: app-secrets\n          key: db_password\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#tls-secret","title":"TLS Secret","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: tls-secret\ntype: kubernetes.io/tls\ndata:\n  tls.crt: base64encodedcert\n  tls.key: base64encodedkey\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#environment-variables","title":"Environment Variables","text":""},{"location":"kubernetes/kubernetes-config-secrets/#direct-environment-variables","title":"Direct Environment Variables","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0\n    env:\n    - name: ENVIRONMENT\n      value: \"production\"\n    - name: LOG_LEVEL\n      value: \"info\"\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#mixed-configuration-sources","title":"Mixed Configuration Sources","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0\n    env:\n    - name: DATABASE_URL\n      valueFrom:\n        configMapKeyRef:\n          name: app-config\n          key: database_url\n    - name: API_KEY\n      valueFrom:\n        secretKeyRef:\n          name: app-secrets\n          key: api_key\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#volume-mounts","title":"Volume Mounts","text":""},{"location":"kubernetes/kubernetes-config-secrets/#configmap-volume-mount","title":"ConfigMap Volume Mount","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0\n    volumeMounts:\n    - name: config-volume\n      mountPath: /etc/config\n      readOnly: true\n  volumes:\n  - name: config-volume\n    configMap:\n      name: app-config\n      items:\n      - key: app.properties\n        path: application.properties\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#secret-volume-mount","title":"Secret Volume Mount","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0\n    volumeMounts:\n    - name: secrets-volume\n      mountPath: /etc/secrets\n      readOnly: true\n  volumes:\n  - name: secrets-volume\n    secret:\n      secretName: app-secrets\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#security-best-practices","title":"Security Best Practices","text":""},{"location":"kubernetes/kubernetes-config-secrets/#secret-encryption","title":"Secret Encryption","text":"<pre><code>apiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nmetadata:\n  name: encryption-config\nresources:\n  - resources:\n    - secrets\n    providers:\n    - aescbc:\n        keys:\n        - name: key1\n          secret: &lt;base64-encoded-key&gt;\n    - identity: {}\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#pod-security-context","title":"Pod Security Context","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  securityContext:\n    runAsUser: 1000\n    runAsGroup: 3000\n    fsGroup: 2000\n  containers:\n  - name: app\n    image: myapp:1.0\n    securityContext:\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate configuration methods</li> <li>Implement proper secret management</li> <li>Follow least privilege principle</li> <li>Encrypt sensitive data</li> <li>Regular secret rotation</li> <li>Implement proper access controls</li> <li>Monitor configuration changes</li> </ol>"},{"location":"kubernetes/kubernetes-config-secrets/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Hardcoding secrets</li> <li>Insufficient access controls</li> <li>Poor secret rotation</li> <li>Insecure secret storage</li> <li>Missing encryption</li> <li>Configuration sprawl</li> </ol>"},{"location":"kubernetes/kubernetes-config-secrets/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-config-secrets/#complete-configuration-example","title":"Complete Configuration Example","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  application.yaml: |\n    server:\n      port: 8080\n    database:\n      url: jdbc:postgresql://db:5432/myapp\n      pool:\n        max-size: 20\n        idle-timeout: 300000\n    logging:\n      level:\n        root: INFO\n        com.example: DEBUG\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: app-secrets\ntype: Opaque\ndata:\n  db-password: base64encodedpassword\n  api-key: base64encodedapikey\n  jwt-secret: base64encodedjwtsecret\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        image: myapp:1.0\n        env:\n        - name: SPRING_CONFIG_LOCATION\n          value: /etc/config/application.yaml\n        - name: DB_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: db-password\n        volumeMounts:\n        - name: config-volume\n          mountPath: /etc/config\n          readOnly: true\n        - name: secrets-volume\n          mountPath: /etc/secrets\n          readOnly: true\n      volumes:\n      - name: config-volume\n        configMap:\n          name: app-config\n      - name: secrets-volume\n        secret:\n          secretName: app-secrets\n</code></pre>"},{"location":"kubernetes/kubernetes-config-secrets/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes ConfigMaps Documentation</li> <li>Kubernetes Secrets Documentation</li> <li>Pod Security Standards</li> <li>Encryption at Rest</li> </ul>"},{"location":"kubernetes/kubernetes-config-secrets/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Create and use ConfigMaps</li> <li>Implement secret management</li> <li>Configure environment variables</li> <li>Set up volume mounts</li> <li>Implement security best practices </li> </ol>"},{"location":"kubernetes/kubernetes-deployment/","title":"Kubernetes Deployments","text":""},{"location":"kubernetes/kubernetes-deployment/#overview","title":"Overview","text":"<p>This guide covers deployment strategies, configurations, and best practices for managing application deployments in Kubernetes.</p>"},{"location":"kubernetes/kubernetes-deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of kubectl commands</li> <li>Familiarity with YAML configuration</li> <li>Understanding of container lifecycle</li> </ul>"},{"location":"kubernetes/kubernetes-deployment/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand deployment strategies</li> <li>Learn deployment configuration</li> <li>Master rolling updates</li> <li>Implement deployment patterns</li> <li>Handle deployment rollbacks</li> </ul>"},{"location":"kubernetes/kubernetes-deployment/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Deployment Basics</li> <li>Deployment Strategies</li> <li>Configuration Management</li> <li>Rolling Updates</li> <li>Rollback Management</li> </ol>"},{"location":"kubernetes/kubernetes-deployment/#deployment-basics","title":"Deployment Basics","text":""},{"location":"kubernetes/kubernetes-deployment/#basic-deployment-structure","title":"Basic Deployment Structure","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#deployment-components","title":"Deployment Components","text":"<ol> <li>metadata: Name and labels for the deployment</li> <li>spec.replicas: Number of desired pods</li> <li>spec.selector: How the deployment finds pods to manage</li> <li>spec.template: Pod template specification</li> </ol>"},{"location":"kubernetes/kubernetes-deployment/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"kubernetes/kubernetes-deployment/#rolling-update","title":"Rolling Update","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#blue-green-deployment","title":"Blue-Green Deployment","text":"<pre><code># Blue deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-blue\nspec:\n  template:\n    metadata:\n      labels:\n        app: myapp\n        version: blue\n\n---\n# Green deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-green\nspec:\n  template:\n    metadata:\n      labels:\n        app: myapp\n        version: green\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#canary-deployment","title":"Canary Deployment","text":"<pre><code># Main deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-main\nspec:\n  replicas: 9\n  template:\n    metadata:\n      labels:\n        app: myapp\n        version: stable\n\n---\n# Canary deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-canary\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: myapp\n        version: canary\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#configuration-management","title":"Configuration Management","text":""},{"location":"kubernetes/kubernetes-deployment/#environment-variables","title":"Environment Variables","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        image: myapp:1.0\n        env:\n        - name: DATABASE_URL\n          value: \"postgresql://db:5432\"\n        - name: API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: api-key\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#configmaps","title":"ConfigMaps","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  app.properties: |\n    environment=production\n    log.level=info\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        volumeMounts:\n        - name: config-volume\n          mountPath: /etc/config\n      volumes:\n      - name: config-volume\n        configMap:\n          name: app-config\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#rolling-updates","title":"Rolling Updates","text":""},{"location":"kubernetes/kubernetes-deployment/#update-strategy","title":"Update Strategy","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  minReadySeconds: 5\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#commands-for-updates","title":"Commands for Updates","text":"<pre><code># Update image\nkubectl set image deployment/app-deployment app=myapp:2.0\n\n# Check rollout status\nkubectl rollout status deployment/app-deployment\n\n# Pause rollout\nkubectl rollout pause deployment/app-deployment\n\n# Resume rollout\nkubectl rollout resume deployment/app-deployment\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#rollback-management","title":"Rollback Management","text":""},{"location":"kubernetes/kubernetes-deployment/#rollback-configuration","title":"Rollback Configuration","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  revisionHistoryLimit: 10\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#rollback-commands","title":"Rollback Commands","text":"<pre><code># View rollout history\nkubectl rollout history deployment/app-deployment\n\n# Rollback to previous version\nkubectl rollout undo deployment/app-deployment\n\n# Rollback to specific revision\nkubectl rollout undo deployment/app-deployment --to-revision=2\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#best-practices","title":"Best Practices","text":"<ol> <li>Use declarative configuration</li> <li>Implement proper health checks</li> <li>Set resource limits</li> <li>Use meaningful labels</li> <li>Configure proper update strategy</li> <li>Maintain revision history</li> <li>Implement proper monitoring</li> </ol>"},{"location":"kubernetes/kubernetes-deployment/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Insufficient health checks</li> <li>Poor resource management</li> <li>Missing rollback strategy</li> <li>Inadequate monitoring</li> <li>Poor version control</li> <li>Insufficient testing</li> </ol>"},{"location":"kubernetes/kubernetes-deployment/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-deployment/#complete-deployment-configuration","title":"Complete Deployment Configuration","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\n  labels:\n    app: web\n    environment: production\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: web\n  template:\n    metadata:\n      labels:\n        app: web\n    spec:\n      containers:\n      - name: web-app\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n        resources:\n          requests:\n            memory: \"64Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 80\n          initialDelaySeconds: 3\n          periodSeconds: 3\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 80\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        env:\n        - name: ENVIRONMENT\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: environment\n        - name: API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: api-key\n        volumeMounts:\n        - name: config-volume\n          mountPath: /etc/config\n      volumes:\n      - name: config-volume\n        configMap:\n          name: app-config\n</code></pre>"},{"location":"kubernetes/kubernetes-deployment/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Deployments Documentation</li> <li>Deployment Strategies</li> <li>Rolling Update Configuration</li> <li>Deployment Best Practices</li> </ul>"},{"location":"kubernetes/kubernetes-deployment/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Create a basic deployment</li> <li>Implement rolling updates</li> <li>Configure blue-green deployment</li> <li>Set up canary deployment</li> <li>Manage deployment rollbacks </li> </ol>"},{"location":"kubernetes/kubernetes-monitoring/","title":"Kubernetes Monitoring","text":""},{"location":"kubernetes/kubernetes-monitoring/#overview","title":"Overview","text":"<p>This guide covers monitoring strategies in Kubernetes, including metrics collection, logging, tracing, and best practices for monitoring cluster and application health.</p>"},{"location":"kubernetes/kubernetes-monitoring/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of monitoring concepts</li> <li>Familiarity with Prometheus and Grafana</li> <li>Understanding of logging systems</li> </ul>"},{"location":"kubernetes/kubernetes-monitoring/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand monitoring concepts</li> <li>Learn metrics collection</li> <li>Master logging strategies</li> <li>Implement tracing</li> <li>Configure alerts</li> </ul>"},{"location":"kubernetes/kubernetes-monitoring/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Metrics Collection</li> <li>Logging</li> <li>Distributed Tracing</li> <li>Alerting</li> <li>Monitoring Tools</li> </ol>"},{"location":"kubernetes/kubernetes-monitoring/#metrics-collection","title":"Metrics Collection","text":""},{"location":"kubernetes/kubernetes-monitoring/#prometheus-configuration","title":"Prometheus Configuration","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: Prometheus\nmetadata:\n  name: prometheus\nspec:\n  serviceAccountName: prometheus\n  serviceMonitorSelector:\n    matchLabels:\n      team: frontend\n  resources:\n    requests:\n      memory: 400Mi\n  enableAdminAPI: false\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#service-monitor","title":"Service Monitor","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: app-monitor\n  labels:\n    team: frontend\nspec:\n  selector:\n    matchLabels:\n      app: web\n  endpoints:\n  - port: metrics\n    interval: 15s\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#metrics-endpoint","title":"Metrics Endpoint","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: app-service\n  annotations:\n    prometheus.io/scrape: 'true'\n    prometheus.io/port: '9090'\nspec:\n  selector:\n    app: web\n  ports:\n  - name: metrics\n    port: 9090\n    targetPort: metrics\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#logging","title":"Logging","text":""},{"location":"kubernetes/kubernetes-monitoring/#fluentd-configuration","title":"Fluentd Configuration","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: fluentd-config\ndata:\n  fluent.conf: |\n    &lt;source&gt;\n      @type tail\n      path /var/log/containers/*.log\n      pos_file /var/log/fluentd-containers.log.pos\n      tag kubernetes.*\n      read_from_head true\n      &lt;parse&gt;\n        @type json\n        time_key time\n        time_format %Y-%m-%dT%H:%M:%S.%NZ\n      &lt;/parse&gt;\n    &lt;/source&gt;\n    &lt;match kubernetes.**&gt;\n      @type elasticsearch\n      host elasticsearch-logging\n      port 9200\n      logstash_format true\n      logstash_prefix k8s\n    &lt;/match&gt;\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#elasticsearch-configuration","title":"Elasticsearch Configuration","text":"<pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: elasticsearch\nspec:\n  serviceName: elasticsearch\n  replicas: 3\n  selector:\n    matchLabels:\n      app: elasticsearch\n  template:\n    metadata:\n      labels:\n        app: elasticsearch\n    spec:\n      containers:\n      - name: elasticsearch\n        image: elasticsearch:7.9.3\n        env:\n        - name: discovery.type\n          value: single-node\n        ports:\n        - containerPort: 9200\n          name: http\n        - containerPort: 9300\n          name: transport\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#distributed-tracing","title":"Distributed Tracing","text":""},{"location":"kubernetes/kubernetes-monitoring/#jaeger-configuration","title":"Jaeger Configuration","text":"<pre><code>apiVersion: jaegertracing.io/v1\nkind: Jaeger\nmetadata:\n  name: jaeger\nspec:\n  strategy: production\n  storage:\n    type: elasticsearch\n    options:\n      es:\n        server-urls: http://elasticsearch:9200\n  ingress:\n    enabled: true\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#opentelemetry-configuration","title":"OpenTelemetry Configuration","text":"<pre><code>apiVersion: opentelemetry.io/v1alpha1\nkind: OpenTelemetryCollector\nmetadata:\n  name: otel\nspec:\n  config: |\n    receivers:\n      otlp:\n        protocols:\n          grpc:\n            endpoint: 0.0.0.0:4317\n    processors:\n      batch:\n    exporters:\n      jaeger:\n        endpoint: jaeger-collector:14250\n        tls:\n          insecure: true\n    service:\n      pipelines:\n        traces:\n          receivers: [otlp]\n          processors: [batch]\n          exporters: [jaeger]\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#alerting","title":"Alerting","text":""},{"location":"kubernetes/kubernetes-monitoring/#alert-manager-configuration","title":"Alert Manager Configuration","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: AlertmanagerConfig\nmetadata:\n  name: alert-config\nspec:\n  route:\n    receiver: 'slack'\n    group_by: ['alertname', 'cluster', 'service']\n  receivers:\n  - name: 'slack'\n    slack_configs:\n    - api_url: 'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'\n      channel: '#alerts'\n      send_resolved: true\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#alert-rules","title":"Alert Rules","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: PrometheusRule\nmetadata:\n  name: prometheus-rules\nspec:\n  groups:\n  - name: node\n    rules:\n    - alert: HighCPUUsage\n      expr: node_cpu_usage_percentage &gt; 80\n      for: 5m\n      labels:\n        severity: warning\n      annotations:\n        description: CPU usage is above 80% for 5 minutes\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#monitoring-tools","title":"Monitoring Tools","text":""},{"location":"kubernetes/kubernetes-monitoring/#grafana-dashboard","title":"Grafana Dashboard","text":"<pre><code>apiVersion: integreatly.org/v1alpha1\nkind: GrafanaDashboard\nmetadata:\n  name: kubernetes-dashboard\nspec:\n  json: |\n    {\n      \"dashboard\": {\n        \"id\": null,\n        \"title\": \"Kubernetes Cluster Monitoring\",\n        \"panels\": [\n          {\n            \"title\": \"CPU Usage\",\n            \"type\": \"graph\",\n            \"datasource\": \"Prometheus\",\n            \"targets\": [\n              {\n                \"expr\": \"sum(rate(container_cpu_usage_seconds_total[5m])) by (pod)\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#prometheus-operator","title":"Prometheus Operator","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: prometheus-operator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: prometheus-operator\n  template:\n    metadata:\n      labels:\n        app: prometheus-operator\n    spec:\n      containers:\n      - name: prometheus-operator\n        image: quay.io/prometheus-operator/prometheus-operator:v0.50.0\n        args:\n        - --kubelet-service=kube-system/kubelet\n        - --config-reloader-image=jimmidyson/configmap-reload:v0.5.0\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#best-practices","title":"Best Practices","text":"<ol> <li>Implement comprehensive monitoring</li> <li>Configure proper log retention</li> <li>Set up distributed tracing</li> <li>Implement meaningful alerts</li> <li>Use appropriate monitoring tools</li> <li>Monitor cluster health</li> <li>Implement proper dashboards</li> </ol>"},{"location":"kubernetes/kubernetes-monitoring/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Insufficient monitoring coverage</li> <li>Poor log management</li> <li>Missing alerts</li> <li>Inadequate resource monitoring</li> <li>Poor visualization</li> <li>Alert fatigue</li> </ol>"},{"location":"kubernetes/kubernetes-monitoring/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-monitoring/#complete-monitoring-stack","title":"Complete Monitoring Stack","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: Prometheus\nmetadata:\n  name: prometheus\nspec:\n  serviceAccountName: prometheus\n  serviceMonitorSelector:\n    matchLabels:\n      team: frontend\n  resources:\n    requests:\n      memory: 400Mi\n  alerting:\n    alertmanagers:\n    - name: alertmanager-main\n      namespace: monitoring\n      port: web\n---\napiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: app-monitor\nspec:\n  selector:\n    matchLabels:\n      app: web\n  endpoints:\n  - port: metrics\n    interval: 15s\n---\napiVersion: monitoring.coreos.com/v1\nkind: AlertmanagerConfig\nmetadata:\n  name: alert-config\nspec:\n  route:\n    receiver: 'slack'\n    group_by: ['alertname', 'cluster', 'service']\n  receivers:\n  - name: 'slack'\n    slack_configs:\n    - api_url: 'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'\n      channel: '#alerts'\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#logging-configuration","title":"Logging Configuration","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: fluentd-config\ndata:\n  fluent.conf: |\n    &lt;source&gt;\n      @type tail\n      path /var/log/containers/*.log\n      pos_file /var/log/fluentd-containers.log.pos\n      tag kubernetes.*\n      read_from_head true\n      &lt;parse&gt;\n        @type json\n      &lt;/parse&gt;\n    &lt;/source&gt;\n    &lt;match kubernetes.**&gt;\n      @type elasticsearch\n      host elasticsearch-logging\n      port 9200\n      logstash_format true\n    &lt;/match&gt;\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: fluentd\nspec:\n  selector:\n    matchLabels:\n      name: fluentd\n  template:\n    metadata:\n      labels:\n        name: fluentd\n    spec:\n      containers:\n      - name: fluentd\n        image: fluent/fluentd-kubernetes-daemonset:v1.12.0-debian-elasticsearch7-1.1\n        volumeMounts:\n        - name: varlog\n          mountPath: /var/log\n        - name: config\n          mountPath: /fluentd/etc\n      volumes:\n      - name: varlog\n        hostPath:\n          path: /var/log\n      - name: config\n        configMap:\n          name: fluentd-config\n</code></pre>"},{"location":"kubernetes/kubernetes-monitoring/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Prometheus Documentation</li> <li>Grafana Documentation</li> <li>Jaeger Tracing</li> <li>ELK Stack on Kubernetes</li> </ul>"},{"location":"kubernetes/kubernetes-monitoring/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Set up Prometheus monitoring</li> <li>Configure logging with ELK stack</li> <li>Implement distributed tracing</li> <li>Create Grafana dashboards</li> <li>Configure alerting rules </li> </ol>"},{"location":"kubernetes/kubernetes-networking/","title":"Kubernetes Networking","text":""},{"location":"kubernetes/kubernetes-networking/#overview","title":"Overview","text":"<p>This guide covers networking concepts in Kubernetes, including services, ingress controllers, network policies, and DNS configuration.</p>"},{"location":"kubernetes/kubernetes-networking/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of networking principles</li> <li>Familiarity with load balancing</li> <li>Understanding of DNS</li> </ul>"},{"location":"kubernetes/kubernetes-networking/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Kubernetes networking</li> <li>Learn service types</li> <li>Master ingress configuration</li> <li>Implement network policies</li> <li>Configure DNS</li> </ul>"},{"location":"kubernetes/kubernetes-networking/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Services</li> <li>Ingress</li> <li>Network Policies</li> <li>DNS Configuration</li> <li>Load Balancing</li> </ol>"},{"location":"kubernetes/kubernetes-networking/#services","title":"Services","text":""},{"location":"kubernetes/kubernetes-networking/#clusterip-service","title":"ClusterIP Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: ClusterIP\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#nodeport-service","title":"NodePort Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: NodePort\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n      nodePort: 30080\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#loadbalancer-service","title":"LoadBalancer Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: web-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: web\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#ingress","title":"Ingress","text":""},{"location":"kubernetes/kubernetes-networking/#basic-ingress","title":"Basic Ingress","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-service\n            port:\n              number: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#tls-ingress","title":"TLS Ingress","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: tls-ingress\nspec:\n  tls:\n  - hosts:\n    - secure.example.com\n    secretName: tls-secret\n  rules:\n  - host: secure.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: secure-service\n            port:\n              number: 443\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#path-based-routing","title":"Path-based Routing","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: path-ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /v1\n        pathType: Prefix\n        backend:\n          service:\n            name: api-v1-service\n            port:\n              number: 80\n      - path: /v2\n        pathType: Prefix\n        backend:\n          service:\n            name: api-v2-service\n            port:\n              number: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#network-policies","title":"Network Policies","text":""},{"location":"kubernetes/kubernetes-networking/#default-deny-policy","title":"Default Deny Policy","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#allow-specific-traffic","title":"Allow Specific Traffic","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 8080\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: database\n    ports:\n    - protocol: TCP\n      port: 5432\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#dns-configuration","title":"DNS Configuration","text":""},{"location":"kubernetes/kubernetes-networking/#coredns-configmap","title":"CoreDNS ConfigMap","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: coredns\n  namespace: kube-system\ndata:\n  Corefile: |\n    .:53 {\n        errors\n        health\n        kubernetes cluster.local in-addr.arpa ip6.arpa {\n           pods insecure\n           upstream\n           fallthrough in-addr.arpa ip6.arpa\n        }\n        prometheus :9153\n        forward . /etc/resolv.conf\n        cache 30\n        loop\n        reload\n        loadbalance\n    }\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#custom-dns-entry","title":"Custom DNS Entry","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: custom-dns\n  annotations:\n    external-dns.alpha.kubernetes.io/hostname: custom.example.com\nspec:\n  type: ExternalName\n  externalName: service.namespace.svc.cluster.local\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#load-balancing","title":"Load Balancing","text":""},{"location":"kubernetes/kubernetes-networking/#external-load-balancer","title":"External Load Balancer","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: external-lb\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: nlb\nspec:\n  type: LoadBalancer\n  selector:\n    app: web\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#internal-load-balancer","title":"Internal Load Balancer","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: internal-lb\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-internal: \"true\"\nspec:\n  type: LoadBalancer\n  selector:\n    app: internal-app\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate service types</li> <li>Implement ingress controllers</li> <li>Configure network policies</li> <li>Optimize DNS settings</li> <li>Use load balancing effectively</li> <li>Monitor network performance</li> <li>Implement security measures</li> </ol>"},{"location":"kubernetes/kubernetes-networking/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Incorrect service configuration</li> <li>Missing network policies</li> <li>DNS resolution issues</li> <li>Load balancer misconfiguration</li> <li>Poor ingress routing</li> <li>Network performance issues</li> </ol>"},{"location":"kubernetes/kubernetes-networking/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-networking/#complete-networking-stack","title":"Complete Networking Stack","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: web-service\nspec:\n  type: ClusterIP\n  selector:\n    app: web\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-service\n            port:\n              number: 80\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: web-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: web\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: frontend\n    ports:\n    - protocol: TCP\n      port: 80\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: backend\n    ports:\n    - protocol: TCP\n      port: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#service-mesh-configuration","title":"Service Mesh Configuration","text":"<pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: web-vs\nspec:\n  hosts:\n  - \"example.com\"\n  gateways:\n  - web-gateway\n  http:\n  - match:\n    - uri:\n        prefix: /v1\n    route:\n    - destination:\n        host: web-service-v1\n        port:\n          number: 80\n  - match:\n    - uri:\n        prefix: /v2\n    route:\n    - destination:\n        host: web-service-v2\n        port:\n          number: 80\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: web-dr\nspec:\n  host: web-service\n  trafficPolicy:\n    loadBalancer:\n      simple: ROUND_ROBIN\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n</code></pre>"},{"location":"kubernetes/kubernetes-networking/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Networking</li> <li>Ingress Controllers</li> <li>Network Policies</li> <li>DNS for Services and Pods</li> </ul>"},{"location":"kubernetes/kubernetes-networking/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Configure different service types</li> <li>Set up ingress controllers</li> <li>Implement network policies</li> <li>Configure DNS settings</li> <li>Set up load balancing </li> </ol>"},{"location":"kubernetes/kubernetes-scaling/","title":"Kubernetes Scaling","text":""},{"location":"kubernetes/kubernetes-scaling/#overview","title":"Overview","text":"<p>This guide covers scaling strategies in Kubernetes, including horizontal and vertical scaling, autoscaling configurations, and best practices for managing application scale.</p>"},{"location":"kubernetes/kubernetes-scaling/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of pod and deployment management</li> <li>Familiarity with resource metrics</li> <li>Understanding of load balancing</li> </ul>"},{"location":"kubernetes/kubernetes-scaling/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand scaling concepts</li> <li>Learn horizontal pod scaling</li> <li>Master vertical scaling</li> <li>Implement autoscaling</li> <li>Configure cluster scaling</li> </ul>"},{"location":"kubernetes/kubernetes-scaling/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Horizontal Pod Scaling</li> <li>Vertical Pod Scaling</li> <li>Cluster Autoscaling</li> <li>Custom Metrics Scaling</li> <li>Best Practices</li> </ol>"},{"location":"kubernetes/kubernetes-scaling/#horizontal-pod-scaling","title":"Horizontal Pod Scaling","text":""},{"location":"kubernetes/kubernetes-scaling/#horizontalpodautoscaler","title":"HorizontalPodAutoscaler","text":"<pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: app-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: app-deployment\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#multiple-metrics","title":"Multiple Metrics","text":"<pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: app-hpa-multi\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: app-deployment\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#vertical-pod-scaling","title":"Vertical Pod Scaling","text":""},{"location":"kubernetes/kubernetes-scaling/#verticalpodautoscaler","title":"VerticalPodAutoscaler","text":"<pre><code>apiVersion: autoscaling.k8s.io/v1\nkind: VerticalPodAutoscaler\nmetadata:\n  name: app-vpa\nspec:\n  targetRef:\n    apiVersion: \"apps/v1\"\n    kind: Deployment\n    name: app-deployment\n  updatePolicy:\n    updateMode: \"Auto\"\n  resourcePolicy:\n    containerPolicies:\n    - containerName: '*'\n      minAllowed:\n        cpu: 100m\n        memory: 50Mi\n      maxAllowed:\n        cpu: 1\n        memory: 500Mi\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#manual-resource-scaling","title":"Manual Resource Scaling","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        resources:\n          requests:\n            memory: \"64Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#cluster-autoscaling","title":"Cluster Autoscaling","text":""},{"location":"kubernetes/kubernetes-scaling/#cluster-autoscaler-configuration","title":"Cluster Autoscaler Configuration","text":"<pre><code>apiVersion: \"autoscaling.k8s.io/v1\"\nkind: ClusterAutoscaler\nmetadata:\n  name: cluster-autoscaler\nspec:\n  scaleDown:\n    enabled: true\n    delayAfterAdd: 10m\n    delayAfterDelete: 10s\n    delayAfterFailure: 3m\n  scaleUp:\n    enabled: true\n    delayAfterAdd: 10s\n    delayAfterDelete: 10s\n    delayAfterFailure: 3m\n  minSize: 1\n  maxSize: 10\n  targetNodeUtilization: 50\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#node-group-configuration","title":"Node Group Configuration","text":"<pre><code>apiVersion: \"autoscaling.k8s.io/v1\"\nkind: NodeGroup\nmetadata:\n  name: worker-nodes\nspec:\n  minSize: 1\n  maxSize: 5\n  machineType: \"t2.medium\"\n  labels:\n    role: worker\n  taints: []\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#custom-metrics-scaling","title":"Custom Metrics Scaling","text":""},{"location":"kubernetes/kubernetes-scaling/#custom-metrics-hpa","title":"Custom Metrics HPA","text":"<pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: app-hpa-custom\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: app-deployment\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Pods\n    pods:\n      metric:\n        name: requests_per_second\n      target:\n        type: AverageValue\n        averageValue: 1k\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#prometheus-adapter-configuration","title":"Prometheus Adapter Configuration","text":"<pre><code>apiVersion: custom.metrics.k8s.io/v1beta1\nkind: MetricsAdapter\nmetadata:\n  name: custom-metrics-adapter\nspec:\n  rules:\n  - seriesQuery: 'http_requests_total'\n    resources:\n      overrides:\n        kubernetes_namespace:\n          resource: namespace\n        kubernetes_pod_name:\n          resource: pod\n    name:\n      matches: \"^(.*)_total\"\n      as: \"${1}_per_second\"\n    metricsQuery: 'rate(&lt;&lt;.Series&gt;&gt;{&lt;&lt;.LabelMatchers&gt;&gt;}[2m])'\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#best-practices","title":"Best Practices","text":""},{"location":"kubernetes/kubernetes-scaling/#resource-requests-and-limits","title":"Resource Requests and Limits","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: resource-pod\nspec:\n  containers:\n  - name: app\n    image: app:1.0\n    resources:\n      requests:\n        memory: \"64Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"128Mi\"\n        cpu: \"500m\"\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#pod-disruption-budget","title":"Pod Disruption Budget","text":"<pre><code>apiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: app-pdb\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: myapp\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Incorrect metric configuration</li> <li>Poor resource planning</li> <li>Missing pod disruption budgets</li> <li>Inadequate monitoring</li> <li>Improper scaling thresholds</li> <li>Resource contention</li> </ol>"},{"location":"kubernetes/kubernetes-scaling/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-scaling/#complete-scaling-configuration","title":"Complete Scaling Configuration","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web\n  template:\n    metadata:\n      labels:\n        app: web\n    spec:\n      containers:\n      - name: web\n        image: nginx\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"128Mi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"256Mi\"\n---\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: web-app-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: web-app\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n---\napiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: web-app-pdb\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: web\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#advanced-scaling-strategy","title":"Advanced Scaling Strategy","text":"<pre><code>apiVersion: autoscaling.k8s.io/v1\nkind: VerticalPodAutoscaler\nmetadata:\n  name: web-app-vpa\nspec:\n  targetRef:\n    apiVersion: \"apps/v1\"\n    kind: Deployment\n    name: web-app\n  updatePolicy:\n    updateMode: \"Auto\"\n  resourcePolicy:\n    containerPolicies:\n    - containerName: '*'\n      minAllowed:\n        cpu: 50m\n        memory: 64Mi\n      maxAllowed:\n        cpu: 500m\n        memory: 512Mi\n---\napiVersion: policy/v1beta1\nkind: PodDisruptionBudget\nmetadata:\n  name: web-app-pdb\nspec:\n  minAvailable: \"50%\"\n  selector:\n    matchLabels:\n      app: web\n</code></pre>"},{"location":"kubernetes/kubernetes-scaling/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Horizontal Pod Autoscaling</li> <li>Vertical Pod Autoscaling</li> <li>Cluster Autoscaler</li> <li>Custom Metrics API</li> </ul>"},{"location":"kubernetes/kubernetes-scaling/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Implement horizontal pod autoscaling</li> <li>Configure vertical pod autoscaling</li> <li>Set up cluster autoscaling</li> <li>Implement custom metrics scaling</li> <li>Configure pod disruption budgets </li> </ol>"},{"location":"kubernetes/kubernetes-security/","title":"Kubernetes Security","text":""},{"location":"kubernetes/kubernetes-security/#overview","title":"Overview","text":"<p>This guide covers security concepts and best practices in Kubernetes, including authentication, authorization, network policies, and security configurations.</p>"},{"location":"kubernetes/kubernetes-security/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of security principles</li> <li>Familiarity with RBAC</li> <li>Understanding of network security</li> </ul>"},{"location":"kubernetes/kubernetes-security/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Kubernetes security concepts</li> <li>Learn authentication methods</li> <li>Master RBAC configuration</li> <li>Implement network policies</li> <li>Configure security contexts</li> </ul>"},{"location":"kubernetes/kubernetes-security/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Authentication</li> <li>Authorization</li> <li>Network Policies</li> <li>Pod Security</li> <li>Secrets Management</li> </ol>"},{"location":"kubernetes/kubernetes-security/#authentication","title":"Authentication","text":""},{"location":"kubernetes/kubernetes-security/#service-account","title":"Service Account","text":"<pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: app-service-account\n  namespace: default\nautomountServiceAccountToken: false\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#token-configuration","title":"Token Configuration","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: service-account-token\n  annotations:\n    kubernetes.io/service-account.name: app-service-account\ntype: kubernetes.io/service-account-token\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#certificate-configuration","title":"Certificate Configuration","text":"<pre><code>apiVersion: certificates.k8s.io/v1\nkind: CertificateSigningRequest\nmetadata:\n  name: app-csr\nspec:\n  request: $(cat server.csr | base64 | tr -d '\\n')\n  signerName: kubernetes.io/kube-apiserver-client\n  usages:\n  - client auth\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#authorization","title":"Authorization","text":""},{"location":"kubernetes/kubernetes-security/#role-configuration","title":"Role Configuration","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: default\n  name: pod-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#rolebinding","title":"RoleBinding","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-pods\n  namespace: default\nsubjects:\n- kind: ServiceAccount\n  name: app-service-account\n  namespace: default\nroleRef:\n  kind: Role\n  name: pod-reader\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#clusterrole","title":"ClusterRole","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: secret-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#network-policies","title":"Network Policies","text":""},{"location":"kubernetes/kubernetes-security/#default-deny-policy","title":"Default Deny Policy","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#allow-specific-traffic","title":"Allow Specific Traffic","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-allow\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#pod-security","title":"Pod Security","text":""},{"location":"kubernetes/kubernetes-security/#security-context","title":"Security Context","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  securityContext:\n    runAsUser: 1000\n    runAsGroup: 3000\n    fsGroup: 2000\n  containers:\n  - name: secure-container\n    image: nginx\n    securityContext:\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      capabilities:\n        drop:\n        - ALL\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#pod-security-policy","title":"Pod Security Policy","text":"<pre><code>apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  volumes:\n    - 'configMap'\n    - 'emptyDir'\n    - 'projected'\n    - 'secret'\n    - 'downwardAPI'\n    - 'persistentVolumeClaim'\n  hostNetwork: false\n  hostIPC: false\n  hostPID: false\n  runAsUser:\n    rule: 'MustRunAsNonRoot'\n  seLinux:\n    rule: 'RunAsAny'\n  supplementalGroups:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  fsGroup:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  readOnlyRootFilesystem: true\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#secrets-management","title":"Secrets Management","text":""},{"location":"kubernetes/kubernetes-security/#secret-creation","title":"Secret Creation","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: app-secrets\ntype: Opaque\ndata:\n  username: dXNlcm5hbWU=\n  password: cGFzc3dvcmQ=\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#using-secrets-in-pods","title":"Using Secrets in Pods","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: secret-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    env:\n    - name: APP_USERNAME\n      valueFrom:\n        secretKeyRef:\n          name: app-secrets\n          key: username\n    volumeMounts:\n    - name: secrets\n      mountPath: \"/etc/secrets\"\n      readOnly: true\n  volumes:\n  - name: secrets\n    secret:\n      secretName: app-secrets\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#best-practices","title":"Best Practices","text":"<ol> <li>Use RBAC for access control</li> <li>Implement network policies</li> <li>Configure security contexts</li> <li>Manage secrets properly</li> <li>Use service accounts</li> <li>Enable audit logging</li> <li>Regular security updates</li> </ol>"},{"location":"kubernetes/kubernetes-security/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Overly permissive RBAC</li> <li>Missing network policies</li> <li>Insecure pod configurations</li> <li>Poor secrets management</li> <li>Weak authentication</li> <li>Insufficient monitoring</li> </ol>"},{"location":"kubernetes/kubernetes-security/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-security/#complete-security-configuration","title":"Complete Security Configuration","text":"<pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: app-service-account\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: app-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"services\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: app-role-binding\nsubjects:\n- kind: ServiceAccount\n  name: app-service-account\nroleRef:\n  kind: Role\n  name: app-role\n  apiGroup: rbac.authorization.k8s.io\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: app-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: web\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 80\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: backend\n    ports:\n    - protocol: TCP\n      port: 8080\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-app\nspec:\n  serviceAccountName: app-service-account\n  securityContext:\n    runAsUser: 1000\n    runAsGroup: 3000\n    fsGroup: 2000\n  containers:\n  - name: app\n    image: nginx\n    securityContext:\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      capabilities:\n        drop:\n        - ALL\n    volumeMounts:\n    - name: secrets\n      mountPath: \"/etc/secrets\"\n      readOnly: true\n  volumes:\n  - name: secrets\n    secret:\n      secretName: app-secrets\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#security-audit-configuration","title":"Security Audit Configuration","text":"<pre><code>apiVersion: audit.k8s.io/v1\nkind: Policy\nmetadata:\n  name: audit-policy\nrules:\n- level: Metadata\n  resources:\n  - group: \"\"\n    resources: [\"pods\", \"services\", \"secrets\"]\n- level: Request\n  resources:\n  - group: \"rbac.authorization.k8s.io\"\n    resources: [\"roles\", \"rolebindings\"]\n- level: RequestResponse\n  resources:\n  - group: \"authentication.k8s.io\"\n    resources: [\"*\"]\n</code></pre>"},{"location":"kubernetes/kubernetes-security/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Security Documentation</li> <li>RBAC Documentation</li> <li>Network Policies</li> <li>Pod Security Standards</li> </ul>"},{"location":"kubernetes/kubernetes-security/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Configure RBAC policies</li> <li>Implement network policies</li> <li>Set up pod security contexts</li> <li>Manage secrets securely</li> <li>Configure audit logging </li> </ol>"},{"location":"kubernetes/kubernetes-services/","title":"Kubernetes Services","text":""},{"location":"kubernetes/kubernetes-services/#overview","title":"Overview","text":"<p>This guide covers Kubernetes services, including different service types, networking configurations, and load balancing strategies.</p>"},{"location":"kubernetes/kubernetes-services/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of networking basics</li> <li>Familiarity with load balancing concepts</li> <li>Understanding of DNS and service discovery</li> </ul>"},{"location":"kubernetes/kubernetes-services/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand service types</li> <li>Learn service configuration</li> <li>Master service networking</li> <li>Implement load balancing</li> <li>Configure service discovery</li> </ul>"},{"location":"kubernetes/kubernetes-services/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Service Types</li> <li>Service Configuration</li> <li>Load Balancing</li> <li>Service Discovery</li> <li>Network Policies</li> </ol>"},{"location":"kubernetes/kubernetes-services/#service-types","title":"Service Types","text":""},{"location":"kubernetes/kubernetes-services/#clusterip-service","title":"ClusterIP Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  type: ClusterIP\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#nodeport-service","title":"NodePort Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: web-service\nspec:\n  type: NodePort\n  selector:\n    app: web\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n      nodePort: 30080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#loadbalancer-service","title":"LoadBalancer Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: frontend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#externalname-service","title":"ExternalName Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: api.external-service.com\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#service-configuration","title":"Service Configuration","text":""},{"location":"kubernetes/kubernetes-services/#basic-service-configuration","title":"Basic Service Configuration","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: app-service\n  labels:\n    app: myapp\nspec:\n  selector:\n    app: myapp\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: 8080\n  sessionAffinity: ClientIP\n  sessionAffinityConfig:\n    clientIP:\n      timeoutSeconds: 10800\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#multi-port-service","title":"Multi-Port Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: multi-port-service\nspec:\n  selector:\n    app: myapp\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: 8080\n    - name: https\n      protocol: TCP\n      port: 443\n      targetPort: 8443\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#load-balancing","title":"Load Balancing","text":""},{"location":"kubernetes/kubernetes-services/#internal-load-balancing","title":"Internal Load Balancing","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: internal-lb\n  annotations:\n    cloud.google.com/load-balancer-type: \"Internal\"\nspec:\n  type: LoadBalancer\n  selector:\n    app: internal-app\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#external-load-balancing","title":"External Load Balancing","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: external-lb\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: nlb\nspec:\n  type: LoadBalancer\n  selector:\n    app: external-app\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#service-discovery","title":"Service Discovery","text":""},{"location":"kubernetes/kubernetes-services/#dns-configuration","title":"DNS Configuration","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\n  namespace: default\nspec:\n  selector:\n    app: backend\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#headless-service","title":"Headless Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: headless-service\nspec:\n  clusterIP: None\n  selector:\n    app: stateful-app\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#network-policies","title":"Network Policies","text":""},{"location":"kubernetes/kubernetes-services/#basic-network-policy","title":"Basic Network Policy","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-allow\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: frontend\n      ports:\n        - protocol: TCP\n          port: 8080\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#namespace-network-policy","title":"Namespace Network Policy","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: namespace-policy\nspec:\n  podSelector: {}\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              environment: production\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate service types</li> <li>Implement proper load balancing</li> <li>Configure health checks</li> <li>Use meaningful DNS names</li> <li>Implement network policies</li> <li>Monitor service performance</li> <li>Configure proper timeouts</li> </ol>"},{"location":"kubernetes/kubernetes-services/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Incorrect service type selection</li> <li>Poor load balancing configuration</li> <li>Missing network policies</li> <li>Inadequate monitoring</li> <li>DNS misconfiguration</li> <li>Security misconfigurations</li> </ol>"},{"location":"kubernetes/kubernetes-services/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-services/#complete-service-configuration","title":"Complete Service Configuration","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: web-service\n  labels:\n    app: web\n    environment: production\n  annotations:\n    prometheus.io/scrape: 'true'\n    prometheus.io/port: '9090'\nspec:\n  type: LoadBalancer\n  selector:\n    app: web\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: 8080\n    - name: https\n      protocol: TCP\n      port: 443\n      targetPort: 8443\n    - name: metrics\n      protocol: TCP\n      port: 9090\n      targetPort: 9090\n  sessionAffinity: ClientIP\n  sessionAffinityConfig:\n    clientIP:\n      timeoutSeconds: 10800\n  loadBalancerSourceRanges:\n    - 10.0.0.0/8\n  externalTrafficPolicy: Local\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#service-with-network-policy","title":"Service with Network Policy","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: api-service\nspec:\n  selector:\n    app: api\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: frontend\n        - namespaceSelector:\n            matchLabels:\n              environment: production\n      ports:\n        - protocol: TCP\n          port: 8080\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432\n</code></pre>"},{"location":"kubernetes/kubernetes-services/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Services Documentation</li> <li>Network Policies Documentation</li> <li>DNS for Services and Pods</li> <li>Service Load Balancing</li> </ul>"},{"location":"kubernetes/kubernetes-services/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Create different types of services</li> <li>Implement load balancing</li> <li>Configure network policies</li> <li>Set up service discovery</li> <li>Test service connectivity </li> </ol>"},{"location":"kubernetes/kubernetes-storage/","title":"Kubernetes Storage","text":""},{"location":"kubernetes/kubernetes-storage/#overview","title":"Overview","text":"<p>This guide covers storage concepts in Kubernetes, including volumes, persistent volumes, storage classes, and best practices for managing application data.</p>"},{"location":"kubernetes/kubernetes-storage/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of storage systems</li> <li>Familiarity with cloud storage</li> <li>Understanding of persistence concepts</li> </ul>"},{"location":"kubernetes/kubernetes-storage/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Kubernetes storage concepts</li> <li>Learn volume management</li> <li>Master persistent volumes</li> <li>Implement storage classes</li> <li>Configure dynamic provisioning</li> </ul>"},{"location":"kubernetes/kubernetes-storage/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Volumes</li> <li>Persistent Volumes</li> <li>Storage Classes</li> <li>Volume Snapshots</li> <li>Storage Best Practices</li> </ol>"},{"location":"kubernetes/kubernetes-storage/#volumes","title":"Volumes","text":""},{"location":"kubernetes/kubernetes-storage/#emptydir-volume","title":"EmptyDir Volume","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pod\nspec:\n  containers:\n  - name: test-container\n    image: nginx\n    volumeMounts:\n    - mountPath: /cache\n      name: cache-volume\n  volumes:\n  - name: cache-volume\n    emptyDir: {}\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#hostpath-volume","title":"HostPath Volume","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pod\nspec:\n  containers:\n  - name: test-container\n    image: nginx\n    volumeMounts:\n    - mountPath: /test-pd\n      name: test-volume\n  volumes:\n  - name: test-volume\n    hostPath:\n      path: /data\n      type: Directory\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#persistent-volumes","title":"Persistent Volumes","text":""},{"location":"kubernetes/kubernetes-storage/#persistentvolume","title":"PersistentVolume","text":"<pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv-volume\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: standard\n  nfs:\n    path: /tmp\n    server: 172.17.0.2\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#persistentvolumeclaim","title":"PersistentVolumeClaim","text":"<pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pv-claim\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  storageClassName: standard\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#using-pvc-in-pod","title":"Using PVC in Pod","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: pv-pod\nspec:\n  containers:\n  - name: test-container\n    image: nginx\n    volumeMounts:\n    - mountPath: \"/var/www/html\"\n      name: pv-storage\n  volumes:\n  - name: pv-storage\n    persistentVolumeClaim:\n      claimName: pv-claim\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#storage-classes","title":"Storage Classes","text":""},{"location":"kubernetes/kubernetes-storage/#basic-storageclass","title":"Basic StorageClass","text":"<pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: standard\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\nreclaimPolicy: Retain\nallowVolumeExpansion: true\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#dynamic-provisioning","title":"Dynamic Provisioning","text":"<pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: io1\n  iopsPerGB: \"10\"\n  fsType: ext4\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#volume-snapshots","title":"Volume Snapshots","text":""},{"location":"kubernetes/kubernetes-storage/#volumesnapshotclass","title":"VolumeSnapshotClass","text":"<pre><code>apiVersion: snapshot.storage.k8s.io/v1\nkind: VolumeSnapshotClass\nmetadata:\n  name: csi-hostpath-snapclass\ndriver: hostpath.csi.k8s.io\ndeletionPolicy: Delete\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#volumesnapshot","title":"VolumeSnapshot","text":"<pre><code>apiVersion: snapshot.storage.k8s.io/v1\nkind: VolumeSnapshot\nmetadata:\n  name: new-snapshot\nspec:\n  volumeSnapshotClassName: csi-hostpath-snapclass\n  source:\n    persistentVolumeClaimName: pv-claim\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#restore-from-snapshot","title":"Restore from Snapshot","text":"<pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: restore-pvc\nspec:\n  dataSource:\n    name: new-snapshot\n    kind: VolumeSnapshot\n    apiGroup: snapshot.storage.k8s.io\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#storage-best-practices","title":"Storage Best Practices","text":""},{"location":"kubernetes/kubernetes-storage/#volume-security-context","title":"Volume Security Context","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: security-context-pod\nspec:\n  securityContext:\n    fsGroup: 2000\n  containers:\n  - name: sec-ctx-container\n    image: nginx\n    volumeMounts:\n    - name: sec-ctx-vol\n      mountPath: /data/demo\n  volumes:\n  - name: sec-ctx-vol\n    persistentVolumeClaim:\n      claimName: pv-claim\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#resource-quotas","title":"Resource Quotas","text":"<pre><code>apiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: storage-quota\nspec:\n  hard:\n    persistentvolumeclaims: \"10\"\n    requests.storage: \"500Gi\"\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate storage types</li> <li>Implement proper backup strategies</li> <li>Configure storage classes correctly</li> <li>Monitor storage usage</li> <li>Implement proper access controls</li> <li>Use volume snapshots</li> <li>Plan for scalability</li> </ol>"},{"location":"kubernetes/kubernetes-storage/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Incorrect storage class selection</li> <li>Poor capacity planning</li> <li>Missing backup strategy</li> <li>Inadequate monitoring</li> <li>Performance issues</li> <li>Security misconfigurations</li> </ol>"},{"location":"kubernetes/kubernetes-storage/#implementation-examples","title":"Implementation Examples","text":""},{"location":"kubernetes/kubernetes-storage/#complete-storage-configuration","title":"Complete Storage Configuration","text":"<pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast-storage\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: io1\n  iopsPerGB: \"10\"\n  fsType: ext4\nreclaimPolicy: Retain\nallowVolumeExpansion: true\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: app-data\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: fast-storage\n  resources:\n    requests:\n      storage: 100Gi\n---\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  serviceName: \"nginx\"\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx\n        ports:\n        - containerPort: 80\n          name: web\n        volumeMounts:\n        - name: www\n          mountPath: /usr/share/nginx/html\n  volumeClaimTemplates:\n  - metadata:\n      name: www\n    spec:\n      accessModes: [ \"ReadWriteOnce\" ]\n      storageClassName: fast-storage\n      resources:\n        requests:\n          storage: 1Gi\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#backup-configuration","title":"Backup Configuration","text":"<pre><code>apiVersion: snapshot.storage.k8s.io/v1\nkind: VolumeSnapshotClass\nmetadata:\n  name: csi-aws-snapclass\ndriver: ebs.csi.aws.com\ndeletionPolicy: Retain\nparameters:\n  description: \"Daily backup snapshot\"\n---\napiVersion: snapshot.storage.k8s.io/v1\nkind: VolumeSnapshot\nmetadata:\n  name: volume-snap-1\nspec:\n  volumeSnapshotClassName: csi-aws-snapclass\n  source:\n    persistentVolumeClaimName: app-data\n</code></pre>"},{"location":"kubernetes/kubernetes-storage/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Storage Documentation</li> <li>Persistent Volumes</li> <li>Storage Classes</li> <li>Volume Snapshots</li> </ul>"},{"location":"kubernetes/kubernetes-storage/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Create and use PersistentVolumes</li> <li>Implement StorageClasses</li> <li>Configure volume snapshots</li> <li>Set up dynamic provisioning</li> <li>Implement backup strategies </li> </ol>"},{"location":"kubernetes/kubernetes-troubleshooting/","title":"Kubernetes Troubleshooting","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#overview","title":"Overview","text":"<p>This guide covers troubleshooting techniques in Kubernetes, including debugging applications, cluster issues, and common problems with their solutions.</p>"},{"location":"kubernetes/kubernetes-troubleshooting/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Kubernetes concepts</li> <li>Knowledge of kubectl commands</li> <li>Familiarity with logging and monitoring</li> <li>Understanding of networking concepts</li> </ul>"},{"location":"kubernetes/kubernetes-troubleshooting/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand troubleshooting methodology</li> <li>Learn debugging techniques</li> <li>Master log analysis</li> <li>Implement monitoring solutions</li> <li>Resolve common issues</li> </ul>"},{"location":"kubernetes/kubernetes-troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Pod Issues</li> <li>Node Problems</li> <li>Networking Issues</li> <li>Storage Problems</li> <li>Cluster Issues</li> </ol>"},{"location":"kubernetes/kubernetes-troubleshooting/#pod-issues","title":"Pod Issues","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#debugging-pods","title":"Debugging Pods","text":"<pre><code># Get pod status\nkubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt;\n\n# Get pod details\nkubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;\n\n# Get pod logs\nkubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;\n\n# Get previous pod logs\nkubectl logs &lt;pod-name&gt; -n &lt;namespace&gt; --previous\n\n# Get container logs in multi-container pod\nkubectl logs &lt;pod-name&gt; -c &lt;container-name&gt; -n &lt;namespace&gt;\n\n# Execute commands in pod\nkubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- /bin/sh\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#common-pod-states","title":"Common Pod States","text":"<pre><code># Pod stuck in Pending\napiVersion: v1\nkind: Pod\nmetadata:\n  name: resource-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    resources:\n      requests:\n        memory: \"64Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"128Mi\"\n        cpu: \"500m\"\n\n# Pod in CrashLoopBackOff\napiVersion: v1\nkind: Pod\nmetadata:\n  name: liveness-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    livenessProbe:\n      httpGet:\n        path: /healthz\n        port: 8080\n      initialDelaySeconds: 3\n      periodSeconds: 3\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#node-problems","title":"Node Problems","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#node-debugging","title":"Node Debugging","text":"<pre><code># Check node status\nkubectl get nodes\n\n# Get node details\nkubectl describe node &lt;node-name&gt;\n\n# Get node metrics\nkubectl top node\n\n# Check node logs\njournalctl -u kubelet\n\n# Check node conditions\nkubectl get nodes -o json | jq '.items[].status.conditions[]'\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#node-maintenance","title":"Node Maintenance","text":"<pre><code># Drain node\nkubectl drain &lt;node-name&gt; --ignore-daemonsets\n\n# Cordon node\nkubectl cordon &lt;node-name&gt;\n\n# Uncordon node\nkubectl uncordon &lt;node-name&gt;\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#networking-issues","title":"Networking Issues","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#network-debugging","title":"Network Debugging","text":"<pre><code># Test service DNS\nkubectl run -it --rm --restart=Never busybox --image=busybox -- nslookup kubernetes.default\n\n# Check service endpoints\nkubectl get endpoints &lt;service-name&gt;\n\n# Test network connectivity\nkubectl run -it --rm --restart=Never busybox --image=busybox -- wget -O- http://service-name:port\n\n# Check network policies\nkubectl get networkpolicies --all-namespaces\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#service-debugging","title":"Service Debugging","text":"<pre><code># Debug service connectivity\napiVersion: v1\nkind: Pod\nmetadata:\n  name: debug-pod\nspec:\n  containers:\n  - name: debug\n    image: nicolaka/netshoot\n    command: ['sh', '-c', 'while true; do sleep 3600; done']\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#storage-problems","title":"Storage Problems","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#storage-debugging","title":"Storage Debugging","text":"<pre><code># Check PV status\nkubectl get pv\n\n# Check PVC status\nkubectl get pvc\n\n# Check storage class\nkubectl get storageclass\n\n# Describe storage issues\nkubectl describe pv &lt;pv-name&gt;\nkubectl describe pvc &lt;pvc-name&gt;\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#storage-cleanup","title":"Storage Cleanup","text":"<pre><code># Force delete PVC\nkubectl patch pvc &lt;pvc-name&gt; -p '{\"metadata\":{\"finalizers\":null}}'\n\n# Force delete PV\nkubectl patch pv &lt;pv-name&gt; -p '{\"metadata\":{\"finalizers\":null}}'\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#cluster-issues","title":"Cluster Issues","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#cluster-debugging","title":"Cluster Debugging","text":"<pre><code># Check cluster components\nkubectl get componentstatuses\n\n# Check control plane pods\nkubectl get pods -n kube-system\n\n# Check cluster events\nkubectl get events --all-namespaces\n\n# Check API server logs\nkubectl logs -n kube-system kube-apiserver-&lt;node-name&gt;\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#control-plane-recovery","title":"Control Plane Recovery","text":"<pre><code># Backup etcd\nETCDCTL_API=3 etcdctl snapshot save snapshot.db\n\n# Restore etcd\nETCDCTL_API=3 etcdctl snapshot restore snapshot.db\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#best-practices","title":"Best Practices","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#logging-best-practices","title":"Logging Best Practices","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: logging-pod\nspec:\n  containers:\n  - name: app\n    image: nginx\n    volumeMounts:\n    - name: logs\n      mountPath: /var/log\n  volumes:\n  - name: logs\n    emptyDir: {}\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#monitoring-setup","title":"Monitoring Setup","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: app-monitor\nspec:\n  selector:\n    matchLabels:\n      app: web\n  endpoints:\n  - port: metrics\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#application-issues","title":"Application Issues","text":"<ol> <li>Pod won't start</li> <li>Check image name and tag</li> <li>Verify resource requests and limits</li> <li>Check pull secrets</li> <li> <p>Examine node capacity</p> </li> <li> <p>Container crashes</p> </li> <li>Check application logs</li> <li>Verify health checks</li> <li>Check resource usage</li> <li>Examine dependencies</li> </ol>"},{"location":"kubernetes/kubernetes-troubleshooting/#networking-issues_1","title":"Networking Issues","text":"<ol> <li>Service not accessible</li> <li>Verify service selector</li> <li>Check endpoint creation</li> <li>Test pod connectivity</li> <li> <p>Examine network policies</p> </li> <li> <p>Ingress problems</p> </li> <li>Check ingress controller</li> <li>Verify TLS configuration</li> <li>Examine service backend</li> <li>Check DNS resolution</li> </ol>"},{"location":"kubernetes/kubernetes-troubleshooting/#storage-issues","title":"Storage Issues","text":"<ol> <li>PVC stuck in pending</li> <li>Check storage class</li> <li>Verify PV availability</li> <li>Examine storage provider</li> <li> <p>Check capacity</p> </li> <li> <p>Volume mount failures</p> </li> <li>Check mount permissions</li> <li>Verify volume paths</li> <li>Examine node issues</li> <li>Check filesystem type</li> </ol>"},{"location":"kubernetes/kubernetes-troubleshooting/#troubleshooting-tools","title":"Troubleshooting Tools","text":""},{"location":"kubernetes/kubernetes-troubleshooting/#debug-container","title":"Debug Container","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: debug-tools\nspec:\n  containers:\n  - name: debug\n    image: nicolaka/netshoot\n    command:\n    - sleep\n    - \"3600\"\n    securityContext:\n      privileged: true\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#network-debug","title":"Network Debug","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: network-debug\nspec:\n  containers:\n  - name: network-tools\n    image: praqma/network-multitool\n    command:\n    - sleep\n    - \"3600\"\n</code></pre>"},{"location":"kubernetes/kubernetes-troubleshooting/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Kubernetes Troubleshooting Guide</li> <li>Debug Running Pods</li> <li>Debug Services</li> <li>Cluster Troubleshooting</li> </ul>"},{"location":"kubernetes/kubernetes-troubleshooting/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Debug failing pods</li> <li>Troubleshoot service connectivity</li> <li>Resolve storage issues</li> <li>Fix networking problems</li> <li>Recover from cluster issues </li> </ol>"},{"location":"microservices/cqrs-pattern/","title":"CQRS Pattern in Microservices","text":""},{"location":"microservices/cqrs-pattern/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>What is the CQRS Pattern?</li> <li>Core Components</li> <li>When to Use CQRS</li> <li>Example: Fintech Transaction Platform</li> <li>Benefits and Challenges</li> <li>Best Practices</li> <li>References</li> </ul>"},{"location":"microservices/cqrs-pattern/#introduction","title":"Introduction","text":"<p>In traditional applications, the same data model is used for both reading and writing operations. However, this approach can lead to performance issues, complexity, and scalability challenges in large-scale microservices architectures. The Command Query Responsibility Segregation (CQRS) pattern addresses these challenges by separating read and write operations.</p>"},{"location":"microservices/cqrs-pattern/#what-is-the-cqrs-pattern","title":"What is the CQRS Pattern?","text":"<p>Command Query Responsibility Segregation (CQRS) is a design pattern that separates the read and write operations of a data store. In CQRS:</p> <ul> <li>Commands: Operations that change the state of an object or entity (writes)</li> <li>Queries: Operations that return the state of an object or entity (reads)</li> </ul> <p>This separation allows each side to be optimized independently for its specific requirements. CQRS is often implemented alongside the Event Sourcing pattern, where state changes are stored as a sequence of events.</p>"},{"location":"microservices/cqrs-pattern/#core-components","title":"Core Components","text":""},{"location":"microservices/cqrs-pattern/#command-side","title":"Command Side","text":"<ul> <li>Command Objects: Represent the intent to change the application state</li> <li>Command Handlers: Process commands and apply business logic</li> <li>Command Data Store: Optimized for writes (often normalized for integrity)</li> <li>Domain Models: Rich domain models representing business entities and logic</li> </ul>"},{"location":"microservices/cqrs-pattern/#query-side","title":"Query Side","text":"<ul> <li>Query Objects: Represent requests for data</li> <li>Query Handlers: Process queries and retrieve data</li> <li>Query Data Store: Optimized for reads (often denormalized for performance)</li> <li>Read Models: Simplified view models optimized for specific use cases</li> </ul>"},{"location":"microservices/cqrs-pattern/#event-bus","title":"Event Bus","text":"<ul> <li>Transports events between command and query sides</li> <li>Ensures eventual consistency between read and write models</li> </ul>"},{"location":"microservices/cqrs-pattern/#when-to-use-cqrs","title":"When to Use CQRS","text":"<p>CQRS is particularly beneficial when:</p> <ul> <li>Read and write workloads are significantly different</li> <li>There's a substantial disparity between read and write operations (e.g., many more reads than writes)</li> <li>Complex domain logic is present on the command side</li> <li>Multiple views of the same data are needed for different purposes</li> <li>Separate scaling of read and write workloads is required</li> <li>Team organization allows for specialization in either reads or writes</li> </ul>"},{"location":"microservices/cqrs-pattern/#example-fintech-transaction-platform","title":"Example: Fintech Transaction Platform","text":"<p>Below is a diagram illustrating a CQRS implementation for a fintech transaction platform that handles payment processing, transaction history, and reporting.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                               Fintech Transaction Platform - CQRS Pattern                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Command Side (Writes)          \u2502                     \u2502            Query Side (Reads)           \u2502\n\u2502                                         \u2502                     \u2502                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  REST API   \u2502      \u2502   Command    \u2502  \u2502                     \u2502  \u2502  REST API   \u2502     \u2502     Query     \u2502  \u2502\n\u2502  \u2502 Controllers \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   Handlers   \u2502  \u2502                     \u2502  \u2502 Controllers \u2502\u25c0\u2500\u2500\u2500\u2500\u2502    Handlers   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                              \u2502          \u2502                     \u2502                              \u2502          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502   Domain    \u2502      \u2502   Command    \u2502  \u2502                     \u2502  \u2502   Read      \u2502     \u2502     Query     \u2502  \u2502\n\u2502  \u2502   Models    \u2502\u25c0\u2500\u2500\u2500\u2500\u25b6\u2502   Services   \u2502  \u2502                     \u2502  \u2502   Models    \u2502\u25c0\u2500\u2500\u2500\u2500\u2502    Services   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                              \u2502          \u2502                     \u2502                              \u2502          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Command    \u2502      \u2502  Transaction \u2502  \u2502                     \u2502  \u2502  Query      \u2502     \u2502 Read Database \u2502  \u2502\n\u2502  \u2502 Repository  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   Database   \u2502  \u2502                     \u2502  \u2502 Repository  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 (NoSQL/Cache) \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                              \u2502          \u2502                     \u2502           \u25b2                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502                                            \u2502\n                               \u2502                                            \u2502\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                   \u2502\n                      \u2502                 \u2502                                   \u2502\n                      \u2502   Event Bus     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502                 \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502  Event Store    \u2502\n                      \u2502  (Transaction   \u2502\n                      \u2502    Events)      \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"microservices/cqrs-pattern/#transaction-flow","title":"Transaction Flow","text":"<ol> <li>Command Flow (Write Path)</li> <li>User initiates a payment transaction through the API</li> <li>Command controller receives the request and creates a Payment Command</li> <li>Command handler validates and processes the command</li> <li>Domain model applies business rules (e.g., account balance validation)</li> <li>Command service creates a transaction record</li> <li>Transaction event is published to the Event Bus</li> <li> <p>Event is stored in the Event Store</p> </li> <li> <p>Query Flow (Read Path)</p> </li> <li>User requests transaction history or account balance</li> <li>Query controller receives the request</li> <li>Query handler processes the request</li> <li>Query service retrieves data from optimized read database</li> <li> <p>Read models (tailored for specific view needs) are returned to the user</p> </li> <li> <p>Synchronization Process</p> </li> <li>Transaction events from the Event Bus update read models</li> <li>Event handlers process events and update read databases</li> <li>Read models are kept eventually consistent with the write models</li> </ol>"},{"location":"microservices/cqrs-pattern/#different-read-models-query-side","title":"Different Read Models (Query Side)","text":"<p>The query side in our fintech platform supports multiple read models, each optimized for specific use cases:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Fintech Platform - Multiple Read Models                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Account Balance \u2502     \u2502  Transaction     \u2502     \u2502  Reporting &amp;     \u2502\n\u2502     View         \u2502     \u2502  History View    \u2502     \u2502  Analytics View  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                        \u2502                        \u2502\n         \u25bc                        \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Redis Cache     \u2502     \u2502  MongoDB         \u2502     \u2502  ClickHouse/     \u2502\n\u2502  (Fast lookups)  \u2502     \u2502  (Documents)     \u2502     \u2502  Analytics DB    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"microservices/cqrs-pattern/#benefits-and-challenges","title":"Benefits and Challenges","text":""},{"location":"microservices/cqrs-pattern/#benefits","title":"Benefits","text":"<ul> <li>Performance Optimization: Each side can be optimized for its specific workload</li> <li>Scalability: Read and write sides can scale independently</li> <li>Simplified Models: Models can be tailored for specific use cases rather than being one-size-fits-all</li> <li>Team Separation: Different teams can work on read and write sides independently</li> <li>Query Flexibility: Supports multiple optimized read models for different use cases</li> <li>Complex Business Logic: Allows complex domain logic on the command side without affecting query performance</li> </ul>"},{"location":"microservices/cqrs-pattern/#challenges","title":"Challenges","text":"<ul> <li>Complexity: Increased architectural complexity and development overhead</li> <li>Eventual Consistency: Read models are eventually consistent with write models</li> <li>Data Duplication: Same data may be stored in different forms across read models</li> <li>Learning Curve: Requires team understanding of the pattern and its implications</li> <li>Synchronization: Requires mechanisms to synchronize command and query models</li> </ul>"},{"location":"microservices/cqrs-pattern/#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple: Don't apply CQRS everywhere - focus on high-value areas with distinct read/write requirements</li> <li>Use Event Sourcing when appropriate to track all changes and maintain an audit trail</li> <li>Design for Eventual Consistency: Ensure clients understand and handle eventual consistency</li> <li>Monitor Synchronization: Track lag between write and read models</li> <li>Versioning: Consider versioning commands and events for system evolution</li> <li>Denormalize Wisely: Create read models that efficiently support specific query patterns</li> <li>Idempotent Handlers: Ensure event handlers are idempotent to handle redelivery</li> <li>Transaction Boundaries: Carefully define transaction boundaries in the command side</li> <li>Materialized Views: Use materialized views where appropriate for performance</li> <li>Caching: Implement caching strategies to improve read performance</li> </ol>"},{"location":"microservices/cqrs-pattern/#references","title":"References","text":"<ul> <li>\"Implementing Domain-Driven Design\" by Vaughn Vernon</li> <li>\"CQRS Journey\" by Microsoft</li> <li>Martin Fowler - CQRS</li> <li>Microsoft - CQRS Pattern </li> </ul>"},{"location":"microservices/microservices-api-gateway/","title":"API Gateway in Microservices","text":""},{"location":"microservices/microservices-api-gateway/#overview","title":"Overview","text":"<p>This guide covers the API Gateway pattern in microservices architecture, including implementation approaches, best practices, and common patterns.</p>"},{"location":"microservices/microservices-api-gateway/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of microservices architecture</li> <li>Knowledge of Spring Cloud Gateway</li> <li>Familiarity with routing concepts</li> <li>Understanding of authentication and authorization</li> </ul>"},{"location":"microservices/microservices-api-gateway/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand API Gateway pattern</li> <li>Learn different gateway implementations</li> <li>Master routing and filtering</li> <li>Implement security at gateway level</li> <li>Handle cross-cutting concerns</li> </ul>"},{"location":"microservices/microservices-api-gateway/#table-of-contents","title":"Table of Contents","text":"<ol> <li>API Gateway Pattern</li> <li>Implementation Approaches</li> <li>Security</li> <li>Cross-Cutting Concerns</li> <li>Best Practices</li> </ol>"},{"location":"microservices/microservices-api-gateway/#api-gateway-pattern","title":"API Gateway Pattern","text":""},{"location":"microservices/microservices-api-gateway/#core-functions","title":"Core Functions","text":"<ol> <li>Routing</li> <li>Authentication</li> <li>SSL Termination</li> <li>Load Balancing</li> <li>Monitoring</li> <li>Rate Limiting</li> <li>Circuit Breaking</li> </ol>"},{"location":"microservices/microservices-api-gateway/#implementation-with-spring-cloud-gateway","title":"Implementation with Spring Cloud Gateway","text":""},{"location":"microservices/microservices-api-gateway/#basic-configuration","title":"Basic Configuration","text":"<pre><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: user_service\n          uri: lb://user-service\n          predicates:\n            - Path=/api/users/**\n          filters:\n            - StripPrefix=1\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#java-configuration","title":"Java Configuration","text":"<pre><code>@Configuration\npublic class GatewayConfig {\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n        return builder.routes()\n            .route(\"user_service\", r -&gt; r\n                .path(\"/api/users/**\")\n                .filters(f -&gt; f.stripPrefix(1))\n                .uri(\"lb://user-service\"))\n            .build();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#implementation-approaches","title":"Implementation Approaches","text":""},{"location":"microservices/microservices-api-gateway/#1-spring-cloud-gateway","title":"1. Spring Cloud Gateway","text":"<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\npublic class ApiGatewayApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ApiGatewayApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#2-custom-filters","title":"2. Custom Filters","text":"<pre><code>@Component\npublic class CustomGatewayFilter implements GatewayFilter {\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        exchange.getRequest().mutate()\n            .header(\"X-Custom-Header\", \"custom-value\");\n        return chain.filter(exchange);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#3-global-filters","title":"3. Global Filters","text":"<pre><code>@Component\npublic class LoggingGlobalFilter implements GlobalFilter {\n    private static final Logger log = LoggerFactory.getLogger(LoggingGlobalFilter.class);\n\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        log.info(\"Path requested: {}\", exchange.getRequest().getPath());\n        return chain.filter(exchange);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#security","title":"Security","text":""},{"location":"microservices/microservices-api-gateway/#jwt-authentication","title":"JWT Authentication","text":"<pre><code>@Component\npublic class JwtAuthenticationFilter implements GatewayFilter {\n    private final JwtTokenProvider tokenProvider;\n\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        String token = extractToken(exchange.getRequest());\n        if (tokenProvider.validateToken(token)) {\n            return chain.filter(exchange);\n        }\n        return Mono.error(new UnauthorizedException(\"Invalid token\"));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#rate-limiting","title":"Rate Limiting","text":"<pre><code>@Configuration\npublic class RateLimitConfig {\n    @Bean\n    public KeyResolver userKeyResolver() {\n        return exchange -&gt; Mono.just(\n            exchange.getRequest().getHeaders().getFirst(\"X-User-Id\"));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#cors-configuration","title":"CORS Configuration","text":"<pre><code>@Configuration\npublic class CorsConfig {\n    @Bean\n    public CorsWebFilter corsWebFilter() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowedOrigins(Arrays.asList(\"*\"));\n        config.setAllowedMethods(Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n        config.setAllowedHeaders(Arrays.asList(\"*\"));\n\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n\n        return new CorsWebFilter(source);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#cross-cutting-concerns","title":"Cross-Cutting Concerns","text":""},{"location":"microservices/microservices-api-gateway/#circuit-breaker","title":"Circuit Breaker","text":"<pre><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: user_service\n          uri: lb://user-service\n          predicates:\n            - Path=/api/users/**\n          filters:\n            - name: CircuitBreaker\n              args:\n                name: userServiceBreaker\n                fallbackUri: forward:/fallback\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#requestresponse-transformation","title":"Request/Response Transformation","text":"<pre><code>@Component\npublic class TransformationFilter implements GatewayFilter {\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        return chain.filter(exchange.mutate()\n            .request(exchange.getRequest().mutate()\n                .header(\"X-Transformed\", \"true\")\n                .build())\n            .build());\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#logging-and-monitoring","title":"Logging and Monitoring","text":"<pre><code>@Component\npublic class MetricsFilter implements GlobalFilter {\n    private final MeterRegistry meterRegistry;\n\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        long startTime = System.currentTimeMillis();\n        return chain.filter(exchange)\n            .doFinally(signalType -&gt; {\n                long duration = System.currentTimeMillis() - startTime;\n                meterRegistry.timer(\"gateway.request.duration\")\n                    .record(duration, TimeUnit.MILLISECONDS);\n            });\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#best-practices","title":"Best Practices","text":"<ol> <li>Implement proper security measures</li> <li>Use circuit breakers for downstream services</li> <li>Implement rate limiting</li> <li>Monitor gateway performance</li> <li>Handle errors gracefully</li> <li>Implement proper logging</li> <li>Use appropriate caching strategies</li> </ol>"},{"location":"microservices/microservices-api-gateway/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Insufficient security measures</li> <li>Poor error handling</li> <li>Missing rate limiting</li> <li>Inadequate monitoring</li> <li>Poor performance</li> <li>Improper routing configuration</li> </ol>"},{"location":"microservices/microservices-api-gateway/#implementation-examples","title":"Implementation Examples","text":""},{"location":"microservices/microservices-api-gateway/#complete-gateway-configuration","title":"Complete Gateway Configuration","text":"<pre><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: user_service\n          uri: lb://user-service\n          predicates:\n            - Path=/api/users/**\n          filters:\n            - StripPrefix=1\n            - name: CircuitBreaker\n              args:\n                name: userServiceBreaker\n            - name: RequestRateLimiter\n              args:\n                redis-rate-limiter.replenishRate: 10\n                redis-rate-limiter.burstCapacity: 20\n        - id: order_service\n          uri: lb://order-service\n          predicates:\n            - Path=/api/orders/**\n          filters:\n            - StripPrefix=1\n            - name: Retry\n              args:\n                retries: 3\n                statuses: BAD_GATEWAY\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#error-handling","title":"Error Handling","text":"<pre><code>@Component\npublic class GlobalErrorHandler implements ErrorWebExceptionHandler {\n    @Override\n    public Mono&lt;Void&gt; handle(ServerWebExchange exchange, Throwable ex) {\n        exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n        return exchange.getResponse().writeWith(Mono.just(\n            exchange.getResponse().bufferFactory().wrap(\n                ex.getMessage().getBytes())));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-api-gateway/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Spring Cloud Gateway Documentation</li> <li>Netflix Zuul Wiki</li> <li>Kong Gateway Documentation</li> <li>Azure API Management</li> </ul>"},{"location":"microservices/microservices-api-gateway/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Set up Spring Cloud Gateway with service discovery</li> <li>Implement custom filters</li> <li>Configure rate limiting</li> <li>Set up circuit breakers</li> <li>Implement JWT authentication </li> </ol>"},{"location":"microservices/microservices-basics/","title":"Microservices Basics","text":""},{"location":"microservices/microservices-basics/#overview","title":"Overview","text":"<p>This guide introduces the fundamental concepts of microservices architecture, its benefits, challenges, and core principles.</p>"},{"location":"microservices/microservices-basics/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of distributed systems</li> <li>Knowledge of RESTful APIs</li> <li>Familiarity with containerization concepts</li> </ul>"},{"location":"microservices/microservices-basics/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand what microservices architecture is</li> <li>Learn the key principles of microservices</li> <li>Compare monolithic vs microservices architecture</li> <li>Identify when to use microservices</li> <li>Understand the benefits and challenges</li> </ul>"},{"location":"microservices/microservices-basics/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Microservices</li> <li>Core Principles</li> <li>Architecture Patterns</li> <li>Benefits and Challenges</li> <li>Getting Started</li> </ol>"},{"location":"microservices/microservices-basics/#introduction-to-microservices","title":"Introduction to Microservices","text":"<p>Microservices is an architectural style that structures an application as a collection of small, autonomous services. Each service is: - Independently deployable - Loosely coupled - Organized around business capabilities - Owned by a small team</p>"},{"location":"microservices/microservices-basics/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Service independence</li> <li>Decentralized data management</li> <li>Built around business capabilities</li> <li>Smart endpoints and dumb pipes</li> <li>Design for failure</li> </ul>"},{"location":"microservices/microservices-basics/#core-principles","title":"Core Principles","text":"<ol> <li>Single Responsibility</li> <li>Each service should focus on one specific business capability</li> <li> <p>Clear boundaries and responsibilities</p> </li> <li> <p>Autonomy</p> </li> <li>Services can be developed, deployed, and scaled independently</li> <li> <p>Teams can work autonomously</p> </li> <li> <p>Data Decentralization</p> </li> <li>Each service manages its own data</li> <li>No shared databases</li> <li> <p>Data consistency through eventual consistency</p> </li> <li> <p>Resilience</p> </li> <li>Services should be designed to handle failure</li> <li>Implementation of Circuit Breaker patterns</li> <li>Fallback mechanisms</li> </ol>"},{"location":"microservices/microservices-basics/#architecture-patterns","title":"Architecture Patterns","text":"<ol> <li>API Gateway Pattern</li> <li>Single entry point for clients</li> <li>Request routing</li> <li> <p>Protocol translation</p> </li> <li> <p>Database per Service</p> </li> <li>Each service has its own database</li> <li>Data isolation</li> <li> <p>Technology flexibility</p> </li> <li> <p>Event-Driven Architecture</p> </li> <li>Asynchronous communication</li> <li>Event sourcing</li> <li>CQRS pattern</li> </ol>"},{"location":"microservices/microservices-basics/#benefits-and-challenges","title":"Benefits and Challenges","text":""},{"location":"microservices/microservices-basics/#benefits","title":"Benefits","text":"<ol> <li>Scalability</li> <li>Independent scaling of services</li> <li> <p>Better resource utilization</p> </li> <li> <p>Agility</p> </li> <li>Faster development cycles</li> <li>Independent deployments</li> <li> <p>Technology flexibility</p> </li> <li> <p>Resilience</p> </li> <li>Isolated failures</li> <li> <p>Better fault tolerance</p> </li> <li> <p>Easy Maintenance</p> </li> <li>Smaller, manageable codebases</li> <li>Easier to understand and modify</li> </ol>"},{"location":"microservices/microservices-basics/#challenges","title":"Challenges","text":"<ol> <li>Distributed System Complexity</li> <li>Network latency</li> <li>Service discovery</li> <li> <p>Distributed transactions</p> </li> <li> <p>Data Consistency</p> </li> <li>Managing data across services</li> <li> <p>Implementing eventual consistency</p> </li> <li> <p>Operational Complexity</p> </li> <li>Multiple services to monitor</li> <li>Complex deployment scenarios</li> <li>Service orchestration</li> </ol>"},{"location":"microservices/microservices-basics/#getting-started","title":"Getting Started","text":"<ol> <li>Identify Service Boundaries</li> <li>Use Domain-Driven Design</li> <li>Define bounded contexts</li> <li> <p>Identify service responsibilities</p> </li> <li> <p>Choose Technology Stack</p> </li> <li>Select appropriate frameworks</li> <li>Consider team expertise</li> <li> <p>Evaluate scalability requirements</p> </li> <li> <p>Plan Infrastructure</p> </li> <li>Container orchestration</li> <li>Service discovery</li> <li>Monitoring solutions</li> </ol>"},{"location":"microservices/microservices-basics/#best-practices","title":"Best Practices","text":"<ol> <li>Keep services small and focused</li> <li>Implement proper monitoring and logging</li> <li>Use containerization</li> <li>Implement proper security measures</li> <li>Design for failure</li> <li>Maintain service documentation</li> </ol>"},{"location":"microservices/microservices-basics/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Creating too fine-grained services</li> <li>Ignoring data consistency challenges</li> <li>Inadequate monitoring</li> <li>Poor service boundaries</li> <li>Tight coupling between services</li> </ol>"},{"location":"microservices/microservices-basics/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Martin Fowler's Microservices Guide</li> <li>Microservices.io</li> <li>The Twelve-Factor App</li> </ul>"},{"location":"microservices/microservices-basics/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Design a simple e-commerce system using microservices</li> <li>Implement service discovery using Eureka</li> <li>Create an API gateway using Spring Cloud Gateway</li> <li>Implement circuit breaker pattern using Resilience4j </li> </ol>"},{"location":"microservices/microservices-best-practices/","title":"Microservices Best Practices","text":""},{"location":"microservices/microservices-best-practices/#overview","title":"Overview","text":"<p>This guide covers comprehensive best practices and patterns for building, deploying, and maintaining microservices architecture.</p>"},{"location":"microservices/microservices-best-practices/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of microservices architecture</li> <li>Knowledge of distributed systems</li> <li>Familiarity with cloud platforms</li> <li>Understanding of DevOps practices</li> </ul>"},{"location":"microservices/microservices-best-practices/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand microservices best practices</li> <li>Learn design patterns</li> <li>Master operational practices</li> <li>Implement security measures</li> <li>Handle scalability and resilience</li> </ul>"},{"location":"microservices/microservices-best-practices/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Design Principles</li> <li>Service Organization</li> <li>Data Management</li> <li>Communication Patterns</li> <li>Operational Excellence</li> </ol>"},{"location":"microservices/microservices-best-practices/#design-principles","title":"Design Principles","text":""},{"location":"microservices/microservices-best-practices/#single-responsibility","title":"Single Responsibility","text":"<p>Each service should have a single responsibility and should be focused on a specific business capability.</p> <pre><code>@Service\npublic class OrderService {\n    private final OrderRepository orderRepository;\n    private final PaymentClient paymentClient;\n\n    // Focus only on order-related operations\n    public Order createOrder(OrderRequest request) {\n        // Order creation logic\n    }\n\n    public Order updateOrder(String orderId, OrderUpdateRequest request) {\n        // Order update logic\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#api-first-design","title":"API First Design","text":"<p>Design APIs before implementation using OpenAPI/Swagger specifications.</p> <pre><code>openapi: 3.0.0\ninfo:\n  title: Order Service API\n  version: 1.0.0\npaths:\n  /orders:\n    post:\n      summary: Create a new order\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/OrderRequest'\n      responses:\n        '201':\n          description: Order created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Order'\n</code></pre>"},{"location":"microservices/microservices-best-practices/#service-organization","title":"Service Organization","text":""},{"location":"microservices/microservices-best-practices/#project-structure","title":"Project Structure","text":"<pre><code>order-service/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 com/company/order/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 config/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 controller/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 repository/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 service/\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 client/\n\u2502   \u2502   \u2514\u2500\u2500 resources/\n\u2502   \u2514\u2500\u2500 test/\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 pom.xml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"microservices/microservices-best-practices/#service-registry","title":"Service Registry","text":"<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\npublic class OrderServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderServiceApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#data-management","title":"Data Management","text":""},{"location":"microservices/microservices-best-practices/#database-per-service","title":"Database Per Service","text":"<p>Each service should have its own database to ensure loose coupling.</p> <pre><code>spring:\n  datasource:\n    url: jdbc:postgresql://localhost:5432/orderdb\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n  jpa:\n    hibernate:\n      ddl-auto: none\n</code></pre>"},{"location":"microservices/microservices-best-practices/#event-sourcing","title":"Event Sourcing","text":"<pre><code>@Service\npublic class OrderEventService {\n    private final EventStore eventStore;\n\n    public void createOrder(OrderCreatedEvent event) {\n        eventStore.save(event);\n        // Additional processing\n    }\n\n    public Order reconstructOrder(String orderId) {\n        List&lt;Event&gt; events = eventStore.getEvents(orderId);\n        return Order.replay(events);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#communication-patterns","title":"Communication Patterns","text":""},{"location":"microservices/microservices-best-practices/#asynchronous-communication","title":"Asynchronous Communication","text":"<pre><code>@Service\npublic class OrderProcessor {\n    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;\n\n    public void processOrder(Order order) {\n        OrderEvent event = new OrderEvent(order);\n        kafkaTemplate.send(\"order-events\", event);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#circuit-breaker","title":"Circuit Breaker","text":"<pre><code>@Service\npublic class PaymentService {\n    @CircuitBreaker(name = \"payment\", fallbackMethod = \"fallbackPayment\")\n    public Payment processPayment(PaymentRequest request) {\n        return paymentClient.processPayment(request);\n    }\n\n    public Payment fallbackPayment(PaymentRequest request, Exception ex) {\n        return new Payment(PaymentStatus.PENDING);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#operational-excellence","title":"Operational Excellence","text":""},{"location":"microservices/microservices-best-practices/#health-checks","title":"Health Checks","text":"<pre><code>@Component\npublic class OrderServiceHealthIndicator implements HealthIndicator {\n    private final OrderRepository orderRepository;\n\n    @Override\n    public Health health() {\n        try {\n            orderRepository.count();\n            return Health.up().build();\n        } catch (Exception ex) {\n            return Health.down()\n                .withException(ex)\n                .build();\n        }\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#monitoring-and-metrics","title":"Monitoring and Metrics","text":"<pre><code>@Component\npublic class OrderMetrics {\n    private final MeterRegistry registry;\n\n    public void recordOrderProcessingTime(long timeInMs) {\n        registry.timer(\"order.processing.time\")\n            .record(timeInMs, TimeUnit.MILLISECONDS);\n    }\n\n    public void incrementOrderCounter() {\n        registry.counter(\"order.created\").increment();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"microservices/microservices-best-practices/#1-service-design","title":"1. Service Design","text":"<ul> <li>Keep services small and focused</li> <li>Design for failure</li> <li>Use API-first approach</li> <li>Implement proper validation</li> <li>Use proper error handling</li> </ul>"},{"location":"microservices/microservices-best-practices/#2-data-management","title":"2. Data Management","text":"<ul> <li>Use database per service</li> <li>Implement eventual consistency</li> <li>Handle distributed transactions</li> <li>Use proper caching strategies</li> <li>Implement data backup and recovery</li> </ul>"},{"location":"microservices/microservices-best-practices/#3-security","title":"3. Security","text":"<ul> <li>Implement authentication and authorization</li> <li>Use HTTPS everywhere</li> <li>Secure sensitive data</li> <li>Implement rate limiting</li> <li>Regular security audits</li> </ul>"},{"location":"microservices/microservices-best-practices/#4-devops","title":"4. DevOps","text":"<ul> <li>Automate deployment process</li> <li>Implement CI/CD</li> <li>Use container orchestration</li> <li>Monitor service health</li> <li>Implement proper logging</li> </ul>"},{"location":"microservices/microservices-best-practices/#5-testing","title":"5. Testing","text":"<ul> <li>Write comprehensive tests</li> <li>Implement contract testing</li> <li>Perform load testing</li> <li>Test failure scenarios</li> <li>Automate testing process</li> </ul>"},{"location":"microservices/microservices-best-practices/#implementation-examples","title":"Implementation Examples","text":""},{"location":"microservices/microservices-best-practices/#complete-service-implementation","title":"Complete Service Implementation","text":"<pre><code>@Service\n@Slf4j\npublic class OrderServiceImpl implements OrderService {\n    private final OrderRepository orderRepository;\n    private final PaymentClient paymentClient;\n    private final OrderMetrics metrics;\n\n    @Transactional\n    public Order createOrder(OrderRequest request) {\n        long startTime = System.currentTimeMillis();\n        try {\n            // Validate request\n            validateRequest(request);\n\n            // Create order\n            Order order = new Order(request);\n            order = orderRepository.save(order);\n\n            // Process payment\n            Payment payment = processPayment(order);\n            order.setPaymentStatus(payment.getStatus());\n\n            // Update metrics\n            metrics.incrementOrderCounter();\n\n            return order;\n        } finally {\n            metrics.recordOrderProcessingTime(\n                System.currentTimeMillis() - startTime);\n        }\n    }\n\n    @CircuitBreaker(name = \"payment\")\n    private Payment processPayment(Order order) {\n        return paymentClient.processPayment(\n            new PaymentRequest(order));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-best-practices/#configuration-management","title":"Configuration Management","text":"<pre><code>spring:\n  application:\n    name: order-service\n  cloud:\n    config:\n      uri: http://config-server:8888\n      fail-fast: true\n  datasource:\n    url: jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n  kafka:\n    bootstrap-servers: ${KAFKA_SERVERS}\n    producer:\n      key-serializer: org.apache.kafka.common.serialization.StringSerializer\n      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,metrics,prometheus\n  metrics:\n    tags:\n      application: ${spring.application.name}\n\nresilience4j:\n  circuitbreaker:\n    instances:\n      payment:\n        slidingWindowSize: 10\n        failureRateThreshold: 50\n        waitDurationInOpenState: 5000\n</code></pre>"},{"location":"microservices/microservices-best-practices/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ol> <li>Too fine-grained services</li> <li>Synchronous communication overuse</li> <li>Shared databases</li> <li>Lack of monitoring</li> <li>Poor error handling</li> <li>Insufficient testing</li> <li>Missing security measures</li> <li>Inadequate documentation</li> </ol>"},{"location":"microservices/microservices-best-practices/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Microservices.io</li> <li>Spring Cloud Documentation</li> <li>Twelve-Factor App</li> <li>Cloud Native Computing Foundation</li> </ul>"},{"location":"microservices/microservices-best-practices/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Design a microservice architecture</li> <li>Implement service discovery</li> <li>Set up monitoring and alerting</li> <li>Implement circuit breakers</li> <li>Create deployment pipelines </li> </ol>"},{"location":"microservices/microservices-communication/","title":"Microservices Communication Patterns","text":""},{"location":"microservices/microservices-communication/#overview","title":"Overview","text":"<p>This guide covers various communication patterns used in microservices architecture, including synchronous and asynchronous communication methods.</p>"},{"location":"microservices/microservices-communication/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of microservices architecture</li> <li>Knowledge of REST APIs</li> <li>Familiarity with messaging systems</li> <li>Basic understanding of event-driven architecture</li> </ul>"},{"location":"microservices/microservices-communication/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand different communication patterns in microservices</li> <li>Learn when to use synchronous vs asynchronous communication</li> <li>Master various messaging patterns</li> <li>Implement different communication strategies</li> <li>Handle communication failures gracefully</li> </ul>"},{"location":"microservices/microservices-communication/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Communication Styles</li> <li>Synchronous Communication</li> <li>Asynchronous Communication</li> <li>Message Formats</li> <li>Error Handling</li> </ol>"},{"location":"microservices/microservices-communication/#communication-styles","title":"Communication Styles","text":""},{"location":"microservices/microservices-communication/#1-requestresponse","title":"1. Request/Response","text":"<ul> <li>REST APIs</li> <li>gRPC</li> <li>GraphQL</li> <li>Direct service-to-service calls</li> </ul>"},{"location":"microservices/microservices-communication/#2-event-driven","title":"2. Event-Driven","text":"<ul> <li>Publish/Subscribe</li> <li>Event Sourcing</li> <li>Message Queues</li> <li>Stream Processing</li> </ul>"},{"location":"microservices/microservices-communication/#3-hybrid-approaches","title":"3. Hybrid Approaches","text":"<ul> <li>Command Query Responsibility Segregation (CQRS)</li> <li>Saga Pattern</li> <li>Event-Carried State Transfer</li> </ul>"},{"location":"microservices/microservices-communication/#synchronous-communication","title":"Synchronous Communication","text":""},{"location":"microservices/microservices-communication/#rest-apis","title":"REST APIs","text":"<ul> <li>HTTP/HTTPS protocols</li> <li>Standard methods (GET, POST, PUT, DELETE)</li> <li>Status codes</li> <li>Resource-based URLs</li> <li>API versioning</li> </ul>"},{"location":"microservices/microservices-communication/#grpc","title":"gRPC","text":"<ul> <li>Protocol buffers</li> <li>Bi-directional streaming</li> <li>Type safety</li> <li>Code generation</li> <li>Performance benefits</li> </ul>"},{"location":"microservices/microservices-communication/#graphql","title":"GraphQL","text":"<ul> <li>Query language for APIs</li> <li>Single endpoint</li> <li>Client-specified queries</li> <li>Schema definition</li> <li>Real-time with subscriptions</li> </ul>"},{"location":"microservices/microservices-communication/#asynchronous-communication","title":"Asynchronous Communication","text":""},{"location":"microservices/microservices-communication/#message-queues","title":"Message Queues","text":"<ul> <li>Apache Kafka</li> <li>RabbitMQ</li> <li>Amazon SQS</li> <li>Message persistence</li> <li>Guaranteed delivery</li> </ul>"},{"location":"microservices/microservices-communication/#event-driven-architecture","title":"Event-Driven Architecture","text":"<ul> <li>Event producers</li> <li>Event consumers</li> <li>Event brokers</li> <li>Event schemas</li> <li>Event versioning</li> </ul>"},{"location":"microservices/microservices-communication/#publishsubscribe-pattern","title":"Publish/Subscribe Pattern","text":"<ul> <li>Topics and subscriptions</li> <li>Message filtering</li> <li>Fan-out distribution</li> <li>Decoupling services</li> </ul>"},{"location":"microservices/microservices-communication/#message-formats","title":"Message Formats","text":""},{"location":"microservices/microservices-communication/#1-json","title":"1. JSON","text":"<ul> <li>Human-readable</li> <li>Wide support</li> <li>Schema flexibility</li> <li>Easy debugging</li> </ul>"},{"location":"microservices/microservices-communication/#2-protocol-buffers","title":"2. Protocol Buffers","text":"<ul> <li>Binary format</li> <li>Schema required</li> <li>Efficient serialization</li> <li>Language agnostic</li> </ul>"},{"location":"microservices/microservices-communication/#3-avro","title":"3. Avro","text":"<ul> <li>Binary format</li> <li>Schema evolution</li> <li>Rich data types</li> <li>Compact serialization</li> </ul>"},{"location":"microservices/microservices-communication/#error-handling","title":"Error Handling","text":""},{"location":"microservices/microservices-communication/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<ul> <li>Failure detection</li> <li>Fallback mechanisms</li> <li>Recovery strategies</li> <li>Configuration options</li> </ul>"},{"location":"microservices/microservices-communication/#retry-patterns","title":"Retry Patterns","text":"<ul> <li>Exponential backoff</li> <li>Jitter</li> <li>Maximum retries</li> <li>Timeout configurations</li> </ul>"},{"location":"microservices/microservices-communication/#dead-letter-queues","title":"Dead Letter Queues","text":"<ul> <li>Failed message handling</li> <li>Message inspection</li> <li>Reprocessing strategies</li> <li>Error logging</li> </ul>"},{"location":"microservices/microservices-communication/#best-practices","title":"Best Practices","text":"<ol> <li>Choose appropriate communication style based on requirements</li> <li>Implement proper error handling and retries</li> <li>Use circuit breakers for synchronous communication</li> <li>Maintain backward compatibility</li> <li>Monitor communication patterns</li> <li>Document APIs and events</li> <li>Implement proper security measures</li> </ol>"},{"location":"microservices/microservices-communication/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Overusing synchronous communication</li> <li>Insufficient error handling</li> <li>Poor message format design</li> <li>Lack of monitoring</li> <li>Ignoring network latency</li> <li>Missing security considerations</li> </ol>"},{"location":"microservices/microservices-communication/#implementation-examples","title":"Implementation Examples","text":""},{"location":"microservices/microservices-communication/#rest-api-with-spring-boot","title":"REST API with Spring Boot","text":"<pre><code>@RestController\n@RequestMapping(\"/api/v1/orders\")\npublic class OrderController {\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Order&gt; getOrder(@PathVariable String id) {\n        // Implementation\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-communication/#kafka-producer","title":"Kafka Producer","text":"<pre><code>@Service\npublic class OrderEventProducer {\n    private final KafkaTemplate&lt;String, OrderEvent&gt; kafkaTemplate;\n\n    public void publishOrderCreated(OrderEvent event) {\n        kafkaTemplate.send(\"order-events\", event);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-communication/#circuit-breaker-with-resilience4j","title":"Circuit Breaker with Resilience4j","text":"<pre><code>@CircuitBreaker(name = \"orderService\")\n@Retry(name = \"orderService\")\npublic Order getOrder(String id) {\n    // Implementation\n}\n</code></pre>"},{"location":"microservices/microservices-communication/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Enterprise Integration Patterns</li> <li>Spring Cloud Documentation</li> <li>Apache Kafka Documentation</li> <li>gRPC Documentation</li> </ul>"},{"location":"microservices/microservices-communication/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Implement a REST API with proper error handling</li> <li>Create a Kafka producer/consumer application</li> <li>Set up a GraphQL server with subscriptions</li> <li>Implement the Circuit Breaker pattern</li> <li>Create a pub/sub system using RabbitMQ </li> </ol>"},{"location":"microservices/microservices-deployment/","title":"Macro Rendering Error","text":"<p>File: <code>microservices/microservices-deployment.md</code></p> <p>UndefinedError: 'github' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mkdocs_macros/plugin.py\", line 527, in render\n    return md_template.render(**page_variables)\n           ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 157, in top-level template code\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\njinja2.exceptions.UndefinedError: 'github' is undefined\n</code></pre>"},{"location":"microservices/microservices-discovery/","title":"Service Discovery in Microservices","text":""},{"location":"microservices/microservices-discovery/#overview","title":"Overview","text":"<p>This guide covers service discovery patterns and implementations in microservices architecture, including both client-side and server-side discovery patterns.</p>"},{"location":"microservices/microservices-discovery/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of microservices architecture</li> <li>Knowledge of load balancing concepts</li> <li>Familiarity with distributed systems</li> <li>Basic understanding of DNS</li> </ul>"},{"location":"microservices/microservices-discovery/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand service discovery patterns</li> <li>Learn different service discovery implementations</li> <li>Master service registration and deregistration</li> <li>Implement health checks</li> <li>Handle service discovery failures</li> </ul>"},{"location":"microservices/microservices-discovery/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Service Discovery Patterns</li> <li>Service Registry</li> <li>Implementation Approaches</li> <li>Health Checking</li> <li>Best Practices</li> </ol>"},{"location":"microservices/microservices-discovery/#service-discovery-patterns","title":"Service Discovery Patterns","text":""},{"location":"microservices/microservices-discovery/#1-client-side-discovery","title":"1. Client-Side Discovery","text":"<ul> <li>Direct service lookup</li> <li>Client-side load balancing</li> <li>Service instance selection</li> <li>Benefits and drawbacks</li> </ul>"},{"location":"microservices/microservices-discovery/#2-server-side-discovery","title":"2. Server-Side Discovery","text":"<ul> <li>Load balancer-based routing</li> <li>DNS-based routing</li> <li>Proxy-based routing</li> <li>Benefits and drawbacks</li> </ul>"},{"location":"microservices/microservices-discovery/#3-hybrid-approaches","title":"3. Hybrid Approaches","text":"<ul> <li>Combined client and server discovery</li> <li>Edge service patterns</li> <li>Service mesh approaches</li> </ul>"},{"location":"microservices/microservices-discovery/#service-registry","title":"Service Registry","text":""},{"location":"microservices/microservices-discovery/#components","title":"Components","text":"<ol> <li>Service Registration</li> <li>Instance registration</li> <li>Metadata management</li> <li> <p>Registration renewal</p> </li> <li> <p>Service Deregistration</p> </li> <li>Graceful shutdown</li> <li>Instance removal</li> <li> <p>Cleanup processes</p> </li> <li> <p>Health Checks</p> </li> <li>Health check endpoints</li> <li>Timeout configurations</li> <li>Failure detection</li> </ol>"},{"location":"microservices/microservices-discovery/#popular-implementations","title":"Popular Implementations","text":""},{"location":"microservices/microservices-discovery/#1-netflix-eureka","title":"1. Netflix Eureka","text":"<pre><code>@SpringBootApplication\n@EnableEurekaServer\npublic class ServiceRegistryApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceRegistryApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-discovery/#2-consul","title":"2. Consul","text":"<pre><code>service:\n  name: user-service\n  port: 8080\n  checks:\n    - http: http://localhost:8080/health\n      interval: 10s\n</code></pre>"},{"location":"microservices/microservices-discovery/#3-zookeeper","title":"3. Zookeeper","text":"<pre><code>@Configuration\npublic class ZookeeperConfig {\n    @Bean\n    public CuratorFramework curatorFramework() {\n        return CuratorFrameworkFactory.newClient(\n            \"zookeeper:2181\",\n            new ExponentialBackoffRetry(1000, 3));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-discovery/#implementation-approaches","title":"Implementation Approaches","text":""},{"location":"microservices/microservices-discovery/#1-spring-cloud-netflix","title":"1. Spring Cloud Netflix","text":"<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\npublic class ServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-discovery/#2-kubernetes-service-discovery","title":"2. Kubernetes Service Discovery","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: user-service\nspec:\n  selector:\n    app: user-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n</code></pre>"},{"location":"microservices/microservices-discovery/#3-consul-service-discovery","title":"3. Consul Service Discovery","text":"<pre><code>@Configuration\npublic class ConsulConfig {\n    @Bean\n    public ConsulClient consulClient() {\n        return new ConsulClient(\"localhost\", 8500);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-discovery/#health-checking","title":"Health Checking","text":""},{"location":"microservices/microservices-discovery/#1-implementation","title":"1. Implementation","text":"<pre><code>@RestController\npublic class HealthController {\n    @GetMapping(\"/health\")\n    public ResponseEntity&lt;HealthStatus&gt; checkHealth() {\n        return ResponseEntity.ok(new HealthStatus(\"UP\"));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-discovery/#2-configuration","title":"2. Configuration","text":"<pre><code>management:\n  endpoints:\n    web:\n      exposure:\n        include: health\n  health:\n    show-details: always\n</code></pre>"},{"location":"microservices/microservices-discovery/#best-practices","title":"Best Practices","text":"<ol> <li>Implement proper health checks</li> <li>Use appropriate timeouts</li> <li>Handle failure scenarios gracefully</li> <li>Implement circuit breakers</li> <li>Monitor service registry</li> <li>Implement proper security</li> <li>Use appropriate caching strategies</li> </ol>"},{"location":"microservices/microservices-discovery/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Insufficient health checks</li> <li>Poor timeout configurations</li> <li>Missing security measures</li> <li>Inadequate monitoring</li> <li>Poor cache invalidation</li> <li>Missing fallback mechanisms</li> </ol>"},{"location":"microservices/microservices-discovery/#implementation-examples","title":"Implementation Examples","text":""},{"location":"microservices/microservices-discovery/#service-registration-with-eureka","title":"Service Registration with Eureka","text":"<pre><code>@SpringBootApplication\n@EnableEurekaClient\npublic class UserServiceApplication {\n    @Value(\"${server.port}\")\n    private int serverPort;\n\n    @Value(\"${spring.application.name}\")\n    private String applicationName;\n\n    @Bean\n    public EurekaInstanceConfigBean eurekaInstanceConfig() {\n        EurekaInstanceConfigBean config = new EurekaInstanceConfigBean();\n        config.setNonSecurePort(serverPort);\n        config.setAppname(applicationName);\n        return config;\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-discovery/#service-discovery-with-ribbon","title":"Service Discovery with Ribbon","text":"<pre><code>@Configuration\n@RibbonClient(name = \"user-service\")\npublic class RibbonConfig {\n    @Bean\n    public IRule ribbonRule() {\n        return new WeightedResponseTimeRule();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-discovery/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Spring Cloud Netflix</li> <li>Consul Documentation</li> <li>Kubernetes Service Discovery</li> <li>Apache Zookeeper</li> </ul>"},{"location":"microservices/microservices-discovery/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Set up Eureka server and register a client</li> <li>Implement service discovery with Consul</li> <li>Create Kubernetes services and deployments</li> <li>Implement custom health checks</li> <li>Set up service discovery with load balancing </li> </ol>"},{"location":"microservices/microservices-monitoring/","title":"Macro Syntax Error","text":"<p>File: <code>microservices/microservices-monitoring.md</code></p> <p>Line 193 in Markdown file: unexpected char '$' at 4818 <pre><code>        description: \"Service {{ $labels.service }} has high error rate\"\n</code></pre></p>"},{"location":"microservices/microservices-resilience/","title":"Microservices Resilience Patterns","text":""},{"location":"microservices/microservices-resilience/#overview","title":"Overview","text":"<p>This guide covers various resilience patterns and strategies used in microservices architecture to build robust and fault-tolerant systems.</p>"},{"location":"microservices/microservices-resilience/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of microservices architecture</li> <li>Knowledge of distributed systems</li> <li>Familiarity with Spring Boot</li> <li>Understanding of basic error handling</li> </ul>"},{"location":"microservices/microservices-resilience/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand different resilience patterns</li> <li>Learn how to implement circuit breakers</li> <li>Master retry mechanisms</li> <li>Implement fallback strategies</li> <li>Handle distributed system failures</li> </ul>"},{"location":"microservices/microservices-resilience/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Circuit Breaker Pattern</li> <li>Retry Pattern</li> <li>Bulkhead Pattern</li> <li>Fallback Pattern</li> <li>Rate Limiting</li> </ol>"},{"location":"microservices/microservices-resilience/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":""},{"location":"microservices/microservices-resilience/#overview_1","title":"Overview","text":"<p>The Circuit Breaker pattern prevents cascading failures by failing fast and providing fallback behavior.</p>"},{"location":"microservices/microservices-resilience/#states","title":"States","text":"<ol> <li>Closed (Normal Operation)</li> <li>Open (Failure State)</li> <li>Half-Open (Recovery State)</li> </ol>"},{"location":"microservices/microservices-resilience/#implementation-with-resilience4j","title":"Implementation with Resilience4j","text":"<pre><code>@Service\npublic class OrderService {\n    @CircuitBreaker(name = \"orderService\", fallbackMethod = \"fallbackMethod\")\n    public Order getOrder(String orderId) {\n        return orderRepository.findById(orderId)\n            .orElseThrow(() -&gt; new OrderNotFoundException(orderId));\n    }\n\n    public Order fallbackMethod(String orderId, Exception ex) {\n        return new Order(orderId, \"Fallback Order\");\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#configuration","title":"Configuration","text":"<pre><code>resilience4j.circuitbreaker:\n  instances:\n    orderService:\n      slidingWindowSize: 10\n      failureRateThreshold: 50\n      waitDurationInOpenState: 5000\n      permittedNumberOfCallsInHalfOpenState: 3\n</code></pre>"},{"location":"microservices/microservices-resilience/#retry-pattern","title":"Retry Pattern","text":""},{"location":"microservices/microservices-resilience/#implementation","title":"Implementation","text":"<pre><code>@Service\npublic class PaymentService {\n    @Retry(name = \"paymentService\", fallbackMethod = \"fallbackPayment\")\n    public Payment processPayment(String paymentId) {\n        return paymentGateway.process(paymentId);\n    }\n\n    public Payment fallbackPayment(String paymentId, Exception ex) {\n        return new Payment(paymentId, PaymentStatus.FAILED);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#configuration_1","title":"Configuration","text":"<pre><code>resilience4j.retry:\n  instances:\n    paymentService:\n      maxAttempts: 3\n      waitDuration: 1s\n      exponentialBackoff: true\n      exponentialBackoffMultiplier: 2\n</code></pre>"},{"location":"microservices/microservices-resilience/#bulkhead-pattern","title":"Bulkhead Pattern","text":""},{"location":"microservices/microservices-resilience/#thread-pool-bulkhead","title":"Thread Pool Bulkhead","text":"<pre><code>@Service\npublic class UserService {\n    @Bulkhead(name = \"userService\", type = Bulkhead.Type.THREADPOOL)\n    public User getUser(String userId) {\n        return userRepository.findById(userId)\n            .orElseThrow(() -&gt; new UserNotFoundException(userId));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#semaphore-bulkhead","title":"Semaphore Bulkhead","text":"<pre><code>@Service\npublic class ProductService {\n    @Bulkhead(name = \"productService\", type = Bulkhead.Type.SEMAPHORE)\n    public Product getProduct(String productId) {\n        return productRepository.findById(productId)\n            .orElseThrow(() -&gt; new ProductNotFoundException(productId));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#fallback-pattern","title":"Fallback Pattern","text":""},{"location":"microservices/microservices-resilience/#static-fallback","title":"Static Fallback","text":"<pre><code>@Service\npublic class CatalogService {\n    private final Cache&lt;String, Product&gt; cache;\n\n    @CircuitBreaker(name = \"catalogService\", fallbackMethod = \"getCachedProduct\")\n    public Product getProduct(String productId) {\n        return productRepository.findById(productId)\n            .orElseThrow(() -&gt; new ProductNotFoundException(productId));\n    }\n\n    private Product getCachedProduct(String productId, Exception ex) {\n        return cache.getIfPresent(productId);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#dynamic-fallback","title":"Dynamic Fallback","text":"<pre><code>@Service\npublic class RecommendationService {\n    @CircuitBreaker(name = \"recommendationService\", fallbackMethod = \"getDefaultRecommendations\")\n    public List&lt;Product&gt; getRecommendations(String userId) {\n        return recommendationEngine.getPersonalizedRecommendations(userId);\n    }\n\n    private List&lt;Product&gt; getDefaultRecommendations(String userId, Exception ex) {\n        return productRepository.findTopRated();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#rate-limiting","title":"Rate Limiting","text":""},{"location":"microservices/microservices-resilience/#implementation_1","title":"Implementation","text":"<pre><code>@Service\npublic class APIService {\n    @RateLimiter(name = \"apiService\")\n    public Response processRequest(Request request) {\n        return processAPIRequest(request);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#configuration_2","title":"Configuration","text":"<pre><code>resilience4j.ratelimiter:\n  instances:\n    apiService:\n      limitForPeriod: 10\n      limitRefreshPeriod: 1s\n      timeoutDuration: 500ms\n</code></pre>"},{"location":"microservices/microservices-resilience/#best-practices","title":"Best Practices","text":"<ol> <li>Implement multiple resilience patterns together</li> <li>Configure appropriate timeouts</li> <li>Use monitoring and alerting</li> <li>Implement proper logging</li> <li>Test failure scenarios</li> <li>Document fallback behaviors</li> <li>Monitor circuit breaker states</li> </ol>"},{"location":"microservices/microservices-resilience/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Incorrect timeout configurations</li> <li>Missing fallback implementations</li> <li>Poor monitoring</li> <li>Inadequate testing</li> <li>Improper thread pool sizing</li> <li>Missing rate limiting</li> </ol>"},{"location":"microservices/microservices-resilience/#implementation-examples","title":"Implementation Examples","text":""},{"location":"microservices/microservices-resilience/#combined-patterns","title":"Combined Patterns","text":"<pre><code>@Service\npublic class OrderProcessingService {\n    @CircuitBreaker(name = \"orderProcessing\")\n    @Retry(name = \"orderProcessing\")\n    @Bulkhead(name = \"orderProcessing\")\n    @RateLimiter(name = \"orderProcessing\")\n    public Order processOrder(OrderRequest request) {\n        return orderProcessor.process(request);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#resilience4j-configuration","title":"Resilience4j Configuration","text":"<pre><code>@Configuration\npublic class Resilience4jConfig {\n    @Bean\n    public CircuitBreakerConfig circuitBreakerConfig() {\n        return CircuitBreakerConfig.custom()\n            .failureRateThreshold(50)\n            .waitDurationInOpenState(Duration.ofMillis(1000))\n            .slidingWindowSize(2)\n            .build();\n    }\n\n    @Bean\n    public RetryConfig retryConfig() {\n        return RetryConfig.custom()\n            .maxAttempts(3)\n            .waitDuration(Duration.ofMillis(100))\n            .build();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-resilience/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Resilience4j Documentation</li> <li>Spring Cloud Circuit Breaker</li> <li>Netflix Hystrix Wiki</li> <li>Microsoft Resilience Patterns</li> </ul>"},{"location":"microservices/microservices-resilience/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Implement Circuit Breaker with custom configurations</li> <li>Create a service with multiple resilience patterns</li> <li>Implement custom fallback strategies</li> <li>Set up monitoring for circuit breakers</li> <li>Test different failure scenarios </li> </ol>"},{"location":"microservices/microservices-security/","title":"Microservices Security","text":""},{"location":"microservices/microservices-security/#overview","title":"Overview","text":"<p>This guide covers security patterns, best practices, and implementation approaches for securing microservices architecture.</p>"},{"location":"microservices/microservices-security/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of microservices architecture</li> <li>Knowledge of Spring Security</li> <li>Familiarity with OAuth2 and JWT</li> <li>Understanding of SSL/TLS</li> </ul>"},{"location":"microservices/microservices-security/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand microservices security patterns</li> <li>Learn OAuth2 implementation</li> <li>Master JWT authentication</li> <li>Implement service-to-service security</li> <li>Handle security at API Gateway level</li> </ul>"},{"location":"microservices/microservices-security/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Authentication and Authorization</li> <li>OAuth2 Implementation</li> <li>JWT Security</li> <li>Service-to-Service Security</li> <li>API Gateway Security</li> </ol>"},{"location":"microservices/microservices-security/#authentication-and-authorization","title":"Authentication and Authorization","text":""},{"location":"microservices/microservices-security/#spring-security-configuration","title":"Spring Security Configuration","text":"<pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()\n            .authorizeRequests()\n                .antMatchers(\"/public/**\").permitAll()\n                .antMatchers(\"/api/**\").authenticated()\n            .and()\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .addFilterBefore(jwtAuthenticationFilter(), \n                UsernamePasswordAuthenticationFilter.class);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#user-details-service","title":"User Details Service","text":"<pre><code>@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n\n    private final UserRepository userRepository;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) \n            throws UsernameNotFoundException {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -&gt; new UsernameNotFoundException(\n                \"User not found: \" + username));\n\n        return new org.springframework.security.core.userdetails.User(\n            user.getUsername(),\n            user.getPassword(),\n            getAuthorities(user.getRoles()));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#oauth2-implementation","title":"OAuth2 Implementation","text":""},{"location":"microservices/microservices-security/#authorization-server-configuration","title":"Authorization Server Configuration","text":"<pre><code>@Configuration\n@EnableAuthorizationServer\npublic class AuthServerConfig extends AuthorizationServerConfigurerAdapter {\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) \n            throws Exception {\n        clients.inMemory()\n            .withClient(\"client-id\")\n            .secret(passwordEncoder().encode(\"client-secret\"))\n            .authorizedGrantTypes(\"password\", \"refresh_token\")\n            .scopes(\"read\", \"write\")\n            .accessTokenValiditySeconds(3600)\n            .refreshTokenValiditySeconds(86400);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#resource-server-configuration","title":"Resource Server Configuration","text":"<pre><code>@Configuration\n@EnableResourceServer\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter {\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n            .antMatchers(\"/api/**\").authenticated()\n            .and()\n            .oauth2ResourceServer()\n            .jwt();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#jwt-security","title":"JWT Security","text":""},{"location":"microservices/microservices-security/#jwt-token-provider","title":"JWT Token Provider","text":"<pre><code>@Component\npublic class JwtTokenProvider {\n\n    @Value(\"${jwt.secret}\")\n    private String jwtSecret;\n\n    @Value(\"${jwt.expiration}\")\n    private int jwtExpiration;\n\n    public String generateToken(Authentication authentication) {\n        UserDetails userDetails = (UserDetails) authentication.getPrincipal();\n\n        return Jwts.builder()\n            .setSubject(userDetails.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(new Date().getTime() + jwtExpiration))\n            .signWith(SignatureAlgorithm.HS512, jwtSecret)\n            .compact();\n    }\n\n    public boolean validateToken(String token) {\n        try {\n            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);\n            return true;\n        } catch (JwtException | IllegalArgumentException e) {\n            return false;\n        }\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#jwt-authentication-filter","title":"JWT Authentication Filter","text":"<pre><code>@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private JwtTokenProvider tokenProvider;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n            HttpServletResponse response, FilterChain filterChain)\n            throws ServletException, IOException {\n        try {\n            String jwt = getJwtFromRequest(request);\n\n            if (StringUtils.hasText(jwt) &amp;&amp; tokenProvider.validateToken(jwt)) {\n                String username = tokenProvider.getUsernameFromJWT(jwt);\n                UserDetails userDetails = userDetailsService\n                    .loadUserByUsername(username);\n\n                UsernamePasswordAuthenticationToken authentication =\n                    new UsernamePasswordAuthenticationToken(\n                        userDetails, null, userDetails.getAuthorities());\n\n                SecurityContextHolder.getContext()\n                    .setAuthentication(authentication);\n            }\n        } catch (Exception ex) {\n            logger.error(\"Could not set user authentication in security context\", ex);\n        }\n\n        filterChain.doFilter(request, response);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#service-to-service-security","title":"Service-to-Service Security","text":""},{"location":"microservices/microservices-security/#mutual-tls-configuration","title":"Mutual TLS Configuration","text":"<pre><code>@Configuration\npublic class MutualTlsConfig {\n\n    @Bean\n    public RestTemplate restTemplate() throws Exception {\n        SSLContext sslContext = SSLContextBuilder\n            .create()\n            .loadTrustMaterial(trustStore.getFile())\n            .loadKeyMaterial(\n                keyStore.getFile(),\n                keyStorePassword.toCharArray(),\n                keyPassword.toCharArray()\n            )\n            .build();\n\n        HttpClient client = HttpClients.custom()\n            .setSSLContext(sslContext)\n            .build();\n\n        HttpComponentsClientHttpRequestFactory requestFactory =\n            new HttpComponentsClientHttpRequestFactory(client);\n\n        return new RestTemplate(requestFactory);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#client-certificate-authentication","title":"Client Certificate Authentication","text":"<pre><code>@Configuration\npublic class ClientCertificateConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n            .anyRequest().authenticated()\n            .and()\n            .x509()\n            .subjectPrincipalRegex(\"CN=(.*?)(?:,|$)\")\n            .userDetailsService(userDetailsService());\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#api-gateway-security","title":"API Gateway Security","text":""},{"location":"microservices/microservices-security/#gateway-security-configuration","title":"Gateway Security Configuration","text":"<pre><code>@Configuration\npublic class GatewaySecurityConfig {\n\n    @Bean\n    public SecurityWebFilterChain springSecurityFilterChain(\n            ServerHttpSecurity http) {\n        http\n            .csrf().disable()\n            .authorizeExchange()\n                .pathMatchers(\"/public/**\").permitAll()\n                .anyExchange().authenticated()\n            .and()\n            .oauth2ResourceServer()\n                .jwt();\n        return http.build();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#rate-limiting","title":"Rate Limiting","text":"<pre><code>@Configuration\npublic class RateLimitingConfig {\n\n    @Bean\n    public KeyResolver userKeyResolver() {\n        return exchange -&gt; Mono.just(\n            exchange.getRequest()\n                .getHeaders()\n                .getFirst(\"X-User-Id\"));\n    }\n\n    @Bean\n    public RateLimiter rateLimiter() {\n        return new RedisRateLimiter(10, 20);\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#best-practices","title":"Best Practices","text":"<ol> <li>Use HTTPS everywhere</li> <li>Implement proper authentication and authorization</li> <li>Use secure session management</li> <li>Implement rate limiting</li> <li>Use secure communication between services</li> <li>Regular security audits</li> <li>Implement proper logging and monitoring</li> </ol>"},{"location":"microservices/microservices-security/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Insecure communication between services</li> <li>Weak authentication mechanisms</li> <li>Missing rate limiting</li> <li>Poor secret management</li> <li>Insufficient logging</li> <li>Missing security headers</li> </ol>"},{"location":"microservices/microservices-security/#implementation-examples","title":"Implementation Examples","text":""},{"location":"microservices/microservices-security/#complete-security-configuration","title":"Complete Security Configuration","text":"<pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()\n            .cors()\n            .and()\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .authorizeRequests()\n                .antMatchers(\"/public/**\").permitAll()\n                .antMatchers(\"/api/**\").authenticated()\n            .and()\n            .oauth2ResourceServer()\n                .jwt()\n            .and()\n            .addFilterBefore(jwtAuthenticationFilter(),\n                UsernamePasswordAuthenticationFilter.class)\n            .headers()\n                .frameOptions().deny()\n                .xssProtection()\n                .and()\n                .contentSecurityPolicy(\"script-src 'self'\");\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#security-headers-configuration","title":"Security Headers Configuration","text":"<pre><code>@Configuration\npublic class SecurityHeadersConfig {\n\n    @Bean\n    public WebFilter securityHeadersFilter() {\n        return (exchange, chain) -&gt; {\n            ServerHttpResponse response = exchange.getResponse();\n            response.getHeaders().add(\"X-XSS-Protection\", \"1; mode=block\");\n            response.getHeaders().add(\"X-Frame-Options\", \"DENY\");\n            response.getHeaders().add(\"X-Content-Type-Options\", \"nosniff\");\n            response.getHeaders().add(\"Strict-Transport-Security\",\n                \"max-age=31536000; includeSubDomains\");\n            return chain.filter(exchange);\n        };\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-security/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>Spring Security Documentation</li> <li>OAuth2 Specifications</li> <li>JWT.io</li> <li>OWASP Microservices Security</li> </ul>"},{"location":"microservices/microservices-security/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Implement OAuth2 authentication</li> <li>Set up JWT-based authentication</li> <li>Configure mutual TLS</li> <li>Implement rate limiting</li> <li>Set up security headers </li> </ol>"},{"location":"microservices/microservices-testing/","title":"Microservices Testing","text":""},{"location":"microservices/microservices-testing/#overview","title":"Overview","text":"<p>This guide covers comprehensive testing strategies for microservices architecture, including unit testing, integration testing, contract testing, and end-to-end testing approaches.</p>"},{"location":"microservices/microservices-testing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of microservices architecture</li> <li>Knowledge of testing frameworks (JUnit, Mockito)</li> <li>Familiarity with Spring Boot Testing</li> <li>Understanding of contract testing concepts</li> </ul>"},{"location":"microservices/microservices-testing/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand different testing strategies</li> <li>Learn unit testing best practices</li> <li>Master integration testing</li> <li>Implement contract testing</li> <li>Handle end-to-end testing</li> </ul>"},{"location":"microservices/microservices-testing/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Unit Testing</li> <li>Integration Testing</li> <li>Contract Testing</li> <li>End-to-End Testing</li> <li>Performance Testing</li> </ol>"},{"location":"microservices/microservices-testing/#unit-testing","title":"Unit Testing","text":""},{"location":"microservices/microservices-testing/#service-layer-testing","title":"Service Layer Testing","text":"<pre><code>@ExtendWith(MockitoExtension.class)\npublic class UserServiceTest {\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    void whenGetUser_thenReturnUser() {\n        // Arrange\n        User user = new User(\"1\", \"John Doe\");\n        when(userRepository.findById(\"1\")).thenReturn(Optional.of(user));\n\n        // Act\n        User result = userService.getUser(\"1\");\n\n        // Assert\n        assertNotNull(result);\n        assertEquals(\"John Doe\", result.getName());\n        verify(userRepository).findById(\"1\");\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#controller-layer-testing","title":"Controller Layer Testing","text":"<pre><code>@WebMvcTest(UserController.class)\npublic class UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private UserService userService;\n\n    @Test\n    void whenGetUser_thenReturnJson() throws Exception {\n        User user = new User(\"1\", \"John Doe\");\n        when(userService.getUser(\"1\")).thenReturn(user);\n\n        mockMvc.perform(get(\"/api/users/1\")\n                .contentType(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(jsonPath(\"$.name\").value(\"John Doe\"));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#integration-testing","title":"Integration Testing","text":""},{"location":"microservices/microservices-testing/#database-integration-testing","title":"Database Integration Testing","text":"<pre><code>@SpringBootTest\n@AutoConfigureTestDatabase\npublic class UserRepositoryIntegrationTest {\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    void whenSaveUser_thenReturnSavedUser() {\n        // Arrange\n        User user = new User(null, \"John Doe\");\n\n        // Act\n        User savedUser = userRepository.save(user);\n\n        // Assert\n        assertNotNull(savedUser.getId());\n        assertEquals(\"John Doe\", savedUser.getName());\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#api-integration-testing","title":"API Integration Testing","text":"<pre><code>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class UserApiIntegrationTest {\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    void whenCallUserApi_thenReturnUser() {\n        // Act\n        ResponseEntity&lt;User&gt; response = restTemplate.getForEntity(\n            \"/api/users/1\", User.class);\n\n        // Assert\n        assertEquals(HttpStatus.OK, response.getStatusCode());\n        assertNotNull(response.getBody());\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#contract-testing","title":"Contract Testing","text":""},{"location":"microservices/microservices-testing/#consumer-contract","title":"Consumer Contract","text":"<pre><code>@SpringBootTest\n@AutoConfigureMessageVerifier\npublic class UserServiceConsumerTest {\n    @Autowired\n    private UserClient userClient;\n\n    @Test\n    @PactTestFor(providerName = \"user-service\")\n    void whenGetUser_thenReturnUser() {\n        // Arrange\n        MockMvcTestTarget target = new MockMvcTestTarget();\n        target.setControllerAdvice(new GlobalExceptionHandler());\n\n        // Act &amp; Assert\n        User user = userClient.getUser(\"1\");\n        assertThat(user).isNotNull();\n        assertThat(user.getName()).isEqualTo(\"John Doe\");\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#provider-contract","title":"Provider Contract","text":"<pre><code>@SpringBootTest\n@Provider(\"user-service\")\n@PactBroker\npublic class UserServiceProviderTest {\n    @MockBean\n    private UserService userService;\n\n    @TestTemplate\n    @ExtendWith(PactVerificationInvocationContextProvider.class)\n    void pactVerificationTestTemplate(PactVerificationContext context) {\n        context.verifyInteraction();\n    }\n\n    @State(\"User exists\")\n    void toUserExistsState() {\n        when(userService.getUser(\"1\"))\n            .thenReturn(new User(\"1\", \"John Doe\"));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#end-to-end-testing","title":"End-to-End Testing","text":""},{"location":"microservices/microservices-testing/#cucumber-test","title":"Cucumber Test","text":"<pre><code>@SpringBootTest\n@CucumberContextConfiguration\npublic class UserFlowTest {\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Given(\"a user exists with id {string}\")\n    public void userExists(String id) {\n        // Setup test data\n    }\n\n    @When(\"the client requests user details\")\n    public void clientRequestsUser() {\n        response = restTemplate.getForEntity(\"/api/users/1\", User.class);\n    }\n\n    @Then(\"the response should contain user details\")\n    public void validateResponse() {\n        assertEquals(HttpStatus.OK, response.getStatusCode());\n        assertNotNull(response.getBody());\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#selenium-test","title":"Selenium Test","text":"<pre><code>public class UserUITest {\n    private WebDriver driver;\n\n    @Test\n    void testUserDetailsPage() {\n        driver.get(\"http://localhost:8080/users/1\");\n\n        WebElement nameElement = driver.findElement(By.id(\"userName\"));\n        assertEquals(\"John Doe\", nameElement.getText());\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#performance-testing","title":"Performance Testing","text":""},{"location":"microservices/microservices-testing/#jmeter-test-plan","title":"JMeter Test Plan","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;jmeterTestPlan version=\"1.2\"&gt;\n  &lt;hashTree&gt;\n    &lt;TestPlan guiclass=\"TestPlanGui\" testclass=\"TestPlan\" testname=\"User Service Test\"&gt;\n      &lt;elementProp name=\"TestPlan.user_defined_variables\" elementType=\"Arguments\"&gt;\n        &lt;collectionProp name=\"Arguments.arguments\"/&gt;\n      &lt;/elementProp&gt;\n    &lt;/TestPlan&gt;\n    &lt;hashTree&gt;\n      &lt;ThreadGroup guiclass=\"ThreadGroupGui\" testclass=\"ThreadGroup\" testname=\"Users\"&gt;\n        &lt;elementProp name=\"ThreadGroup.main_controller\" elementType=\"LoopController\"&gt;\n          &lt;stringProp name=\"LoopController.loops\"&gt;10&lt;/stringProp&gt;\n        &lt;/elementProp&gt;\n        &lt;stringProp name=\"ThreadGroup.num_threads\"&gt;100&lt;/stringProp&gt;\n      &lt;/ThreadGroup&gt;\n    &lt;/hashTree&gt;\n  &lt;/hashTree&gt;\n&lt;/jmeterTestPlan&gt;\n</code></pre>"},{"location":"microservices/microservices-testing/#gatling-test","title":"Gatling Test","text":"<pre><code>class UserSimulation extends Simulation {\n  val httpProtocol = http\n    .baseUrl(\"http://localhost:8080\")\n    .acceptHeader(\"application/json\")\n\n  val scn = scenario(\"Get User\")\n    .exec(http(\"request_1\")\n      .get(\"/api/users/1\"))\n    .pause(5)\n\n  setUp(scn.inject(\n    rampUsers(100).during(10.seconds)\n  ).protocols(httpProtocol))\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#best-practices","title":"Best Practices","text":"<ol> <li>Follow the testing pyramid</li> <li>Write maintainable tests</li> <li>Use appropriate test doubles</li> <li>Implement continuous testing</li> <li>Monitor test coverage</li> <li>Write meaningful assertions</li> <li>Use test data builders</li> </ol>"},{"location":"microservices/microservices-testing/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Insufficient test coverage</li> <li>Brittle tests</li> <li>Slow tests</li> <li>Missing integration tests</li> <li>Poor test isolation</li> <li>Inadequate error scenarios</li> </ol>"},{"location":"microservices/microservices-testing/#implementation-examples","title":"Implementation Examples","text":""},{"location":"microservices/microservices-testing/#complete-test-suite","title":"Complete Test Suite","text":"<pre><code>@SpringBootTest\npublic class UserServiceCompleteTest {\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @BeforeEach\n    void setup() {\n        userRepository.deleteAll();\n    }\n\n    @Test\n    void testCreateUser() {\n        User user = new User(null, \"John Doe\");\n        User savedUser = userService.createUser(user);\n        assertNotNull(savedUser.getId());\n    }\n\n    @Test\n    void testUpdateUser() {\n        User user = userService.createUser(new User(null, \"John Doe\"));\n        user.setName(\"Jane Doe\");\n        User updatedUser = userService.updateUser(user);\n        assertEquals(\"Jane Doe\", updatedUser.getName());\n    }\n\n    @Test\n    void testDeleteUser() {\n        User user = userService.createUser(new User(null, \"John Doe\"));\n        userService.deleteUser(user.getId());\n        assertThrows(UserNotFoundException.class,\n            () -&gt; userService.getUser(user.getId()));\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#test-configuration","title":"Test Configuration","text":"<pre><code>@Configuration\n@Profile(\"test\")\npublic class TestConfig {\n    @Bean\n    public UserRepository userRepository() {\n        return new InMemoryUserRepository();\n    }\n\n    @Bean\n    public TestRestTemplate testRestTemplate() {\n        return new TestRestTemplate();\n    }\n}\n</code></pre>"},{"location":"microservices/microservices-testing/#resources-for-further-learning","title":"Resources for Further Learning","text":"<ul> <li>JUnit 5 Documentation</li> <li>Mockito Documentation</li> <li>Spring Boot Testing Guide</li> <li>Pact Documentation</li> </ul>"},{"location":"microservices/microservices-testing/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Write comprehensive unit tests</li> <li>Implement integration tests</li> <li>Set up contract testing</li> <li>Create end-to-end tests</li> <li>Perform load testing </li> </ol>"},{"location":"microservices/platform-architecture/","title":"Kubernetes API Request Flow Architecture","text":""},{"location":"microservices/platform-architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Architecture Components</li> <li>Request Flow Sequence Diagram</li> <li>Component Roles and Responsibilities</li> <li>TLS/SSL Certificate Configurations</li> <li>Security and Performance Considerations</li> <li>Best Practices and Recommendations</li> <li>References</li> </ul>"},{"location":"microservices/platform-architecture/#overview","title":"Overview","text":"<p>This document outlines the comprehensive journey of an API request in a production Kubernetes environment, from the initial client request to response delivery. The architecture follows industry best practices for security, performance, and reliability, implementing a multi-layered approach to protect and efficiently deliver API services.</p> <p>The document details how requests flow through each architectural component, focusing on security aspects, performance considerations, and potential failure points. It provides infrastructure teams and technical architects with an in-depth understanding of the platform's request handling mechanisms.</p>"},{"location":"microservices/platform-architecture/#architecture-components","title":"Architecture Components","text":"<p>The key components in our Kubernetes API request flow architecture include:</p> <ol> <li>Client Application: The source of API requests (mobile app, web application, or third-party service)</li> <li>Akamai CDN/Edge Protection: Global content delivery network and edge protection layer</li> <li>NGINX Ingress Controller: Kubernetes entry point for external HTTP/HTTPS traffic</li> <li>Kubernetes Ingress Resources: Kubernetes objects defining routing rules</li> <li>Kubernetes Services: Internal load balancing and service discovery mechanism</li> <li>Kubernetes Pods: Running application containers that process requests</li> <li>Service Backends: Databases, caches, and other backing services</li> </ol>"},{"location":"microservices/platform-architecture/#request-flow-sequence-diagram","title":"Request Flow Sequence Diagram","text":"<p><pre><code>sequenceDiagram\n    participant Client\n    participant Akamai as Akamai CDN/Edge\n    participant NGINX as NGINX Ingress Controller\n    participant KIngress as Kubernetes Ingress\n    participant KService as Kubernetes Service\n    participant Pod as Application Pod\n    participant Backend as Backend Services\n\n    Note over Client,Backend: Request Flow\n\n    Client-&gt;&gt;Akamai: HTTPS Request\n    Note right of Akamai: TLS Termination&lt;br/&gt;WAF Processing&lt;br/&gt;DDoS Protection&lt;br/&gt;Edge Caching Check\n\n    alt Cached Response Available\n        Akamai--&gt;&gt;Client: Return Cached Response\n    else Cache Miss\n        Akamai-&gt;&gt;NGINX: Re-encrypted HTTPS Request\n        Note right of NGINX: TLS Termination&lt;br/&gt;Request Routing&lt;br/&gt;Rate Limiting\n\n        NGINX-&gt;&gt;KIngress: HTTP Request\n        Note right of KIngress: Routing Rule&lt;br/&gt;Application\n\n        KIngress-&gt;&gt;KService: Routed Request\n        Note right of KService: Load Balancing&lt;br/&gt;Service Discovery\n\n        KService-&gt;&gt;Pod: Request to Selected Pod\n        Note right of Pod: Request Processing&lt;br/&gt;Business Logic&lt;br/&gt;Authentication\n\n        alt External Data Required\n            Pod-&gt;&gt;Backend: Backend Service Request\n            Backend--&gt;&gt;Pod: Backend Response\n        end\n\n        Pod--&gt;&gt;KService: Response\n        KService--&gt;&gt;KIngress: Response\n        KIngress--&gt;&gt;NGINX: Response\n\n        Note right of NGINX: Response&lt;br/&gt;Processing&lt;br/&gt;Compression\n\n        NGINX--&gt;&gt;Akamai: HTTPS Response\n\n        Note right of Akamai: Response Caching&lt;br/&gt;Edge Optimization\n\n        Akamai--&gt;&gt;Client: HTTPS Response\n    end\n\n    Note over Client,Backend: Response Flow Complete</code></pre> </p>"},{"location":"microservices/platform-architecture/#component-roles-and-responsibilities","title":"Component Roles and Responsibilities","text":""},{"location":"microservices/platform-architecture/#client-application","title":"Client Application","text":"<ul> <li>Role: Originates API requests to the platform</li> <li>Responsibilities:</li> <li>Forms properly structured API requests</li> <li>Handles authentication tokens/credentials</li> <li>Processes responses</li> <li>Implements retry logic and circuit breaking</li> <li>Maintains secure TLS connections</li> </ul>"},{"location":"microservices/platform-architecture/#akamai-cdnedge-protection","title":"Akamai CDN/Edge Protection","text":"<ul> <li>Role: Provides edge protection, global distribution, and performance optimization</li> <li>Responsibilities:</li> <li>DDoS Mitigation: Protection against volumetric and application-layer attacks</li> <li>Web Application Firewall (WAF): Blocks common exploitation techniques and attacks</li> <li>TLS Termination: Handles initial client SSL/TLS connections</li> <li>Content Caching: Stores and serves cacheable API responses</li> <li>Request Filtering: Blocks malicious traffic based on signatures and behavior</li> <li>Geographic Distribution: Routes requests to nearest data centers</li> <li>Rate Limiting: Enforces global rate limits to protect backend services</li> <li>Bot Detection: Identifies and manages automated traffic</li> <li>Edge Computing: May execute simple transformations at the edge</li> </ul>"},{"location":"microservices/platform-architecture/#nginx-ingress-controller","title":"NGINX Ingress Controller","text":"<ul> <li>Role: Acts as the entry point for external traffic into the Kubernetes cluster</li> <li>Responsibilities:</li> <li>TLS Termination: Handles HTTPS connections from Akamai</li> <li>Request Routing: Directs traffic to appropriate services based on URL paths</li> <li>Load Balancing: Distributes traffic across multiple service instances</li> <li>Rate Limiting: Provides service-specific rate controls</li> <li>SSL/TLS Management: Manages certificates for secure communication</li> <li>Request/Response Manipulation: Modifies headers, performs redirects</li> <li>Authentication: Optional integration with auth services</li> <li>Health Checks: Monitors backend services</li> <li>Metrics Collection: Captures detailed request metrics</li> </ul>"},{"location":"microservices/platform-architecture/#kubernetes-ingress-resources","title":"Kubernetes Ingress Resources","text":"<ul> <li>Role: Declarative definition of how external HTTP traffic should be routed</li> <li>Responsibilities:</li> <li>Path-based Routing: Maps URL paths to specific services</li> <li>Host-based Routing: Routes traffic based on domain names</li> <li>TLS Configuration: Specifies certificate resources for secure connections</li> <li>Traffic Splitting: Can be used for canary deployments</li> <li>Rewrite Rules: Modifies request URLs before forwarding</li> <li>Annotation Support: Provides controller-specific configurations</li> </ul>"},{"location":"microservices/platform-architecture/#kubernetes-services","title":"Kubernetes Services","text":"<ul> <li>Role: Provides stable network identity and load balancing for pods</li> <li>Responsibilities:</li> <li>Service Discovery: Provides DNS names for sets of pods</li> <li>Load Balancing: Distributes traffic among available pods</li> <li>IP Management: Assigns stable virtual IPs to services</li> <li>Port Mapping: Maps service ports to container ports</li> <li>Session Affinity: Optional support for sticky sessions</li> <li>Headless Services: Allows direct DNS lookup of pod IPs when needed</li> <li>External Services: Can represent external endpoints when needed</li> </ul>"},{"location":"microservices/platform-architecture/#kubernetes-pods","title":"Kubernetes Pods","text":"<ul> <li>Role: Houses application containers that process requests</li> <li>Responsibilities:</li> <li>Application Execution: Runs application code in containers</li> <li>Request Processing: Handles business logic for API requests</li> <li>Data Validation: Validates incoming request data</li> <li>Authentication/Authorization: Verifies user permissions</li> <li>Backend Integration: Communicates with databases and other services</li> <li>Response Formation: Generates API responses</li> <li>Resource Management: Works within allocated CPU/memory constraints</li> <li>Health Reporting: Exposes health status to the cluster</li> </ul>"},{"location":"microservices/platform-architecture/#tlsssl-certificate-configurations","title":"TLS/SSL Certificate Configurations","text":""},{"location":"microservices/platform-architecture/#akamai-edge-certificates-customer-facing","title":"Akamai Edge Certificates (Customer-Facing)","text":"<ul> <li>Type: Public CA-issued certificates (DigiCert, Let's Encrypt)</li> <li>Purpose: Secures communication between clients and Akamai edge</li> <li>Configuration:</li> <li>Certificate Type: Usually wildcard or SAN certificates</li> <li>Key Size: 2048-bit RSA or ECC P-256</li> <li>Validity Period: Typically 1 year</li> <li>Management: Automated through Akamai Certificate Manager</li> <li>TLS Version: TLS 1.2/1.3 only</li> <li>Cipher Suites: Modern, strong cipher suites only</li> <li>OCSP Stapling: Enabled</li> <li>HTTP Strict Transport Security (HSTS): Enabled</li> </ul>"},{"location":"microservices/platform-architecture/#akamai-to-origin-certificates","title":"Akamai-to-Origin Certificates","text":"<ul> <li>Type: Public or Private CA certificates</li> <li>Purpose: Secures communication between Akamai and NGINX Ingress</li> <li>Configuration:</li> <li>Certificate Type: Domain-specific certificate</li> <li>Validation: Mutual TLS optional for additional security</li> <li>Management: Automated with monitoring and alerts</li> <li>Rotation: Regularly scheduled rotation (quarterly)</li> <li>Key Storage: Secure key storage with restricted access</li> <li>IP Restrictions: Typically limited to Akamai IP ranges</li> </ul>"},{"location":"microservices/platform-architecture/#nginx-ingress-controller-certificates","title":"NGINX Ingress Controller Certificates","text":"<ul> <li>Type: Kubernetes-managed certificates via cert-manager</li> <li>Purpose: Terminates TLS connections from Akamai and secures traffic</li> <li>Configuration:</li> <li>Certificate Source: Let's Encrypt or private CA</li> <li>Validation: Domain validation automated</li> <li>Storage: Kubernetes secrets</li> <li>Rotation: Automated renewal before expiration</li> <li>Key Size: 2048-bit RSA or ECC P-256</li> <li>TLS Settings: Configured via ingress annotations</li> <li>Secret References: Referenced in Ingress resources</li> </ul>"},{"location":"microservices/platform-architecture/#internal-service-mesh-certificates-optional","title":"Internal Service Mesh Certificates (Optional)","text":"<ul> <li>Type: Service mesh CA-issued certificates (e.g., Istio, Linkerd)</li> <li>Purpose: Enables mTLS between services inside the cluster</li> <li>Configuration:</li> <li>Certificate Authority: Self-signed or intermediate CA</li> <li>Workload Identity: Pod-specific certificates</li> <li>Certificate Lifetime: Short-lived (24 hours typical)</li> <li>Rotation: Automatic rotation before expiration</li> <li>Key Generation: Generated on pod startup</li> <li>Trust Chain: Managed by service mesh control plane</li> </ul>"},{"location":"microservices/platform-architecture/#certificate-renewal-and-management-processes","title":"Certificate Renewal and Management Processes","text":"<ol> <li>Monitoring:</li> <li>Automated certificate expiration monitoring</li> <li>Alerting at multiple thresholds (30, 14, 7, 3, 1 days)</li> <li> <p>Certificate inventory database</p> </li> <li> <p>Automation:</p> </li> <li>cert-manager for Kubernetes certificates</li> <li>Akamai certificate automation for edge certificates</li> <li> <p>API-based renewal processes</p> </li> <li> <p>Emergency Procedures:</p> </li> <li>Certificate revocation protocol</li> <li>Emergency replacement process</li> <li>Fallback certificates for critical services</li> <li> <p>On-call rotation for certificate issues</p> </li> <li> <p>Audit and Compliance:</p> </li> <li>Regular certificate inventory audits</li> <li>Compliance verification (key strength, algorithms)</li> <li>Certificate transparency monitoring</li> </ol>"},{"location":"microservices/platform-architecture/#security-and-performance-considerations","title":"Security and Performance Considerations","text":""},{"location":"microservices/platform-architecture/#tls-termination-points-and-re-encryption","title":"TLS Termination Points and Re-encryption","text":"<ol> <li>Client to Akamai Edge:</li> <li>First TLS termination at Akamai edge</li> <li>Modern TLS protocol and cipher suites</li> <li> <p>Complete validation of client certificates if used</p> </li> <li> <p>Akamai to NGINX Ingress:</p> </li> <li>Re-encrypted connection with separate certificate</li> <li>Potential for mutual TLS authentication</li> <li>IP-restricted access (Akamai edge IP ranges only)</li> <li> <p>Private network path where possible</p> </li> <li> <p>Service Mesh Communication (Optional):</p> </li> <li>Automatic mTLS between services</li> <li>Certificate-based service identity</li> <li>Encrypted east-west traffic within cluster</li> </ol>"},{"location":"microservices/platform-architecture/#network-security-controls","title":"Network Security Controls","text":"<ol> <li>Edge Security:</li> <li>IP reputation filtering</li> <li>Bot management</li> <li>DDoS protection</li> <li>API rate limiting</li> <li>Geo-blocking capabilities</li> <li> <p>Custom WAF rules</p> </li> <li> <p>Cluster Network Security:</p> </li> <li>Network policies for pod isolation</li> <li>Ingress/egress restrictions</li> <li>Service mesh traffic policies</li> <li>Namespace isolation</li> <li> <p>Container network security</p> </li> <li> <p>Pod Security:</p> </li> <li>Pod Security Policies/Standards</li> <li>Read-only file systems</li> <li>Non-root containers</li> <li>Dropped capabilities</li> <li>Resource limits</li> </ol>"},{"location":"microservices/platform-architecture/#headers-and-metadata-transformation","title":"Headers and Metadata Transformation","text":"<ol> <li>Client to Akamai:</li> <li>Client headers preserved</li> <li>Addition of request ID headers</li> <li> <p>Security headers validation</p> </li> <li> <p>Akamai to Ingress:</p> </li> <li>True-Client-IP headers added</li> <li>Client certificates translated to headers if used</li> <li> <p>Custom security headers added</p> </li> <li> <p>Ingress to Service:</p> </li> <li>Request transformation based on annotations</li> <li>Path rewriting if configured</li> <li> <p>Additional application headers</p> </li> <li> <p>Service to Pod:</p> </li> <li>Kubernetes service information</li> <li>Load balancer source preservation</li> <li> <p>Original request metadata</p> </li> <li> <p>Response Path:</p> </li> <li>Response headers added at each layer</li> <li>CORS headers managed</li> <li>Security headers enforced</li> <li>Cache control headers processed</li> </ol>"},{"location":"microservices/platform-architecture/#authentication-and-authorization-enforcement","title":"Authentication and Authorization Enforcement","text":"<ol> <li>Edge Authentication (Akamai):</li> <li>API key validation</li> <li>OAuth token pre-validation</li> <li>JWT signature verification</li> <li> <p>Basic request authentication</p> </li> <li> <p>Ingress Authentication:</p> </li> <li>External authentication service integration</li> <li> <p>API gateway token validation</p> </li> <li> <p>Service-level Authentication:</p> </li> <li>Service account tokens</li> <li> <p>Internal service authentication</p> </li> <li> <p>Application Authentication:</p> </li> <li>Detailed token validation</li> <li>Authorization policy enforcement</li> <li>Role-based access control</li> <li>Multi-tenancy enforcement</li> </ol>"},{"location":"microservices/platform-architecture/#performance-considerations-and-bottlenecks","title":"Performance Considerations and Bottlenecks","text":"<ol> <li>Edge Performance:</li> <li>Global Akamai distribution</li> <li>Edge caching for appropriate responses</li> <li>Connection keep-alive</li> <li> <p>Content compression</p> </li> <li> <p>Ingress Controller Performance:</p> </li> <li>Controller scaling and redundancy</li> <li>Efficient routing algorithms</li> <li>Connection pooling</li> <li> <p>Worker process optimization</p> </li> <li> <p>Service Routing Performance:</p> </li> <li>Efficient service discovery</li> <li>Optimized iptables rules</li> <li>Kernel parameter tuning</li> <li> <p>IPVS mode for kube-proxy</p> </li> <li> <p>Pod Performance:</p> </li> <li>Proper resource allocation</li> <li>Horizontal scaling capability</li> <li>Efficient container images</li> <li>JVM/runtime optimization</li> </ol>"},{"location":"microservices/platform-architecture/#common-failure-points-and-resilience-strategies","title":"Common Failure Points and Resilience Strategies","text":"<ol> <li>Edge Failures:</li> <li>Multiple edge regions</li> <li>Failover configurations</li> <li>Health-based routing</li> <li> <p>Origin shields</p> </li> <li> <p>Ingress Controller Failures:</p> </li> <li>Controller redundancy</li> <li>Anti-affinity scheduling</li> <li>Failover configurations</li> <li> <p>Health-based removal</p> </li> <li> <p>Service Discovery Failures:</p> </li> <li>DNS caching strategies</li> <li>Short TTLs for critical services</li> <li>Direct endpoint access fallback</li> <li> <p>Headless services when appropriate</p> </li> <li> <p>Pod Failures:</p> </li> <li>Readiness/liveness probes</li> <li>Graceful shutdown handling</li> <li>PodDisruptionBudgets</li> <li>Topology spread constraints</li> <li> <p>Horizontal Pod Autoscaling</p> </li> <li> <p>Backend Service Failures:</p> </li> <li>Circuit breaking</li> <li>Retry budgets</li> <li>Fallback responses</li> <li>Cache-based resilience</li> </ol>"},{"location":"microservices/platform-architecture/#best-practices-and-recommendations","title":"Best Practices and Recommendations","text":""},{"location":"microservices/platform-architecture/#certificate-management","title":"Certificate Management","text":"<ol> <li>Automated Lifecycle:</li> <li>Use cert-manager for Kubernetes certificates</li> <li>Implement automated renewal processes</li> <li>Monitor certificate expiration</li> <li> <p>Maintain certificate inventory</p> </li> <li> <p>Security Best Practices:</p> </li> <li>Use appropriate key lengths (RSA 2048+, ECC P-256+)</li> <li>Maintain secure private key storage</li> <li>Implement certificate pinning for critical services</li> <li> <p>Regularly rotate certificates</p> </li> <li> <p>Operational Recommendations:</p> </li> <li>Standardize on preferred CAs</li> <li>Document emergency certificate procedures</li> <li>Perform regular rotation drills</li> <li>Maintain certificate hierarchy diagram</li> </ol>"},{"location":"microservices/platform-architecture/#security-hardening","title":"Security Hardening","text":"<ol> <li>Infrastructure Security:</li> <li>Keep Kubernetes version updated</li> <li>Apply security patches promptly</li> <li>Implement cluster hardening guidelines</li> <li>Use private networks where possible</li> <li> <p>Enforce least privilege principles</p> </li> <li> <p>Application Security:</p> </li> <li>Implement container security scanning</li> <li>Use distroless or minimal base images</li> <li>Perform regular vulnerability scanning</li> <li> <p>Implement runtime threat detection</p> </li> <li> <p>Network Security:</p> </li> <li>Default-deny network policies</li> <li>Implement microsegmentation</li> <li>Encrypt all traffic (east-west and north-south)</li> <li>Protect pod-to-pod communication</li> </ol>"},{"location":"microservices/platform-architecture/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Edge Optimization:</li> <li>Configure appropriate caching rules</li> <li>Implement content compression</li> <li>Use edge computing for simple transformations</li> <li> <p>Configure connection pooling</p> </li> <li> <p>Kubernetes Optimization:</p> </li> <li>Right-size pod resources</li> <li>Implement horizontal pod autoscaling</li> <li>Configure pod disruption budgets</li> <li>Optimize etcd performance</li> <li> <p>Use node anti-affinity for critical services</p> </li> <li> <p>Application Optimization:</p> </li> <li>Optimize container images</li> <li>Implement efficient API designs</li> <li>Use appropriate database indexes</li> <li>Optimize JVM settings for Java applications</li> <li>Implement response compression</li> </ol>"},{"location":"microservices/platform-architecture/#monitoring-and-observability","title":"Monitoring and Observability","text":"<ol> <li>Infrastructure Monitoring:</li> <li>Kubernetes cluster monitoring</li> <li>Node and pod metrics</li> <li>Network traffic analysis</li> <li> <p>Certificate expiration monitoring</p> </li> <li> <p>Application Monitoring:</p> </li> <li>Request/response metrics</li> <li>Latency tracking</li> <li>Error rate monitoring</li> <li> <p>Dependency health checks</p> </li> <li> <p>Request Tracing:</p> </li> <li>Implement distributed tracing</li> <li>Maintain request IDs throughout the chain</li> <li>Trace context propagation</li> <li> <p>Service dependency mapping</p> </li> <li> <p>Logging Strategy:</p> </li> <li>Structured logging</li> <li>Centralized log aggregation</li> <li>Log level management</li> <li> <p>Audit logging for security events</p> </li> <li> <p>Alerting and Dashboards:</p> </li> <li>SLO-based alerting</li> <li>Multi-level alerting strategy</li> <li>Custom dashboards for different user roles</li> <li>Automated runbooks for common issues</li> </ol>"},{"location":"microservices/platform-architecture/#references","title":"References","text":"<ul> <li>Kubernetes Documentation - Ingress</li> <li>NGINX Ingress Controller Documentation</li> <li>Akamai Security Best Practices</li> <li>cert-manager Documentation</li> <li>CNCF Cloud Native Security Whitepaper</li> <li>Kubernetes Network Policies</li> <li>TLS Best Practices </li> </ul>"},{"location":"microservices/saga-pattern/","title":"Saga Pattern in Microservices","text":""},{"location":"microservices/saga-pattern/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>What is the Saga Pattern?</li> <li>Types of Saga Implementations</li> <li>When to Use Saga Pattern</li> <li>Example: Fintech E-commerce Payment Gateway</li> <li>Benefits and Challenges</li> <li>Best Practices</li> <li>References</li> </ul>"},{"location":"microservices/saga-pattern/#introduction","title":"Introduction","text":"<p>In a microservices architecture, business transactions often span multiple services. Each service manages its own database, and local transactions ensure consistency within that service. However, implementing business transactions that span multiple services requires special handling. The Saga pattern is a microservices design pattern specifically created to manage distributed transactions while maintaining data consistency across services without tight coupling.</p>"},{"location":"microservices/saga-pattern/#what-is-the-saga-pattern","title":"What is the Saga Pattern?","text":"<p>A Saga is a sequence of local transactions where each transaction updates data within a single service. The completion of each local transaction triggers the next transaction in the sequence. If a transaction fails, the saga executes compensating transactions that undo the changes made by the preceding transactions.</p> <p>Key characteristics of the Saga pattern: - It breaks a distributed transaction into multiple local transactions - Each local transaction has a compensating transaction for rollback - Maintains eventual consistency rather than immediate consistency - Ensures each service's autonomy by avoiding distributed locks</p>"},{"location":"microservices/saga-pattern/#types-of-saga-implementations","title":"Types of Saga Implementations","text":""},{"location":"microservices/saga-pattern/#choreography-based-saga","title":"Choreography-based Saga","text":"<p>In a choreography-based saga, participants exchange events without a centralized coordinator. Each service publishes domain events that trigger other services to perform local transactions.</p> <p>Characteristics: - Decentralized decision making - Services reactively perform transactions based on events they receive - Simple implementation for smaller systems - More challenging to monitor and debug as system complexity grows</p>"},{"location":"microservices/saga-pattern/#orchestration-based-saga","title":"Orchestration-based Saga","text":"<p>In an orchestration-based saga, a central orchestrator (coordinator) directs participants and manages the sequence of transactions. The orchestrator tells each participant what local transaction to execute.</p> <p>Characteristics: - Centralized coordination - Clear centralized view of the saga execution - Easier to implement complex transaction flows - Potentially creates a single point of failure</p>"},{"location":"microservices/saga-pattern/#when-to-use-saga-pattern","title":"When to Use Saga Pattern","text":"<p>Consider using the Saga pattern when: - Transactions span multiple services - You need to maintain data consistency across several microservices - Long-running business processes need to be implemented - You want to avoid distributed two-phase commits - Services use separate databases and data stores</p>"},{"location":"microservices/saga-pattern/#example-fintech-e-commerce-payment-gateway","title":"Example: Fintech E-commerce Payment Gateway","text":"<p>Below is a flow diagram of a Saga pattern implementation for an e-commerce payment gateway system. This implementation uses the orchestration approach, where a Payment Orchestrator service coordinates the entire payment process.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                    E-commerce Payment Gateway - Saga Pattern                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                           \u2502  Customer   \u2502\n                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                  \u2502\n                                  \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                                                                \u2502\n\u2502                                        Payment Orchestrator Service                                            \u2502\n\u2502                                                                                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                    \u2502                       \u2502                    \u2502                    \u2502\n             \u25bc                    \u25bc                       \u25bc                    \u25bc                    \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Order Service \u2502   \u2502 Payment Service\u2502     \u2502   Fraud Check  \u2502   \u2502 Account Service\u2502   \u2502Notification Svc\u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                    \u2502                      \u2502                    \u2502                    \u2502\n             \u2502                    \u2502                      \u2502                    \u2502                    \u2502\n             \u25bc                    \u25bc                      \u25bc                    \u25bc                    \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   Order DB     \u2502   \u2502   Payment DB   \u2502     \u2502    Fraud DB    \u2502   \u2502   Account DB   \u2502   \u2502 Notification DB\u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"microservices/saga-pattern/#transaction-flow","title":"Transaction Flow","text":"<ol> <li>Payment Initiation</li> <li>Customer initiates a payment in the e-commerce system</li> <li>Order Service validates the order and reserves inventory</li> <li> <p>Payment Orchestrator begins the saga</p> </li> <li> <p>Fraud Check</p> </li> <li>Orchestrator requests fraud analysis of the transaction</li> <li>Fraud Check Service analyzes the transaction patterns</li> <li> <p>If suspicious patterns found, saga initiates compensation</p> </li> <li> <p>Account Verification</p> </li> <li>Orchestrator requests account service to verify customer account</li> <li>Account Service checks if account exists and is in good standing</li> <li> <p>If verification fails, saga initiates compensation</p> </li> <li> <p>Payment Processing</p> </li> <li>Orchestrator requests Payment Service to process the payment</li> <li>Payment Service communicates with external payment gateway</li> <li> <p>If payment fails, saga initiates compensation</p> </li> <li> <p>Order Confirmation</p> </li> <li>Orchestrator requests Order Service to confirm the order</li> <li>Order Service confirms inventory and finalizes the order</li> <li> <p>Order status is updated</p> </li> <li> <p>Notification</p> </li> <li>Orchestrator requests Notification Service</li> <li>Notification Service sends confirmation to customer</li> </ol>"},{"location":"microservices/saga-pattern/#compensation-flow-diagram","title":"Compensation Flow Diagram","text":"<p>If any step fails, the orchestrator executes a compensation process:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Payment Gateway - Compensation Flow (Failure in Payment)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    \u2502      \u2502                    \u2502      \u2502                    \u2502      \u2502                    \u2502\n\u2502   Order Service    \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2524 Payment Orchestrator\u25c4\u2500\u2500\u2500\u2500\u2500\u2524  Payment Service   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2524External Payment GW \u2502\n\u2502                    \u2502      \u2502                    \u2502      \u2502                    \u2502      \u2502                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n                                      \u25bc\n                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502                    \u2502\n                            \u2502  Fraud Check Svc   \u2502\n                            \u2502                    \u2502\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n                                      \u25bc\n                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502                    \u2502      \u2502                    \u2502\n                            \u2502Notification Service\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502     Customer       \u2502\n                            \u2502                    \u2502      \u2502                    \u2502\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCompensation Steps:\n1. Payment Gateway rejects transaction\n2. Payment Service reports failure to Orchestrator\n3. Orchestrator initiates compensation\n4. Order Service rollback - release inventory\n5. Fraud Check Service records transaction attempt\n6. Notification Service informs customer of failed transaction\n</code></pre>"},{"location":"microservices/saga-pattern/#benefits-and-challenges","title":"Benefits and Challenges","text":""},{"location":"microservices/saga-pattern/#benefits","title":"Benefits","text":"<ul> <li>Maintains data consistency across services</li> <li>Preserves service autonomy</li> <li>Supports long-running transactions</li> <li>Enables complex business processes spanning multiple services</li> <li>No need for distributed locks or two-phase commits</li> </ul>"},{"location":"microservices/saga-pattern/#challenges","title":"Challenges","text":"<ul> <li>Complexity in design and implementation</li> <li>Difficult to debug</li> <li>Eventual consistency instead of immediate consistency</li> <li>Must design compensating transactions carefully</li> <li>Requires handling potential failures in the compensation process</li> </ul>"},{"location":"microservices/saga-pattern/#best-practices","title":"Best Practices","text":"<ol> <li>Idempotent Operations: Ensure all transactions and compensations are idempotent</li> <li>Stateless Design: Design services to be stateless where possible</li> <li>Timeout Handling: Implement proper timeout handling for each service</li> <li>Retry Mechanism: Implement retry mechanisms for transient failures</li> <li>Monitoring &amp; Alerting: Implement comprehensive monitoring of saga execution</li> <li>Saga Log: Maintain a saga log to track progress and enable recovery</li> <li>Avoid Cyclic Dependencies: Design sagas to avoid circular dependencies</li> <li>Asynchronous Communication: Use asynchronous communication when possible</li> <li>Transaction ID: Include a transaction ID in all communications to track the saga</li> </ol>"},{"location":"microservices/saga-pattern/#references","title":"References","text":"<ul> <li>\"Microservices Patterns\" by Chris Richardson</li> <li>\"Enterprise Integration Patterns\" by Gregor Hohpe &amp; Bobby Woolf</li> <li>Microsoft - Saga Distributed Transactions Pattern</li> <li>IBM - Implementing the Saga Pattern </li> </ul>"},{"location":"spring-boot/spring-ai/","title":"Spring AI","text":""},{"location":"spring-boot/spring-ai/#overview","title":"Overview","text":"<p>Spring AI is a project within the Spring ecosystem that simplifies the integration of AI capabilities into Spring applications. It provides abstractions and integrations for various AI models, services, and tools, making it easier for Spring developers to incorporate AI functionality into their applications without deep AI expertise. This guide covers the fundamentals of Spring AI, its integration with different AI providers, and practical examples of using AI in Spring Boot applications.</p>"},{"location":"spring-boot/spring-ai/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Spring Boot</li> <li>Understanding of Java and RESTful API concepts</li> <li>Familiarity with AI/ML concepts (helpful but not required)</li> <li>Spring Boot application setup experience</li> </ul>"},{"location":"spring-boot/spring-ai/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the Spring AI project and its components</li> <li>Set up Spring AI in a Spring Boot application</li> <li>Work with different AI model providers through Spring AI</li> <li>Implement common AI use cases with Spring AI</li> <li>Build AI-powered features in Spring applications</li> <li>Handle AI responses and errors appropriately</li> <li>Optimize and monitor AI integrations</li> </ul>"},{"location":"spring-boot/spring-ai/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Spring AI</li> <li>Getting Started with Spring AI</li> <li>Working with LLMs in Spring</li> <li>Text Embedding and Vector Databases</li> <li>Image Generation</li> <li>Document Processing</li> <li>AI-Powered Web Applications</li> <li>Prompt Engineering in Spring AI</li> <li>Error Handling and Resiliency</li> <li>Performance Considerations</li> <li>Best Practices</li> </ol>"},{"location":"spring-boot/spring-ai/#introduction-to-spring-ai","title":"Introduction to Spring AI","text":"<p>Spring AI is designed to simplify the integration of AI capabilities into Spring applications by providing consistent abstractions across different AI providers.</p>"},{"location":"spring-boot/spring-ai/#key-concepts","title":"Key Concepts","text":"<ul> <li>AI Models: Pre-trained algorithms that can perform specific tasks like text generation, classification, image generation, etc.</li> <li>Prompts: Input text that guides AI models to produce relevant outputs</li> <li>Completion: The output generated by an AI model in response to a prompt</li> <li>Embeddings: Numerical representations of text that capture semantic meaning</li> <li>Tokens: Units of text that AI models process (words, subwords, or characters)</li> </ul>"},{"location":"spring-boot/spring-ai/#spring-ai-architecture","title":"Spring AI Architecture","text":"<p>Spring AI follows a provider-based architecture:</p> <ul> <li>Core abstractions: Define common interfaces for AI functionality</li> <li>Provider implementations: Integrate with specific AI services (OpenAI, Azure, etc.)</li> <li>Middleware components: Handle cross-cutting concerns like caching, rate limiting, etc.</li> </ul>"},{"location":"spring-boot/spring-ai/#supported-ai-providers","title":"Supported AI Providers","text":"<p>Spring AI supports multiple AI providers:</p> <ul> <li>OpenAI (GPT models)</li> <li>Azure OpenAI</li> <li>Google AI (PaLM, Gemini)</li> <li>Amazon Bedrock</li> <li>Anthropic Claude</li> <li>Ollama (for local models)</li> <li>HuggingFace</li> <li>More providers are added regularly</li> </ul>"},{"location":"spring-boot/spring-ai/#getting-started-with-spring-ai","title":"Getting Started with Spring AI","text":""},{"location":"spring-boot/spring-ai/#setting-up-spring-ai","title":"Setting Up Spring AI","text":"<p>Add Spring AI dependencies to your Spring Boot project:</p> <pre><code>&lt;!-- Maven --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-ai-starter&lt;/artifactId&gt;\n    &lt;version&gt;0.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- Provider specific dependencies --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;0.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Or for Gradle:</p> <pre><code>implementation 'org.springframework.ai:spring-ai-starter:0.8.0'\nimplementation 'org.springframework.ai:spring-ai-openai-spring-boot-starter:0.8.0'\n</code></pre>"},{"location":"spring-boot/spring-ai/#configuration","title":"Configuration","text":"<p>Configure Spring AI in your <code>application.properties</code> or <code>application.yml</code>:</p> <pre><code># OpenAI configuration\nspring.ai.openai.api-key=${OPENAI_API_KEY}\nspring.ai.openai.model=gpt-4\nspring.ai.openai.temperature=0.7\nspring.ai.openai.max-tokens=500\n</code></pre> <p>For Azure OpenAI:</p> <pre><code>spring.ai.azure.openai.api-key=${AZURE_OPENAI_API_KEY}\nspring.ai.azure.openai.endpoint=${AZURE_OPENAI_ENDPOINT}\nspring.ai.azure.openai.deployment-name=${AZURE_OPENAI_DEPLOYMENT}\n</code></pre>"},{"location":"spring-boot/spring-ai/#basic-usage","title":"Basic Usage","text":"<p>A simple example of using Spring AI with OpenAI:</p> <pre><code>import org.springframework.ai.chat.ChatClient;\nimport org.springframework.ai.chat.prompt.Prompt;\nimport org.springframework.ai.chat.prompt.SystemPromptTemplate;\nimport org.springframework.ai.chat.prompt.UserPrompt;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class AiController {\n\n    private final ChatClient chatClient;\n\n    @Autowired\n    public AiController(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    @GetMapping(\"/chat\")\n    public String chat(@RequestParam String message) {\n        String systemPrompt = \"You are a helpful assistant. Provide concise responses.\";\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(systemPrompt).create(),\n            new UserPrompt(message)\n        );\n\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#working-with-llms-in-spring","title":"Working with LLMs in Spring","text":"<p>Large Language Models (LLMs) are the core AI models used for text generation and understanding.</p>"},{"location":"spring-boot/spring-ai/#chatclient-for-conversations","title":"ChatClient for Conversations","text":"<p>The <code>ChatClient</code> interface is the primary way to interact with LLMs:</p> <pre><code>@Service\npublic class ConversationService {\n\n    private final ChatClient chatClient;\n\n    public ConversationService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    public String generateResponse(String userMessage) {\n        Prompt prompt = new Prompt(new UserPrompt(userMessage));\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n\n    public String generateStructuredResponse(String userMessage) {\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(\"You are a helpful assistant. Format your response as JSON.\").create(),\n            new UserPrompt(userMessage)\n        );\n\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#working-with-multiple-messages","title":"Working with Multiple Messages","text":"<p>Build more complex conversations with multiple messages:</p> <pre><code>public String multiTurnConversation(List&lt;String&gt; conversation) {\n    List&lt;Message&gt; messages = new ArrayList&lt;&gt;();\n\n    // Add system message first\n    messages.add(new SystemPromptTemplate(\"You are a helpful assistant.\").create());\n\n    // Add conversation history\n    for (int i = 0; i &lt; conversation.size(); i++) {\n        if (i % 2 == 0) {\n            // User messages\n            messages.add(new UserPrompt(conversation.get(i)));\n        } else {\n            // Assistant messages\n            messages.add(new AssistantPrompt(conversation.get(i)));\n        }\n    }\n\n    Prompt prompt = new Prompt(messages);\n    return chatClient.call(prompt).getResult().getOutput().getContent();\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#streaming-responses","title":"Streaming Responses","text":"<p>For large responses, use streaming to improve user experience:</p> <pre><code>@GetMapping(value = \"/chat/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\npublic Flux&lt;String&gt; streamChat(@RequestParam String message) {\n    Prompt prompt = new Prompt(new UserPrompt(message));\n\n    return Flux.from(chatClient.stream(prompt))\n            .map(response -&gt; response.getOutput().getContent());\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#handling-structured-data","title":"Handling Structured Data","text":"<p>Extract structured data from LLM responses:</p> <pre><code>public ProductRecommendation getProductRecommendation(String userQuery) {\n    String systemPrompt = \"\"\"\n        You are a product recommendation system.\n        Analyze the user query and recommend a product.\n        Format your response in JSON with the following structure:\n        {\n            \"productName\": \"string\",\n            \"description\": \"string\",\n            \"price\": float,\n            \"relevanceScore\": float\n        }\n        \"\"\";\n\n    Prompt prompt = new Prompt(\n        new SystemPromptTemplate(systemPrompt).create(),\n        new UserPrompt(userQuery)\n    );\n\n    String response = chatClient.call(prompt).getResult().getOutput().getContent();\n\n    // Parse JSON to object using Jackson\n    ObjectMapper mapper = new ObjectMapper();\n    try {\n        return mapper.readValue(response, ProductRecommendation.class);\n    } catch (JsonProcessingException e) {\n        throw new RuntimeException(\"Failed to parse AI response\", e);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#text-embedding-and-vector-databases","title":"Text Embedding and Vector Databases","text":"<p>Text embeddings convert text into numerical vectors that capture semantic meaning, enabling similarity search and retrieval.</p>"},{"location":"spring-boot/spring-ai/#generating-embeddings","title":"Generating Embeddings","text":"<p>Use the <code>EmbeddingClient</code> to generate embeddings:</p> <pre><code>@Service\npublic class EmbeddingService {\n\n    private final EmbeddingClient embeddingClient;\n\n    public EmbeddingService(EmbeddingClient embeddingClient) {\n        this.embeddingClient = embeddingClient;\n    }\n\n    public List&lt;Float&gt; generateEmbedding(String text) {\n        EmbeddingResponse response = embeddingClient.embed(text);\n        return response.getEmbedding();\n    }\n\n    public List&lt;List&lt;Float&gt;&gt; batchEmbeddings(List&lt;String&gt; texts) {\n        EmbeddingResponse response = embeddingClient.embed(texts);\n        return response.getEmbeddings();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#integrating-with-vector-databases","title":"Integrating with Vector Databases","text":"<p>Spring AI supports various vector databases for storing and retrieving embeddings:</p>"},{"location":"spring-boot/spring-ai/#redis-as-a-vector-store","title":"Redis as a Vector Store","text":"<pre><code>@Configuration\npublic class VectorStoreConfig {\n\n    @Bean\n    public RedisVectorStore redisVectorStore(\n            RedisTemplate&lt;String, String&gt; redisTemplate,\n            EmbeddingClient embeddingClient) {\n\n        return new RedisVectorStore(redisTemplate, embeddingClient);\n    }\n}\n\n@Service\npublic class DocumentSearchService {\n\n    private final RedisVectorStore vectorStore;\n    private final EmbeddingClient embeddingClient;\n\n    public DocumentSearchService(RedisVectorStore vectorStore, EmbeddingClient embeddingClient) {\n        this.vectorStore = vectorStore;\n        this.embeddingClient = embeddingClient;\n    }\n\n    public void storeDocument(String id, String content) {\n        Document document = Document.from(content, Map.of(\"id\", id));\n        vectorStore.add(List.of(document));\n    }\n\n    public List&lt;Document&gt; searchSimilarDocuments(String query, int k) {\n        return vectorStore.similaritySearch(query, k);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#using-postgresql-with-pgvector","title":"Using PostgreSQL with pgvector","text":"<pre><code>@Configuration\npublic class PgVectorConfig {\n\n    @Bean\n    public DataSource dataSource() {\n        // Configure PostgreSQL datasource\n    }\n\n    @Bean\n    public PgVectorStore pgVectorStore(DataSource dataSource, EmbeddingClient embeddingClient) {\n        return new PgVectorStore(dataSource, embeddingClient);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#retrieval-augmented-generation-rag","title":"Retrieval Augmented Generation (RAG)","text":"<p>Combine document retrieval with LLM generation for knowledge-grounded responses:</p> <pre><code>@Service\npublic class RagService {\n\n    private final VectorStore vectorStore;\n    private final ChatClient chatClient;\n\n    public RagService(VectorStore vectorStore, ChatClient chatClient) {\n        this.vectorStore = vectorStore;\n        this.chatClient = chatClient;\n    }\n\n    public String answerWithContext(String question) {\n        // 1. Retrieve relevant documents\n        List&lt;Document&gt; relevantDocs = vectorStore.similaritySearch(question, 3);\n\n        // 2. Format documents as context\n        String context = relevantDocs.stream()\n                .map(Document::getContent)\n                .collect(Collectors.joining(\"\\n\\n\"));\n\n        // 3. Create prompt with context\n        String systemPrompt = \"\"\"\n            You are a helpful assistant. Answer the user's question using the provided context.\n            If the answer cannot be found in the context, say \"I don't have enough information.\"\n\n            Context:\n            %s\n            \"\"\".formatted(context);\n\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(systemPrompt).create(),\n            new UserPrompt(question)\n        );\n\n        // 4. Generate answer\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#image-generation","title":"Image Generation","text":"<p>Spring AI supports image generation capabilities through various providers.</p>"},{"location":"spring-boot/spring-ai/#generating-images-with-dall-e","title":"Generating Images with DALL-E","text":"<pre><code>@Service\npublic class ImageGenerationService {\n\n    private final OpenAiImageClient imageClient;\n\n    public ImageGenerationService(OpenAiImageClient imageClient) {\n        this.imageClient = imageClient;\n    }\n\n    public String generateImage(String prompt) {\n        ImageOptions options = ImageOptions.builder()\n                .withModel(\"dall-e-3\")\n                .withSize(\"1024x1024\")\n                .withQuality(\"standard\")\n                .build();\n\n        ImageResponse response = imageClient.generateImage(prompt, options);\n        return response.getResult().getUrl();\n    }\n\n    public void generateAndSaveImage(String prompt, String outputPath) throws IOException {\n        ImageResponse response = imageClient.generateImage(prompt);\n        String imageUrl = response.getResult().getUrl();\n\n        // Download and save image\n        URL url = new URL(imageUrl);\n        try (InputStream in = url.openStream();\n             FileOutputStream out = new FileOutputStream(outputPath)) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#image-variation-and-editing","title":"Image Variation and Editing","text":"<p>Some providers support image variations and editing:</p> <pre><code>public String createImageVariation(File baseImage) throws IOException {\n    ImageOptions options = ImageOptions.builder()\n            .withModel(\"dall-e-2\")\n            .withN(1)\n            .withSize(\"1024x1024\")\n            .build();\n\n    ImageResponse response = imageClient.createVariation(\n            new FileSystemResource(baseImage), options);\n    return response.getResult().getUrl();\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#document-processing","title":"Document Processing","text":"<p>Spring AI can help process and analyze documents with AI capabilities.</p>"},{"location":"spring-boot/spring-ai/#pdf-analysis-with-llms","title":"PDF Analysis with LLMs","text":"<pre><code>@Service\npublic class DocumentAnalysisService {\n\n    private final ChatClient chatClient;\n\n    public DocumentAnalysisService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    public String analyzePdf(MultipartFile pdfFile) throws IOException {\n        // 1. Extract text from PDF\n        String pdfText = extractTextFromPdf(pdfFile.getInputStream());\n\n        // 2. Generate analysis with LLM\n        String systemPrompt = \"\"\"\n            You are a document analysis assistant. Analyze the provided document and extract:\n            1. Key points\n            2. Main topics\n            3. Action items\n            4. Summary\n\n            Format your response in Markdown.\n            \"\"\";\n\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(systemPrompt).create(),\n            new UserPrompt(\"Here's the document: \" + pdfText)\n        );\n\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n\n    private String extractTextFromPdf(InputStream pdfStream) throws IOException {\n        // Use a PDF library like Apache PDFBox or PdfToText\n        // Example with PDFBox:\n        PDDocument document = PDDocument.load(pdfStream);\n        try {\n            PDFTextStripper stripper = new PDFTextStripper();\n            return stripper.getText(document);\n        } finally {\n            document.close();\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#document-question-answering","title":"Document Question Answering","text":"<pre><code>public String askQuestionAboutDocument(String documentText, String question) {\n    String systemPrompt = \"\"\"\n        You are an assistant that answers questions about documents.\n        Use only the information in the provided document to answer the question.\n        If the answer is not in the document, say \"I don't have that information.\"\n\n        Document:\n        %s\n        \"\"\".formatted(documentText);\n\n    Prompt prompt = new Prompt(\n        new SystemPromptTemplate(systemPrompt).create(),\n        new UserPrompt(question)\n    );\n\n    return chatClient.call(prompt).getResult().getOutput().getContent();\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#ai-powered-web-applications","title":"AI-Powered Web Applications","text":"<p>Integrating Spring AI into web applications creates powerful user experiences.</p>"},{"location":"spring-boot/spring-ai/#ai-powered-chat-interface","title":"AI-Powered Chat Interface","text":"<pre><code>@Controller\npublic class ChatController {\n\n    private final ChatClient chatClient;\n\n    public ChatController(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    @GetMapping(\"/chat-ui\")\n    public String chatPage() {\n        return \"chat\";\n    }\n\n    @MessageMapping(\"/chat\")\n    @SendTo(\"/topic/messages\")\n    public ChatMessage processMessage(UserMessage message) {\n        String userContent = message.getContent();\n\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(\"You are a helpful customer service assistant.\").create(),\n            new UserPrompt(userContent)\n        );\n\n        String response = chatClient.call(prompt).getResult().getOutput().getContent();\n\n        return new ChatMessage(\"assistant\", response);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#content-generation-for-websites","title":"Content Generation for Websites","text":"<pre><code>@Service\npublic class ContentGenerationService {\n\n    private final ChatClient chatClient;\n\n    public ContentGenerationService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    public String generateBlogPost(String topic, String keywords, int wordCount) {\n        String systemPrompt = \"\"\"\n            You are a professional content writer. Generate a blog post about the given topic.\n            Use the provided keywords naturally throughout the text.\n            The blog post should be approximately %d words.\n            Format the post in Markdown with appropriate headings, paragraphs, and bullet points.\n            \"\"\".formatted(wordCount);\n\n        String userPrompt = \"\"\"\n            Topic: %s\n            Keywords: %s\n            \"\"\".formatted(topic, keywords);\n\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(systemPrompt).create(),\n            new UserPrompt(userPrompt)\n        );\n\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n\n    public String generateMetaDescription(String content, int maxLength) {\n        String systemPrompt = \"\"\"\n            Generate an SEO-friendly meta description for the provided content.\n            The description should be engaging and under %d characters.\n            \"\"\".formatted(maxLength);\n\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(systemPrompt).create(),\n            new UserPrompt(\"Content: \" + content)\n        );\n\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#prompt-engineering-in-spring-ai","title":"Prompt Engineering in Spring AI","text":"<p>Effective prompt engineering is crucial for getting good results from AI models.</p>"},{"location":"spring-boot/spring-ai/#creating-effective-prompts","title":"Creating Effective Prompts","text":"<pre><code>@Service\npublic class PromptService {\n\n    public Prompt createStructuredPrompt(String task, Map&lt;String, Object&gt; parameters) {\n        String systemTemplate = \"\"\"\n            You are an AI assistant specialized in ${task}.\n            Follow these guidelines:\n            - Be concise and clear\n            - Focus only on the requested task\n            - Format your response as ${format}\n\n            Additional instructions: ${instructions}\n            \"\"\";\n\n        SystemPromptTemplate systemPrompt = new SystemPromptTemplate(systemTemplate);\n\n        return new Prompt(\n            systemPrompt.create(parameters),\n            new UserPrompt(parameters.get(\"userInput\").toString())\n        );\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#working-with-prompt-templates","title":"Working with Prompt Templates","text":"<pre><code>@Component\npublic class PromptTemplateService {\n\n    private final PromptTemplateEngine promptTemplateEngine;\n\n    public PromptTemplateService(PromptTemplateEngine promptTemplateEngine) {\n        this.promptTemplateEngine = promptTemplateEngine;\n    }\n\n    public String processTemplate(String template, Map&lt;String, Object&gt; variables) {\n        return promptTemplateEngine.process(template, variables);\n    }\n\n    public Prompt createPromptFromTemplate(String systemTemplate, \n                                          String userTemplate,\n                                          Map&lt;String, Object&gt; variables) {\n        Message systemMessage = new SystemPromptTemplate(systemTemplate)\n                .create(variables);\n\n        Message userMessage = new UserPromptTemplate(userTemplate)\n                .create(variables);\n\n        return new Prompt(List.of(systemMessage, userMessage));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#few-shot-learning-examples","title":"Few-Shot Learning Examples","text":"<pre><code>public Prompt createFewShotPrompt(String task, List&lt;Example&gt; examples, String userInput) {\n    StringBuilder fewShotExamples = new StringBuilder();\n\n    for (Example example : examples) {\n        fewShotExamples.append(\"Input: \").append(example.getInput()).append(\"\\n\");\n        fewShotExamples.append(\"Output: \").append(example.getOutput()).append(\"\\n\\n\");\n    }\n\n    String systemTemplate = \"\"\"\n        You are an assistant that helps with ${task}.\n        Here are some examples of how to respond:\n\n        ${examples}\n\n        Follow the same pattern for the user's input.\n        \"\"\";\n\n    Map&lt;String, Object&gt; variables = Map.of(\n        \"task\", task,\n        \"examples\", fewShotExamples.toString()\n    );\n\n    return new Prompt(\n        new SystemPromptTemplate(systemTemplate).create(variables),\n        new UserPrompt(userInput)\n    );\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#error-handling-and-resiliency","title":"Error Handling and Resiliency","text":"<p>Proper error handling is essential when working with external AI services.</p>"},{"location":"spring-boot/spring-ai/#handling-ai-service-errors","title":"Handling AI Service Errors","text":"<pre><code>@Service\npublic class ResilientAiService {\n\n    private final ChatClient chatClient;\n    private final Logger logger = LoggerFactory.getLogger(ResilientAiService.class);\n\n    public ResilientAiService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    public String generateContentWithRetry(String prompt) {\n        int maxRetries = 3;\n        int retryCount = 0;\n        long retryDelay = 1000; // 1 second\n\n        while (retryCount &lt; maxRetries) {\n            try {\n                return chatClient.call(new Prompt(new UserPrompt(prompt)))\n                        .getResult().getOutput().getContent();\n            } catch (RuntimeException e) {\n                retryCount++;\n                logger.warn(\"AI service call failed (attempt {}): {}\", retryCount, e.getMessage());\n\n                if (retryCount &gt;= maxRetries) {\n                    logger.error(\"Max retries reached for AI call\", e);\n                    throw new AiServiceException(\"Failed to generate content after multiple attempts\", e);\n                }\n\n                try {\n                    Thread.sleep(retryDelay * retryCount); // Exponential backoff\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                    throw new AiServiceException(\"Retry interrupted\", ie);\n                }\n            }\n        }\n\n        // This should never happen with the retry logic above\n        throw new IllegalStateException(\"Unexpected end of retry loop\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>@Configuration\npublic class ResiliencyConfig {\n\n    @Bean\n    public CircuitBreakerFactory circuitBreakerFactory() {\n        CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()\n                .failureRateThreshold(50)\n                .waitDurationInOpenState(Duration.ofSeconds(10))\n                .permittedNumberOfCallsInHalfOpenState(5)\n                .slidingWindowSize(10)\n                .slidingWindowType(CircuitBreakerConfig.SlidingWindowType.COUNT_BASED)\n                .build();\n\n        Map&lt;String, CircuitBreakerConfig&gt; configs = Map.of(\"aiService\", circuitBreakerConfig);\n\n        return new DefaultCircuitBreakerFactory(configs);\n    }\n}\n\n@Service\npublic class CircuitBreakerAiService {\n\n    private final ChatClient chatClient;\n    private final CircuitBreakerFactory circuitBreakerFactory;\n\n    public CircuitBreakerAiService(ChatClient chatClient, CircuitBreakerFactory circuitBreakerFactory) {\n        this.chatClient = chatClient;\n        this.circuitBreakerFactory = circuitBreakerFactory;\n    }\n\n    public String generateContent(String prompt) {\n        CircuitBreaker circuitBreaker = circuitBreakerFactory.create(\"aiService\");\n\n        return circuitBreaker.run(\n            () -&gt; chatClient.call(new Prompt(new UserPrompt(prompt)))\n                    .getResult().getOutput().getContent(),\n            throwable -&gt; getFallbackResponse(prompt, throwable)\n        );\n    }\n\n    private String getFallbackResponse(String prompt, Throwable throwable) {\n        return \"I'm unable to generate a response at this time. Please try again later.\";\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#performance-considerations","title":"Performance Considerations","text":"<p>Optimizing AI interactions improves application performance and reduces costs.</p>"},{"location":"spring-boot/spring-ai/#caching-responses","title":"Caching Responses","text":"<pre><code>@Configuration\n@EnableCaching\npublic class CacheConfig {\n\n    @Bean\n    public CacheManager cacheManager() {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        cacheManager.setCaches(List.of(\n            new ConcurrentMapCache(\"aiResponses\")\n        ));\n        return cacheManager;\n    }\n}\n\n@Service\npublic class CachedAiService {\n\n    private final ChatClient chatClient;\n\n    public CachedAiService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    @Cacheable(value = \"aiResponses\", key = \"#prompt.hashCode()\")\n    public String generateResponse(Prompt prompt) {\n        return chatClient.call(prompt).getResult().getOutput().getContent();\n    }\n\n    @CacheEvict(value = \"aiResponses\", allEntries = true)\n    public void clearCache() {\n        // Method to clear the cache\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#batching-requests","title":"Batching Requests","text":"<pre><code>@Service\npublic class BatchProcessingService {\n\n    private final EmbeddingClient embeddingClient;\n\n    public BatchProcessingService(EmbeddingClient embeddingClient) {\n        this.embeddingClient = embeddingClient;\n    }\n\n    public List&lt;List&lt;Float&gt;&gt; batchProcessDocuments(List&lt;String&gt; documents) {\n        // Process in batches of 20\n        int batchSize = 20;\n        List&lt;List&lt;Float&gt;&gt; allEmbeddings = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; documents.size(); i += batchSize) {\n            int end = Math.min(i + batchSize, documents.size());\n            List&lt;String&gt; batch = documents.subList(i, end);\n\n            EmbeddingResponse response = embeddingClient.embed(batch);\n            allEmbeddings.addAll(response.getEmbeddings());\n        }\n\n        return allEmbeddings;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#optimizing-token-usage","title":"Optimizing Token Usage","text":"<pre><code>@Service\npublic class TokenOptimizationService {\n\n    private final ChatClient chatClient;\n\n    public TokenOptimizationService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    public String summarizeWithTokenLimit(String text, int maxTokens) {\n        // First, check if we need to truncate the input\n        if (estimateTokens(text) &gt; 4000) { // Rough estimate for token limit\n            text = truncateText(text, 4000);\n        }\n\n        String systemPrompt = \"\"\"\n            Summarize the following text concisely.\n            Focus on the most important information.\n            \"\"\";\n\n        ChatOptions options = ChatOptions.builder()\n                .withMaxTokens(maxTokens)\n                .withTemperature(0.3f) // Lower temperature for more focused response\n                .build();\n\n        Prompt prompt = new Prompt(\n            new SystemPromptTemplate(systemPrompt).create(),\n            new UserPrompt(text)\n        );\n\n        return chatClient.call(prompt, options).getResult().getOutput().getContent();\n    }\n\n    private int estimateTokens(String text) {\n        // Simple estimation: ~4 characters per token\n        return text.length() / 4;\n    }\n\n    private String truncateText(String text, int tokenLimit) {\n        // Simple truncation strategy\n        int charLimit = tokenLimit * 4;\n        if (text.length() &lt;= charLimit) {\n            return text;\n        }\n        return text.substring(0, charLimit) + \"...\";\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#best-practices","title":"Best Practices","text":""},{"location":"spring-boot/spring-ai/#security-considerations","title":"Security Considerations","text":"<pre><code>@Configuration\npublic class AiSecurityConfig {\n\n    @Bean\n    public OpenAiChatClient openAiChatClient(\n            @Value(\"${spring.ai.openai.api-key}\") String apiKey) {\n\n        // Validate API key format\n        if (apiKey == null || !apiKey.startsWith(\"sk-\")) {\n            throw new IllegalArgumentException(\"Invalid OpenAI API key format\");\n        }\n\n        // Create client with security headers\n        return new OpenAiChatClient(OpenAiChatOptions.builder()\n                .withApiKey(apiKey)\n                .withModel(\"gpt-4\")\n                .build());\n    }\n\n    @Bean\n    public SecurityFilter aiSecurityFilter() {\n        return new SecurityFilter();\n    }\n}\n\n@Component\npublic class SecurityFilter {\n\n    public String sanitizeUserInput(String input) {\n        // Remove potentially harmful characters or sequences\n        return input.replaceAll(\"[&lt;&gt;]\", \"\")\n                   .replaceAll(\"javascript:\", \"\")\n                   .trim();\n    }\n\n    public boolean containsSensitiveInformation(String text) {\n        // Check for patterns that might indicate sensitive data\n        Pattern creditCardPattern = Pattern.compile(\"\\\\d{4}[- ]?\\\\d{4}[- ]?\\\\d{4}[- ]?\\\\d{4}\");\n        Pattern ssnPattern = Pattern.compile(\"\\\\d{3}[- ]?\\\\d{2}[- ]?\\\\d{4}\");\n\n        return creditCardPattern.matcher(text).find() || ssnPattern.matcher(text).find();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#cost-management","title":"Cost Management","text":"<pre><code>@Service\npublic class AiCostManagementService {\n\n    private final ChatClient chatClient;\n    private final AtomicLong tokenUsage = new AtomicLong(0);\n\n    public AiCostManagementService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n\n    public String generateResponse(String prompt, boolean isHighPriority) {\n        // Select model based on priority/complexity\n        String model = isHighPriority ? \"gpt-4\" : \"gpt-3.5-turbo\";\n\n        ChatOptions options = ChatOptions.builder()\n                .withModel(model)\n                .withMaxTokens(isHighPriority ? 500 : 250)\n                .build();\n\n        ChatResponse response = chatClient.call(\n            new Prompt(new UserPrompt(prompt)), \n            options\n        );\n\n        // Track usage\n        TokenUsage usage = response.getMetadata().getUsage();\n        tokenUsage.addAndGet(usage.getInputTokens() + usage.getOutputTokens());\n\n        return response.getResult().getOutput().getContent();\n    }\n\n    public long getTotalTokenUsage() {\n        return tokenUsage.get();\n    }\n\n    public double estimateCost() {\n        // Approximate cost calculation\n        // Rates might vary based on the model and provider\n        return tokenUsage.get() * 0.00002; // $0.02 per 1000 tokens\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#monitoring-ai-services","title":"Monitoring AI Services","text":"<pre><code>@Configuration\npublic class MonitoringConfig {\n\n    @Bean\n    public MeterRegistry meterRegistry() {\n        return new SimpleMeterRegistry();\n    }\n}\n\n@Service\npublic class MonitoredAiService {\n\n    private final ChatClient chatClient;\n    private final MeterRegistry meterRegistry;\n    private final Logger logger = LoggerFactory.getLogger(MonitoredAiService.class);\n\n    public MonitoredAiService(ChatClient chatClient, MeterRegistry meterRegistry) {\n        this.chatClient = chatClient;\n        this.meterRegistry = meterRegistry;\n    }\n\n    public String generateContent(String prompt) {\n        Timer.Sample sample = Timer.start(meterRegistry);\n\n        try {\n            ChatResponse response = chatClient.call(new Prompt(new UserPrompt(prompt)));\n\n            // Record metrics\n            TokenUsage usage = response.getMetadata().getUsage();\n            meterRegistry.counter(\"ai.tokens.input\").increment(usage.getInputTokens());\n            meterRegistry.counter(\"ai.tokens.output\").increment(usage.getOutputTokens());\n\n            String content = response.getResult().getOutput().getContent();\n            sample.stop(meterRegistry.timer(\"ai.request.duration\", \"model\", response.getMetadata().getModel()));\n\n            return content;\n        } catch (Exception e) {\n            meterRegistry.counter(\"ai.request.errors\").increment();\n            logger.error(\"AI request failed\", e);\n            throw e;\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#testing-ai-integrations","title":"Testing AI Integrations","text":"<pre><code>@SpringBootTest\nclass AiServiceTests {\n\n    @Autowired\n    private ChatClient chatClient;\n\n    @MockBean\n    private OpenAiApi openAiApi;\n\n    @Test\n    void shouldGenerateResponse() {\n        // Arrange\n        String expectedResponse = \"This is a mock response\";\n        ChatCompletion mockCompletion = new ChatCompletion();\n        mockCompletion.setChoices(List.of(\n            new ChatCompletionChoice(0, new ChatMessage(\"assistant\", expectedResponse), null)\n        ));\n        mockCompletion.setUsage(new TokenUsage(10, 5));\n\n        when(openAiApi.chatCompletion(any())).thenReturn(mockCompletion);\n\n        // Act\n        String response = chatClient.call(new Prompt(new UserPrompt(\"Test prompt\")))\n                .getResult().getOutput().getContent();\n\n        // Assert\n        assertEquals(expectedResponse, response);\n        verify(openAiApi).chatCompletion(any());\n    }\n\n    @Test\n    void shouldHandleApiError() {\n        // Arrange\n        when(openAiApi.chatCompletion(any())).thenThrow(new RuntimeException(\"API error\"));\n\n        // Act &amp; Assert\n        assertThrows(RuntimeException.class, () -&gt; {\n            chatClient.call(new Prompt(new UserPrompt(\"Test prompt\")));\n        });\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-ai/#summary","title":"Summary","text":"<p>Spring AI provides a powerful abstraction layer for integrating AI capabilities into Spring applications. Key benefits include:</p> <ul> <li>Consistent API across different AI providers</li> <li>Seamless integration with the Spring ecosystem</li> <li>Support for various AI models and capabilities</li> <li>Tools for text generation, embeddings, image generation, and more</li> <li>Built-in support for error handling and resiliency</li> </ul> <p>By following the practices outlined in this guide, you can effectively leverage AI to enhance your Spring applications while maintaining good performance, security, and cost management.</p>"},{"location":"spring-boot/spring-ai/#further-reading","title":"Further Reading","text":"<ul> <li>Spring AI Documentation</li> <li>Spring AI GitHub Repository</li> <li>Spring AI Samples</li> <li>Prompt Engineering Guide</li> <li>OpenAI Documentation</li> <li>Azure OpenAI Service Documentation </li> </ul>"},{"location":"spring-boot/spring-boot-actuator/","title":"Spring Boot Actuator","text":""},{"location":"spring-boot/spring-boot-actuator/#overview","title":"Overview","text":"<p>Spring Boot Actuator provides production-ready features for monitoring and managing your Spring Boot application. It includes various built-in endpoints, metrics collection, health checks, and auditing capabilities that help you gain insights into your running application. This guide will help you understand and implement Spring Boot Actuator effectively in your applications.</p>"},{"location":"spring-boot/spring-boot-actuator/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Spring Boot</li> <li>Understanding of RESTful web services</li> <li>Familiarity with application monitoring concepts</li> <li>Spring Boot application setup</li> </ul>"},{"location":"spring-boot/spring-boot-actuator/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Spring Boot Actuator and its capabilities</li> <li>Configure and secure Actuator endpoints</li> <li>Implement custom health indicators</li> <li>Create custom metrics and counters</li> <li>Integrate with monitoring systems</li> <li>Use Actuator for application management</li> <li>Implement auditing using Actuator</li> <li>Customize Actuator responses</li> <li>Create custom endpoints</li> </ul>"},{"location":"spring-boot/spring-boot-actuator/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Getting Started with Actuator</li> <li>Actuator Endpoints</li> <li>Health Indicators</li> <li>Metrics and Monitoring</li> <li>Customizing Actuator</li> <li>Security Considerations</li> <li>Integration with Monitoring Systems</li> <li>Creating Custom Endpoints</li> <li>Auditing with Actuator</li> <li>Best Practices</li> </ol>"},{"location":"spring-boot/spring-boot-actuator/#getting-started-with-actuator","title":"Getting Started with Actuator","text":""},{"location":"spring-boot/spring-boot-actuator/#adding-actuator-dependency","title":"Adding Actuator Dependency","text":"<p>To add Spring Boot Actuator to your project, include the following dependency:</p> <p>For Maven: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p>For Gradle: <pre><code>implementation 'org.springframework.boot:spring-boot-starter-actuator'\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#basic-configuration","title":"Basic Configuration","text":"<p>Once the dependency is added, Spring Boot automatically configures several endpoints. The base path for these endpoints is <code>/actuator</code> by default. You can customize this in your <code>application.properties</code> or <code>application.yml</code> file:</p> <pre><code># application.properties\nmanagement.endpoints.web.base-path=/management\n</code></pre> <p>Or in YAML: <pre><code># application.yml\nmanagement:\n  endpoints:\n    web:\n      base-path: /management\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#enabling-endpoints","title":"Enabling Endpoints","text":"<p>By default, most endpoints except <code>/health</code> are disabled for web access. You can enable all endpoints or specific ones:</p> <pre><code># Enable all endpoints\nmanagement.endpoints.web.exposure.include=*\n\n# Enable specific endpoints\nmanagement.endpoints.web.exposure.include=health,info,metrics\n\n# Exclude specific endpoints\nmanagement.endpoints.web.exposure.exclude=env,beans\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#basic-usage","title":"Basic Usage","text":"<p>After configuring Actuator, you can access the endpoints via HTTP. For example:</p> <ul> <li><code>http://localhost:8080/actuator</code> - Lists all available endpoints</li> <li><code>http://localhost:8080/actuator/health</code> - Shows application health information</li> <li><code>http://localhost:8080/actuator/info</code> - Displays application information</li> </ul>"},{"location":"spring-boot/spring-boot-actuator/#actuator-endpoints","title":"Actuator Endpoints","text":"<p>Spring Boot Actuator provides numerous built-in endpoints for different purposes:</p>"},{"location":"spring-boot/spring-boot-actuator/#core-endpoints","title":"Core Endpoints","text":"ID Description <code>health</code> Shows application health information <code>info</code> Displays arbitrary application info <code>metrics</code> Shows metrics information <code>env</code> Exposes environment properties <code>configprops</code> Displays @ConfigurationProperties <code>loggers</code> Shows and modifies logger configurations <code>beans</code> Displays all Spring beans in the application <code>mappings</code> Displays all @RequestMapping paths <code>conditions</code> Shows auto-configuration conditions <code>threaddump</code> Performs a thread dump <code>heapdump</code> Returns a heap dump file <code>shutdown</code> Allows the application to be gracefully shutdown (disabled by default) <code>scheduledtasks</code> Displays scheduled tasks <code>caches</code> Exposes available caches <code>flyway</code> Shows Flyway database migrations <code>liquibase</code> Shows Liquibase database migrations"},{"location":"spring-boot/spring-boot-actuator/#the-health-endpoint","title":"The Health Endpoint","text":"<p>The <code>/health</code> endpoint shows the application's health status. By default, it shows a simple UP or DOWN status, but you can configure it to show more details:</p> <pre><code># Show full health details\nmanagement.endpoint.health.show-details=always\n\n# Or only for authenticated users\nmanagement.endpoint.health.show-details=when-authorized\n</code></pre> <p>Example response with details: <pre><code>{\n  \"status\": \"UP\",\n  \"components\": {\n    \"diskSpace\": {\n      \"status\": \"UP\",\n      \"details\": {\n        \"total\": 499963170816,\n        \"free\": 91300069376,\n        \"threshold\": 10485760\n      }\n    },\n    \"db\": {\n      \"status\": \"UP\",\n      \"details\": {\n        \"database\": \"PostgreSQL\",\n        \"validationQuery\": \"isValid()\"\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#the-info-endpoint","title":"The Info Endpoint","text":"<p>The <code>/info</code> endpoint displays custom information about your application. You can configure it in properties:</p> <pre><code># Static information\ninfo.app.name=My Spring Application\ninfo.app.description=A sample Spring Boot application\ninfo.app.version=1.0.0\ninfo.team.name=Sample Team\ninfo.team.contact=team@example.com\n</code></pre> <p>You can also add dynamic information by implementing <code>InfoContributor</code>:</p> <pre><code>@Component\npublic class BuildInfoContributor implements InfoContributor {\n\n    @Override\n    public void contribute(Info.Builder builder) {\n        Map&lt;String, Object&gt; buildDetails = new HashMap&lt;&gt;();\n        buildDetails.put(\"buildTime\", LocalDateTime.now().toString());\n        buildDetails.put(\"buildNumber\", \"1234\");\n\n        builder.withDetail(\"build\", buildDetails);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#the-metrics-endpoint","title":"The Metrics Endpoint","text":"<p>The <code>/metrics</code> endpoint provides access to application metrics. You can see available metrics by accessing:</p> <pre><code>GET /actuator/metrics\n</code></pre> <p>And specific metrics by including the metric name:</p> <pre><code>GET /actuator/metrics/jvm.memory.used\n</code></pre> <p>Example response: <pre><code>{\n  \"name\": \"jvm.memory.used\",\n  \"description\": \"The amount of used memory\",\n  \"baseUnit\": \"bytes\",\n  \"measurements\": [\n    {\n      \"statistic\": \"VALUE\",\n      \"value\": 234234346\n    }\n  ],\n  \"availableTags\": [\n    {\n      \"tag\": \"area\",\n      \"values\": [\n        \"heap\",\n        \"nonheap\"\n      ]\n    }\n  ]\n}\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#the-env-endpoint","title":"The Env Endpoint","text":"<p>The <code>/env</code> endpoint exposes all environment properties, including configuration properties:</p> <pre><code>GET /actuator/env\n</code></pre> <p>You can also query specific properties:</p> <pre><code>GET /actuator/env/server.port\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#the-loggers-endpoint","title":"The Loggers Endpoint","text":"<p>The <code>/loggers</code> endpoint allows viewing and modifying logging levels at runtime:</p> <p>To view all loggers: <pre><code>GET /actuator/loggers\n</code></pre></p> <p>To view a specific logger: <pre><code>GET /actuator/loggers/org.springframework\n</code></pre></p> <p>To change a logging level (using POST): <pre><code>POST /actuator/loggers/org.springframework\nContent-Type: application/json\n\n{\n  \"configuredLevel\": \"DEBUG\"\n}\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#health-indicators","title":"Health Indicators","text":"<p>Health indicators report the health status of application components. Spring Boot includes several built-in health indicators.</p>"},{"location":"spring-boot/spring-boot-actuator/#built-in-health-indicators","title":"Built-in Health Indicators","text":"<ul> <li><code>DiskSpaceHealthIndicator</code>: Checks for low disk space</li> <li><code>DataSourceHealthIndicator</code>: Checks the connection to a database</li> <li><code>MongoHealthIndicator</code>: Checks MongoDB connection</li> <li><code>RedisHealthIndicator</code>: Checks Redis connection</li> <li><code>CassandraHealthIndicator</code>: Checks Cassandra connection</li> <li><code>ElasticsearchHealthIndicator</code>: Checks Elasticsearch connection</li> <li><code>InfluxDbHealthIndicator</code>: Checks InfluxDB connection</li> <li><code>RabbitHealthIndicator</code>: Checks RabbitMQ connection</li> <li><code>SolrHealthIndicator</code>: Checks Solr connection</li> </ul>"},{"location":"spring-boot/spring-boot-actuator/#creating-custom-health-indicators","title":"Creating Custom Health Indicators","text":"<p>You can create custom health indicators by implementing the <code>HealthIndicator</code> interface:</p> <pre><code>import org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomServiceHealthIndicator implements HealthIndicator {\n\n    private final CustomService customService;\n\n    public CustomServiceHealthIndicator(CustomService customService) {\n        this.customService = customService;\n    }\n\n    @Override\n    public Health health() {\n        try {\n            boolean serviceStatus = customService.isRunning();\n            if (serviceStatus) {\n                return Health.up()\n                        .withDetail(\"message\", \"Custom service is running\")\n                        .withDetail(\"timestamp\", System.currentTimeMillis())\n                        .build();\n            } else {\n                return Health.down()\n                        .withDetail(\"message\", \"Custom service is not running\")\n                        .withDetail(\"timestamp\", System.currentTimeMillis())\n                        .build();\n            }\n        } catch (Exception e) {\n            return Health.down(e)\n                    .withDetail(\"message\", \"Error checking custom service\")\n                    .withDetail(\"error\", e.getMessage())\n                    .build();\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#composite-health-indicators","title":"Composite Health Indicators","text":"<p>You can group related health indicators using <code>CompositeHealthContributor</code>:</p> <pre><code>import org.springframework.boot.actuate.health.CompositeHealthContributor;\nimport org.springframework.boot.actuate.health.HealthContributor;\nimport org.springframework.boot.actuate.health.NamedContributor;\nimport org.springframework.stereotype.Component;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n@Component\npublic class ExternalServicesHealthIndicator implements CompositeHealthContributor {\n\n    private final Map&lt;String, HealthContributor&gt; contributors = new HashMap&lt;&gt;();\n\n    public ExternalServicesHealthIndicator(\n            PaymentServiceHealthIndicator paymentService,\n            ShippingServiceHealthIndicator shippingService) {\n        contributors.put(\"payment\", paymentService);\n        contributors.put(\"shipping\", shippingService);\n    }\n\n    @Override\n    public HealthContributor getContributor(String name) {\n        return contributors.get(name);\n    }\n\n    @Override\n    public Iterator&lt;NamedContributor&lt;HealthContributor&gt;&gt; iterator() {\n        return contributors.entrySet().stream()\n                .map(entry -&gt; NamedContributor.of(entry.getKey(), entry.getValue()))\n                .iterator();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#health-groups","title":"Health Groups","text":"<p>You can also create health groups to organize indicators:</p> <pre><code>management.endpoint.health.group.readiness.include=db,redis,kafka\nmanagement.endpoint.health.group.liveness.include=diskSpace,ping\nmanagement.endpoint.health.group.custom.include=customService\nmanagement.endpoint.health.group.custom.show-details=always\n</code></pre> <p>These groups can be accessed at <code>/actuator/health/{group}</code>, such as <code>/actuator/health/readiness</code>.</p>"},{"location":"spring-boot/spring-boot-actuator/#metrics-and-monitoring","title":"Metrics and Monitoring","text":"<p>Spring Boot Actuator uses Micrometer to collect and expose metrics, which provides a vendor-neutral facade for many monitoring systems.</p>"},{"location":"spring-boot/spring-boot-actuator/#built-in-metrics","title":"Built-in Metrics","text":"<p>Spring Boot automatically records several metrics:</p> <ul> <li>JVM metrics: Memory, garbage collection, threads, classes</li> <li>CPU metrics</li> <li>File descriptor metrics</li> <li>Tomcat metrics (if using Tomcat)</li> <li>Log metrics</li> <li>Spring MVC metrics (request counts, timings)</li> <li>RestTemplate metrics</li> <li>Cache metrics</li> <li>DataSource metrics (connection pool, query times)</li> </ul>"},{"location":"spring-boot/spring-boot-actuator/#registering-custom-metrics","title":"Registering Custom Metrics","text":"<p>You can register custom metrics using the <code>MeterRegistry</code>:</p> <pre><code>import io.micrometer.core.instrument.Counter;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class OrderService {\n\n    private final Counter orderCounter;\n    private final Counter failedOrderCounter;\n\n    public OrderService(MeterRegistry registry) {\n        this.orderCounter = registry.counter(\"orders.created\", \"type\", \"order\");\n        this.failedOrderCounter = registry.counter(\"orders.failed\", \"type\", \"order\");\n    }\n\n    public void createOrder(Order order) {\n        try {\n            // Process order\n            orderCounter.increment();\n        } catch (Exception e) {\n            failedOrderCounter.increment();\n            throw e;\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#types-of-metrics","title":"Types of Metrics","text":"<p>Micrometer supports various metric types:</p>"},{"location":"spring-boot/spring-boot-actuator/#counter","title":"Counter","text":"<p>Measures a single incrementing value:</p> <pre><code>Counter counter = registry.counter(\"requests.count\", \"status\", \"success\");\ncounter.increment();\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#gauge","title":"Gauge","text":"<p>Measures a single fluctuating value:</p> <pre><code>List&lt;Order&gt; orders = new ArrayList&lt;&gt;();\nGauge.builder(\"orders.pending\", orders, List::size)\n    .description(\"Number of pending orders\")\n    .register(registry);\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#timer","title":"Timer","text":"<p>Measures the timing of a specific operation:</p> <pre><code>Timer timer = registry.timer(\"api.requests\", \"endpoint\", \"/users\");\n\ntimer.record(() -&gt; {\n    // Code to measure\n    processRequest();\n});\n\n// Or manually\nlong start = System.nanoTime();\ntry {\n    processRequest();\n} finally {\n    timer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#distribution-summary","title":"Distribution Summary","text":"<p>Similar to a timer but for measuring distributions of values that aren't time-based:</p> <pre><code>DistributionSummary summary = registry.summary(\"order.amount\");\nsummary.record(order.getAmount());\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#long-task-timer","title":"Long Task Timer","text":"<p>Measures time spent on long-running tasks:</p> <pre><code>LongTaskTimer longTaskTimer = registry.more().longTaskTimer(\"batch.job.duration\");\nLongTaskTimer.Sample sample = longTaskTimer.start();\ntry {\n    runBatchJob();\n} finally {\n    sample.stop();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#timed-annotation","title":"@Timed Annotation","text":"<p>You can use the <code>@Timed</code> annotation to time methods:</p> <pre><code>import io.micrometer.core.annotation.Timed;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class ProductService {\n\n    @Timed(value = \"product.search.time\", description = \"Time taken to search products\")\n    public List&lt;Product&gt; searchProducts(String query) {\n        // Search products\n        return results;\n    }\n}\n</code></pre> <p>To enable this, register a <code>TimedAspect</code>:</p> <pre><code>@Bean\npublic TimedAspect timedAspect(MeterRegistry registry) {\n    return new TimedAspect(registry);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#customizing-actuator","title":"Customizing Actuator","text":"<p>You can customize various aspects of Spring Boot Actuator.</p>"},{"location":"spring-boot/spring-boot-actuator/#customizing-response-formats","title":"Customizing Response Formats","text":"<p>By default, Actuator endpoints return JSON responses. You can customize the response format by implementing <code>HttpMessageConverter</code>:</p> <pre><code>@Configuration\npublic class ActuatorConfig {\n\n    @Bean\n    public HttpMessageConverter&lt;Object&gt; actuatorCustomMessageConverter() {\n        return new CustomMessageConverter();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#adding-custom-information-to-info-endpoint","title":"Adding Custom Information to Info Endpoint","text":"<p>You can implement <code>InfoContributor</code> to add custom information to the <code>/info</code> endpoint:</p> <pre><code>@Component\npublic class GitInfoContributor implements InfoContributor {\n\n    @Override\n    public void contribute(Info.Builder builder) {\n        Map&lt;String, Object&gt; gitInfo = new HashMap&lt;&gt;();\n        gitInfo.put(\"branch\", \"master\");\n        gitInfo.put(\"commit\", \"abc123\");\n        gitInfo.put(\"repository\", \"https://github.com/example/repo\");\n\n        builder.withDetail(\"git\", gitInfo);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#auto-configured-info-contributors","title":"Auto-configured Info Contributors","text":"<p>Spring Boot provides several auto-configured <code>InfoContributor</code> beans:</p> <ul> <li><code>EnvironmentInfoContributor</code>: Exposes properties from <code>info.*</code></li> <li><code>GitInfoContributor</code>: Exposes git information if a <code>git.properties</code> file is available</li> <li><code>BuildInfoContributor</code>: Exposes build information if a <code>META-INF/build-info.properties</code> file is available</li> </ul> <p>You can generate these files automatically:</p> <p>For Maven: <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;build-info&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n\n&lt;plugin&gt;\n    &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;\n&lt;/plugin&gt;\n</code></pre></p> <p>For Gradle: <pre><code>springBoot {\n    buildInfo()\n}\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#security-considerations","title":"Security Considerations","text":"<p>Actuator endpoints can expose sensitive information, so securing them is important.</p>"},{"location":"spring-boot/spring-boot-actuator/#securing-actuator-endpoints","title":"Securing Actuator Endpoints","text":"<p>To secure Actuator endpoints, add Spring Security:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure security for endpoints:</p> <pre><code>@Configuration\npublic class ActuatorSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .requestMatcher(EndpointRequest.toAnyEndpoint())\n            .authorizeRequests()\n                .requestMatchers(EndpointRequest.to(\"health\", \"info\")).permitAll()\n                .anyRequest().hasRole(\"ACTUATOR\")\n            .and()\n            .httpBasic();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#cors-configuration","title":"CORS Configuration","text":"<p>Configure CORS for Actuator endpoints:</p> <pre><code>management.endpoints.web.cors.allowed-origins=https://example.com\nmanagement.endpoints.web.cors.allowed-methods=GET,POST\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#using-different-port-for-actuator","title":"Using Different Port for Actuator","text":"<p>You can configure Actuator to use a different port, keeping it separate from your application:</p> <pre><code>management.server.port=8081\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#integration-with-monitoring-systems","title":"Integration with Monitoring Systems","text":"<p>Micrometer supports various monitoring systems through its registry implementations.</p>"},{"location":"spring-boot/spring-boot-actuator/#prometheus","title":"Prometheus","text":"<p>To export metrics to Prometheus:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Prometheus scrapes metrics from the <code>/actuator/prometheus</code> endpoint.</p> <p>Prometheus configuration: <pre><code>scrape_configs:\n  - job_name: 'spring-boot-app'\n    metrics_path: '/actuator/prometheus'\n    static_configs:\n      - targets: ['localhost:8080']\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#datadog","title":"Datadog","text":"<p>For Datadog integration:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-datadog&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure the Datadog API key: <pre><code>management.metrics.export.datadog.api-key=YOUR_API_KEY\nmanagement.metrics.export.datadog.step=30s\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#new-relic","title":"New Relic","text":"<p>For New Relic integration:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-new-relic&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure New Relic: <pre><code>management.metrics.export.newrelic.api-key=YOUR_API_KEY\nmanagement.metrics.export.newrelic.account-id=YOUR_ACCOUNT_ID\nmanagement.metrics.export.newrelic.step=30s\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#graphite","title":"Graphite","text":"<p>For Graphite integration:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-graphite&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure Graphite: <pre><code>management.metrics.export.graphite.host=localhost\nmanagement.metrics.export.graphite.port=2004\nmanagement.metrics.export.graphite.step=30s\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#elastic","title":"Elastic","text":"<p>For Elasticsearch integration:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-elastic&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure Elasticsearch: <pre><code>management.metrics.export.elastic.host=http://localhost:9200\nmanagement.metrics.export.elastic.step=30s\n</code></pre></p>"},{"location":"spring-boot/spring-boot-actuator/#creating-custom-endpoints","title":"Creating Custom Endpoints","text":"<p>You can create custom Actuator endpoints for specific monitoring or management needs.</p>"},{"location":"spring-boot/spring-boot-actuator/#creating-a-read-only-endpoint","title":"Creating a Read-Only Endpoint","text":"<pre><code>import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\nimport org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\nimport org.springframework.stereotype.Component;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Component\n@Endpoint(id = \"features\")\npublic class FeaturesEndpoint {\n\n    @ReadOperation\n    public Map&lt;String, Object&gt; features() {\n        Map&lt;String, Object&gt; features = new HashMap&lt;&gt;();\n        features.put(\"payment\", true);\n        features.put(\"reporting\", true);\n        features.put(\"notifications\", false);\n        features.put(\"socialLogin\", Map.of(\n            \"facebook\", true,\n            \"google\", true,\n            \"github\", false\n        ));\n\n        return features;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#creating-a-writeable-endpoint","title":"Creating a Writeable Endpoint","text":"<pre><code>import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\nimport org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\nimport org.springframework.boot.actuate.endpoint.annotation.WriteOperation;\nimport org.springframework.stereotype.Component;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n@Component\n@Endpoint(id = \"counter\")\npublic class CounterEndpoint {\n\n    private final AtomicInteger counter = new AtomicInteger(0);\n\n    @ReadOperation\n    public Map&lt;String, Object&gt; getCount() {\n        return Map.of(\"count\", counter.get());\n    }\n\n    @WriteOperation\n    public Map&lt;String, Object&gt; increment() {\n        return Map.of(\"count\", counter.incrementAndGet());\n    }\n\n    @WriteOperation\n    public Map&lt;String, Object&gt; incrementBy(int delta) {\n        return Map.of(\"count\", counter.addAndGet(delta));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#enabling-jmx","title":"Enabling JMX","text":"<p>By default, Spring Boot exposes endpoints over HTTP. To expose them over JMX:</p> <pre><code>management.endpoints.jmx.exposure.include=health,info,beans\n</code></pre> <p>Creating a JMX-specific endpoint:</p> <pre><code>import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\nimport org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\nimport org.springframework.jmx.export.annotation.ManagedOperation;\nimport org.springframework.jmx.export.annotation.ManagedResource;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Endpoint(id = \"jmxCustom\")\n@ManagedResource\npublic class JmxCustomEndpoint {\n\n    @ReadOperation\n    @ManagedOperation\n    public String getData() {\n        return \"Custom JMX data\";\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#auditing-with-actuator","title":"Auditing with Actuator","text":"<p>Spring Boot Actuator provides auditing capabilities through the AuditEventRepository.</p>"},{"location":"spring-boot/spring-boot-actuator/#basic-auditing","title":"Basic Auditing","text":"<p>To use auditing, you need an implementation of <code>AuditEventRepository</code>:</p> <pre><code>@Bean\npublic InMemoryAuditEventRepository auditEventRepository() {\n    return new InMemoryAuditEventRepository();\n}\n</code></pre> <p>For production, use a persistent implementation:</p> <pre><code>@Component\npublic class PersistentAuditEventRepository implements AuditEventRepository {\n\n    private final AuditEventDao auditEventDao;\n\n    public PersistentAuditEventRepository(AuditEventDao auditEventDao) {\n        this.auditEventDao = auditEventDao;\n    }\n\n    @Override\n    public void add(AuditEvent event) {\n        auditEventDao.save(convertToEntity(event));\n    }\n\n    @Override\n    public List&lt;AuditEvent&gt; find(String principal, Instant after, String type) {\n        // Implementation details\n    }\n\n    // Helper methods\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#publishing-audit-events","title":"Publishing Audit Events","text":"<p>You can publish audit events using the <code>ApplicationEventPublisher</code>:</p> <pre><code>@Service\npublic class UserService {\n\n    private final ApplicationEventPublisher publisher;\n\n    public UserService(ApplicationEventPublisher publisher) {\n        this.publisher = publisher;\n    }\n\n    public void login(String username, boolean success) {\n        Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();\n        data.put(\"success\", success);\n        data.put(\"ip\", getCurrentIp());\n\n        publisher.publishEvent(\n            new AuditApplicationEvent(username, \"LOGIN\", data)\n        );\n    }\n\n    // Other methods\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#accessing-audit-events","title":"Accessing Audit Events","text":"<p>Audit events are available through the <code>/actuator/auditevents</code> endpoint:</p> <pre><code>GET /actuator/auditevents\n</code></pre> <p>You can filter by principal, date, or type:</p> <pre><code>GET /actuator/auditevents?principal=admin&amp;after=2023-01-01T00:00:00Z&amp;type=LOGIN\n</code></pre>"},{"location":"spring-boot/spring-boot-actuator/#best-practices","title":"Best Practices","text":""},{"location":"spring-boot/spring-boot-actuator/#production-configuration","title":"Production Configuration","text":"<p>For production environments:</p> <ol> <li> <p>Disable unnecessary endpoints: <pre><code>management.endpoints.web.exposure.include=health,info,metrics,prometheus\n</code></pre></p> </li> <li> <p>Secure endpoints properly: <pre><code>management.endpoints.web.exposure.include=health,info,metrics\nmanagement.endpoint.health.show-details=when-authorized\n</code></pre></p> </li> <li> <p>Consider using a separate management port: <pre><code>management.server.port=8081\n</code></pre></p> </li> <li> <p>Set appropriate logging levels: <pre><code>logging.level.org.springframework.boot.actuate=WARN\n</code></pre></p> </li> </ol>"},{"location":"spring-boot/spring-boot-actuator/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Be mindful of endpoint overhead:</li> <li>The <code>/heapdump</code> endpoint can generate large responses</li> <li> <p><code>/threaddump</code> may impact performance temporarily</p> </li> <li> <p>For high-volume metrics, consider sampling: <pre><code>Timer timer = Timer.builder(\"request.timer\")\n    .publishPercentiles(0.5, 0.95, 0.99)\n    .publishPercentileHistogram()\n    .sla(Duration.ofMillis(100), Duration.ofMillis(500))\n    .minimumExpectedValue(Duration.ofMillis(1))\n    .maximumExpectedValue(Duration.ofSeconds(10))\n    .register(registry);\n</code></pre></p> </li> <li> <p>Adjust metric collection frequency: <pre><code>management.metrics.export.prometheus.step=30s\n</code></pre></p> </li> </ol>"},{"location":"spring-boot/spring-boot-actuator/#monitoring-strategy","title":"Monitoring Strategy","text":"<ol> <li>Implement a comprehensive health check strategy:</li> <li>Create custom health indicators for critical services</li> <li>Group health indicators for different aspects (db, services, etc.)</li> <li> <p>Configure appropriate detail levels</p> </li> <li> <p>Set up alerts based on metrics:</p> </li> <li>Critical error rates</li> <li>Slow response times</li> <li>Resource utilization (memory, CPU)</li> <li> <p>Business metrics (order rates, failed transactions)</p> </li> <li> <p>Implement proper logging integration:</p> </li> <li>Configure log levels through the <code>/loggers</code> endpoint</li> <li>Correlate logs with metrics</li> <li>Integrate with centralized logging systems</li> </ol>"},{"location":"spring-boot/spring-boot-actuator/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Always secure Actuator endpoints:</li> <li>Use HTTPS for all endpoints</li> <li>Require authentication for sensitive endpoints</li> <li> <p>Consider network-level security (firewall rules, VPC)</p> </li> <li> <p>Control information exposure:</p> </li> <li>Limit detailed health information to authenticated users</li> <li>Avoid exposing sensitive configuration through <code>/env</code></li> <li> <p>Regularly audit exposed endpoints</p> </li> <li> <p>Implement proper user management:</p> </li> <li>Create specific roles for Actuator access</li> <li>Use fine-grained permissions</li> <li>Audit access to endpoints</li> </ol>"},{"location":"spring-boot/spring-boot-actuator/#summary","title":"Summary","text":"<p>Spring Boot Actuator is a powerful tool for monitoring and managing your Spring Boot applications. It provides:</p> <ul> <li>Production-ready features like health checks, metrics, and environment information</li> <li>Integration with monitoring systems through Micrometer</li> <li>Extensibility through custom endpoints and health indicators</li> <li>Security controls to protect sensitive information</li> </ul> <p>By properly configuring and extending Actuator, you can gain valuable insights into your application's behavior, improve observability, and respond quickly to issues.</p>"},{"location":"spring-boot/spring-boot-actuator/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Actuator Documentation</li> <li>Micrometer Documentation</li> <li>Spring Boot Admin</li> <li>Prometheus Documentation</li> <li>Grafana Documentation </li> </ul>"},{"location":"spring-boot/spring-boot-aop/","title":"Spring Boot AOP (Aspect-Oriented Programming)","text":""},{"location":"spring-boot/spring-boot-aop/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to AOP</li> <li>Core Concepts</li> <li>AOP Annotations</li> <li>Pointcut Expressions</li> <li>Advice Types</li> <li>Common Use Cases</li> <li>Best Practices</li> </ol>"},{"location":"spring-boot/spring-boot-aop/#introduction","title":"Introduction","text":"<p>Aspect-Oriented Programming (AOP) complements Object-Oriented Programming (OOP) by providing another way of thinking about program structure. While OOP modularizes through classes, AOP modularizes cross-cutting concerns.</p>"},{"location":"spring-boot/spring-boot-aop/#dependencies","title":"Dependencies","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#enable-aop","title":"Enable AOP","text":"<pre><code>@Configuration\n@EnableAspectJAutoProxy\npublic class AopConfig {\n    // AOP Configuration\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#core-concepts","title":"Core Concepts","text":""},{"location":"spring-boot/spring-boot-aop/#1-aspect","title":"1. Aspect","text":"<p>A modularization of a concern that cuts across multiple classes.</p> <pre><code>@Aspect\n@Component\npublic class LoggingAspect {\n    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);\n\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void logBefore(JoinPoint joinPoint) {\n        logger.info(\"Before executing: \" + joinPoint.getSignature().getName());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#2-join-point","title":"2. Join Point","text":"<p>A point during the execution of a program, such as the execution of a method or handling of an exception.</p> <pre><code>@Aspect\n@Component\npublic class JoinPointDemoAspect {\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void demonstrateJoinPoint(JoinPoint joinPoint) {\n        // Method name\n        String methodName = joinPoint.getSignature().getName();\n\n        // Arguments\n        Object[] args = joinPoint.getArgs();\n\n        // Target class\n        String className = joinPoint.getTarget().getClass().getSimpleName();\n\n        System.out.println(\"Executing \" + className + \".\" + methodName);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#3-pointcut","title":"3. Pointcut","text":"<p>A predicate that matches join points.</p> <pre><code>@Aspect\n@Component\npublic class PointcutDemoAspect {\n    // Pointcut declaration\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceLayer() {}\n\n    // Reusing pointcut\n    @Before(\"serviceLayer()\")\n    public void beforeService() {\n        // Advice implementation\n    }\n\n    @After(\"serviceLayer()\")\n    public void afterService() {\n        // Advice implementation\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#aop-annotations","title":"AOP Annotations","text":""},{"location":"spring-boot/spring-boot-aop/#1-before","title":"1. @Before","text":"<pre><code>@Aspect\n@Component\npublic class BeforeAspect {\n    @Before(\"execution(* com.example.service.UserService.createUser(..))\")\n    public void beforeUserCreation(JoinPoint joinPoint) {\n        Object[] args = joinPoint.getArgs();\n        logger.info(\"About to create user with data: \" + Arrays.toString(args));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#2-after","title":"2. @After","text":"<pre><code>@Aspect\n@Component\npublic class AfterAspect {\n    @After(\"execution(* com.example.service.UserService.deleteUser(..))\")\n    public void afterUserDeletion(JoinPoint joinPoint) {\n        logger.info(\"User deletion completed\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#3-around","title":"3. @Around","text":"<pre><code>@Aspect\n@Component\npublic class AroundAspect {\n    @Around(\"execution(* com.example.service.*.*(..))\")\n    public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n\n        Object result = joinPoint.proceed();\n\n        long executionTime = System.currentTimeMillis() - start;\n        logger.info(joinPoint.getSignature() + \" executed in \" + executionTime + \"ms\");\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#4-afterreturning","title":"4. @AfterReturning","text":"<pre><code>@Aspect\n@Component\npublic class AfterReturningAspect {\n    @AfterReturning(\n        pointcut = \"execution(* com.example.service.UserService.findUser(..))\",\n        returning = \"result\"\n    )\n    public void afterReturningUser(JoinPoint joinPoint, Object result) {\n        logger.info(\"Found user: \" + result);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#5-afterthrowing","title":"5. @AfterThrowing","text":"<pre><code>@Aspect\n@Component\npublic class AfterThrowingAspect {\n    @AfterThrowing(\n        pointcut = \"execution(* com.example.service.*.*(..))\",\n        throwing = \"ex\"\n    )\n    public void afterThrowingException(JoinPoint joinPoint, Exception ex) {\n        logger.error(\"Method \" + joinPoint.getSignature() + \" threw exception: \" + ex.getMessage());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#pointcut-expressions","title":"Pointcut Expressions","text":""},{"location":"spring-boot/spring-boot-aop/#1-method-execution","title":"1. Method Execution","text":"<pre><code>@Aspect\n@Component\npublic class MethodExecutionAspect {\n    // Any public method\n    @Before(\"execution(public * *(..))\")\n    public void beforePublicMethod() {}\n\n    // Specific return type\n    @Before(\"execution(String com.example.service.*.*(..))\")\n    public void beforeStringReturn() {}\n\n    // Specific parameters\n    @Before(\"execution(* *.*(.., String))\")\n    public void beforeMethodWithStringParam() {}\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#2-within","title":"2. Within","text":"<pre><code>@Aspect\n@Component\npublic class WithinAspect {\n    // All methods in a package\n    @Before(\"within(com.example.service.*)\")\n    public void beforeServicePackage() {}\n\n    // All methods in a class\n    @Before(\"within(com.example.service.UserService)\")\n    public void beforeUserService() {}\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#3-bean","title":"3. Bean","text":"<pre><code>@Aspect\n@Component\npublic class BeanAspect {\n    // Specific bean\n    @Before(\"bean(userService)\")\n    public void beforeUserServiceBean() {}\n\n    // Bean pattern\n    @Before(\"bean(*Service)\")\n    public void beforeAnyServiceBean() {}\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#common-use-cases","title":"Common Use Cases","text":""},{"location":"spring-boot/spring-boot-aop/#1-logging-aspect","title":"1. Logging Aspect","text":"<pre><code>@Aspect\n@Component\npublic class LoggingAspect {\n    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);\n\n    @Around(\"execution(* com.example.service.*.*(..))\")\n    public Object logMethod(ProceedingJoinPoint joinPoint) throws Throwable {\n        String methodName = joinPoint.getSignature().getName();\n        String className = joinPoint.getTarget().getClass().getSimpleName();\n\n        logger.info(\"=&gt; Starting {} in {}\", methodName, className);\n\n        try {\n            Object result = joinPoint.proceed();\n            logger.info(\"&lt;= Completed {} in {}\", methodName, className);\n            return result;\n        } catch (Exception e) {\n            logger.error(\"!! Exception in {}.{}: {}\", className, methodName, e.getMessage());\n            throw e;\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#2-performance-monitoring","title":"2. Performance Monitoring","text":"<pre><code>@Aspect\n@Component\npublic class PerformanceAspect {\n    private static final Logger logger = LoggerFactory.getLogger(PerformanceAspect.class);\n\n    @Around(\"@annotation(Monitored)\")\n    public Object measurePerformance(ProceedingJoinPoint joinPoint) throws Throwable {\n        long startTime = System.nanoTime();\n\n        try {\n            return joinPoint.proceed();\n        } finally {\n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime) / 1_000_000; // Convert to milliseconds\n\n            logger.info(\"Method {} took {}ms to execute\",\n                joinPoint.getSignature().getName(), duration);\n        }\n    }\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Monitored {}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#3-security-aspect","title":"3. Security Aspect","text":"<pre><code>@Aspect\n@Component\npublic class SecurityAspect {\n    @Before(\"@annotation(secured)\")\n    public void checkSecurity(JoinPoint joinPoint, Secured secured) {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n\n        if (!hasRequiredRole(auth, secured.value())) {\n            throw new AccessDeniedException(\"Access denied\");\n        }\n    }\n\n    private boolean hasRequiredRole(Authentication auth, String[] roles) {\n        return Arrays.stream(roles)\n            .anyMatch(role -&gt; auth.getAuthorities().stream()\n                .anyMatch(a -&gt; a.getAuthority().equals(\"ROLE_\" + role)));\n    }\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Secured {\n    String[] value();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#4-caching-aspect","title":"4. Caching Aspect","text":"<pre><code>@Aspect\n@Component\npublic class CachingAspect {\n    private Map&lt;String, Object&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\n    @Around(\"@annotation(Cacheable)\")\n    public Object cache(ProceedingJoinPoint joinPoint) throws Throwable {\n        String key = generateKey(joinPoint);\n\n        if (cache.containsKey(key)) {\n            return cache.get(key);\n        }\n\n        Object result = joinPoint.proceed();\n        cache.put(key, result);\n        return result;\n    }\n\n    private String generateKey(JoinPoint joinPoint) {\n        return joinPoint.getSignature().toString() + \n               Arrays.toString(joinPoint.getArgs());\n    }\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Cacheable {}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#5-transaction-aspect","title":"5. Transaction Aspect","text":"<pre><code>@Aspect\n@Component\npublic class TransactionAspect {\n    @Autowired\n    private TransactionTemplate transactionTemplate;\n\n    @Around(\"@annotation(Transactional)\")\n    public Object handleTransaction(ProceedingJoinPoint joinPoint) throws Throwable {\n        return transactionTemplate.execute(status -&gt; {\n            try {\n                return joinPoint.proceed();\n            } catch (Throwable throwable) {\n                status.setRollbackOnly();\n                throw new RuntimeException(throwable);\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#best-practices","title":"Best Practices","text":""},{"location":"spring-boot/spring-boot-aop/#1-keep-aspects-focused","title":"1. Keep Aspects Focused","text":"<pre><code>@Aspect\n@Component\npublic class SingleResponsibilityAspect {\n    // Good: Single responsibility\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void logMethodEntry(JoinPoint joinPoint) {\n        // Only logging logic here\n    }\n\n    // Bad: Multiple responsibilities\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void doMultipleThings(JoinPoint joinPoint) {\n        // Logging\n        // Security checks\n        // Performance monitoring\n        // Cache management\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#2-use-custom-annotations","title":"2. Use Custom Annotations","text":"<pre><code>// Custom annotation\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Audited {\n    String value() default \"\";\n}\n\n// Aspect using custom annotation\n@Aspect\n@Component\npublic class AuditAspect {\n    @Before(\"@annotation(audited)\")\n    public void audit(JoinPoint joinPoint, Audited audited) {\n        // Audit logic\n    }\n}\n\n// Usage in service\n@Service\npublic class UserService {\n    @Audited(\"user-creation\")\n    public User createUser(UserDTO dto) {\n        // Implementation\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#3-handle-exceptions-properly","title":"3. Handle Exceptions Properly","text":"<pre><code>@Aspect\n@Component\npublic class ExceptionHandlingAspect {\n    @Around(\"execution(* com.example.service.*.*(..))\")\n    public Object handleExceptions(ProceedingJoinPoint joinPoint) throws Throwable {\n        try {\n            return joinPoint.proceed();\n        } catch (BusinessException e) {\n            // Handle business exceptions\n            throw e;\n        } catch (Exception e) {\n            // Handle unexpected exceptions\n            logger.error(\"Unexpected error\", e);\n            throw new SystemException(\"System error occurred\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#4-order-multiple-aspects","title":"4. Order Multiple Aspects","text":"<pre><code>@Aspect\n@Component\n@Order(1)\npublic class SecurityAspect {\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void checkSecurity() {\n        // Security checks\n    }\n}\n\n@Aspect\n@Component\n@Order(2)\npublic class LoggingAspect {\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void log() {\n        // Logging\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#testing-aspects","title":"Testing Aspects","text":"<pre><code>@SpringBootTest\npublic class LoggingAspectTest {\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void testLoggingAspect() {\n        // Given\n        UserDTO userDTO = new UserDTO(\"test@example.com\");\n\n        // When\n        User user = userService.createUser(userDTO);\n\n        // Then\n        // Verify logging occurred\n        // You might need to use a mock logger or capture logs\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-aop/#summary","title":"Summary","text":"<ul> <li>Use AOP for cross-cutting concerns</li> <li>Keep aspects focused and single-responsibility</li> <li>Use custom annotations for better readability</li> <li>Handle exceptions appropriately</li> <li>Order multiple aspects when needed</li> <li>Test aspects thoroughly</li> <li>Document aspect behavior and requirements </li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/","title":"Spring Boot Best Practices","text":""},{"location":"spring-boot/spring-boot-best-practices/#overview","title":"Overview","text":"<p>This guide compiles essential best practices for Spring Boot application development. It covers project architecture, security considerations, performance optimization, testing strategies, and deployment techniques. Following these practices will help you build robust, maintainable, and efficient Spring Boot applications.</p>"},{"location":"spring-boot/spring-boot-best-practices/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Spring Boot</li> <li>Understanding of Java development principles</li> <li>Familiarity with software development best practices</li> <li>Experience building Spring Boot applications</li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Implement proper application architecture</li> <li>Apply effective coding standards and patterns</li> <li>Secure Spring Boot applications properly</li> <li>Optimize application performance</li> <li>Write effective tests for Spring Boot applications</li> <li>Deploy applications following best practices</li> <li>Monitor and maintain applications in production</li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Project Structure and Architecture</li> <li>Coding Best Practices</li> <li>Configuration Management</li> <li>Security Best Practices</li> <li>Database Access and Data Management</li> <li>Performance Optimization</li> <li>Testing Strategies</li> <li>Deployment Considerations</li> <li>Monitoring and Maintenance</li> <li>Common Pitfalls to Avoid</li> </ol>"},{"location":"spring-boot/spring-boot-best-practices/#project-structure-and-architecture","title":"Project Structure and Architecture","text":""},{"location":"spring-boot/spring-boot-best-practices/#package-organization","title":"Package Organization","text":"<p>Structure your application using a domain-driven or feature-based approach rather than a technical layered approach:</p> <pre><code>com.example.myapp/\n\u251c\u2500\u2500 config/             # Global configuration\n\u251c\u2500\u2500 common/             # Shared utilities and components\n\u251c\u2500\u2500 security/           # Security configuration\n\u2514\u2500\u2500 feature/            # Feature-specific packages\n    \u251c\u2500\u2500 user/           # User-related functionality\n    \u2502   \u251c\u2500\u2500 controller/\n    \u2502   \u251c\u2500\u2500 service/\n    \u2502   \u251c\u2500\u2500 repository/\n    \u2502   \u2514\u2500\u2500 model/\n    \u2514\u2500\u2500 product/        # Product-related functionality\n        \u251c\u2500\u2500 controller/\n        \u251c\u2500\u2500 service/\n        \u251c\u2500\u2500 repository/\n        \u2514\u2500\u2500 model/\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#use-proper-layering","title":"Use Proper Layering","text":"<p>Follow a clear separation of concerns with proper layering:</p> <ul> <li>Controller Layer: Handles HTTP requests and responses</li> <li>Service Layer: Contains business logic</li> <li>Repository Layer: Manages data access</li> <li>Model Layer: Defines entities and DTOs</li> </ul> <pre><code>@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private final UserService userService;\n\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n\n    @GetMapping(\"/{id}\")\n    public UserDTO getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n}\n\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    private final UserMapper userMapper;\n\n    // Business logic methods\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    // Data access methods\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#modular-components","title":"Modular Components","text":"<p>Design with modularity in mind:</p> <ul> <li>Keep components focused on single responsibilities</li> <li>Use interfaces for abstractions</li> <li>Implement dependency injection</li> <li>Create reusable modules</li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/#avoid-circular-dependencies","title":"Avoid Circular Dependencies","text":"<p>Prevent circular dependencies to maintain clean architecture:</p> <ul> <li>Ensure one-way dependencies between layers</li> <li>Use interfaces and dependency inversion</li> <li>Reorganize components if necessary</li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/#coding-best-practices","title":"Coding Best Practices","text":""},{"location":"spring-boot/spring-boot-best-practices/#use-constructor-injection","title":"Use Constructor Injection","text":"<p>Prefer constructor injection over field injection:</p> <pre><code>// Good practice\n@Service\npublic class ProductService {\n    private final ProductRepository productRepository;\n    private final PriceCalculator priceCalculator;\n\n    public ProductService(ProductRepository productRepository, \n                          PriceCalculator priceCalculator) {\n        this.productRepository = productRepository;\n        this.priceCalculator = priceCalculator;\n    }\n}\n\n// Avoid\n@Service\npublic class ProductService {\n    @Autowired\n    private ProductRepository productRepository;\n\n    @Autowired\n    private PriceCalculator priceCalculator;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#use-immutable-objects","title":"Use Immutable Objects","text":"<p>Create immutable DTOs and value objects:</p> <pre><code>public final class UserDTO {\n    private final Long id;\n    private final String name;\n    private final String email;\n\n    public UserDTO(Long id, String name, String email) {\n        this.id = id;\n        this.name = name;\n        this.email = email;\n    }\n\n    // Only getters, no setters\n    public Long getId() { return id; }\n    public String getName() { return name; }\n    public String getEmail() { return email; }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#effective-error-handling","title":"Effective Error Handling","text":"<p>Implement consistent exception handling:</p> <pre><code>@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity&lt;ErrorResponse&gt; handleResourceNotFound(ResourceNotFoundException ex) {\n        logger.error(\"Resource not found: {}\", ex.getMessage());\n        return new ResponseEntity&lt;&gt;(new ErrorResponse(\"NOT_FOUND\", ex.getMessage()), \n                                    HttpStatus.NOT_FOUND);\n    }\n\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity&lt;ErrorResponse&gt; handleGenericException(Exception ex) {\n        logger.error(\"Unexpected error\", ex);\n        return new ResponseEntity&lt;&gt;(new ErrorResponse(\"INTERNAL_ERROR\", \n                                                     \"An unexpected error occurred\"), \n                                    HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#use-lombok-judiciously","title":"Use Lombok Judiciously","text":"<p>Lombok can reduce boilerplate but use it carefully:</p> <pre><code>@Data               // Provides getters, setters, equals, hashCode, toString\n@NoArgsConstructor  // Default constructor\n@AllArgsConstructor // Constructor with all attributes\npublic class Product {\n    private Long id;\n    private String name;\n    private BigDecimal price;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#follow-api-design-best-practices","title":"Follow API Design Best Practices","text":"<p>Create RESTful APIs that follow conventions:</p> <ul> <li>Use appropriate HTTP methods (GET, POST, PUT, DELETE)</li> <li>Return proper status codes</li> <li>Use consistent URL patterns</li> <li>Version your APIs (via URL or headers)</li> <li>Provide comprehensive documentation with Swagger/OpenAPI</li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/#configuration-management","title":"Configuration Management","text":""},{"location":"spring-boot/spring-boot-best-practices/#externalize-configuration","title":"Externalize Configuration","text":"<p>Keep configuration external to your application:</p> <pre><code># application.properties\nspring.datasource.url=${DB_URL}\nspring.datasource.username=${DB_USERNAME}\nspring.datasource.password=${DB_PASSWORD}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#use-configuration-properties-classes","title":"Use Configuration Properties Classes","text":"<p>Create typed configuration classes:</p> <pre><code>@ConfigurationProperties(prefix = \"app.service\")\n@Validated\npublic class ServiceProperties {\n\n    @NotNull\n    private String apiUrl;\n\n    @Min(1)\n    @Max(60)\n    private int timeout = 30;\n\n    // Getters and setters\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#environment-specific-profiles","title":"Environment-Specific Profiles","text":"<p>Configure environment-specific settings with profiles:</p> <pre><code># application-dev.yml\nlogging:\n  level:\n    root: DEBUG\n\n# application-prod.yml\nlogging:\n  level:\n    root: WARN\n</code></pre> <p>Activate with: <pre><code>java -jar app.jar --spring.profiles.active=prod\n</code></pre></p>"},{"location":"spring-boot/spring-boot-best-practices/#secret-management","title":"Secret Management","text":"<p>Never hardcode secrets:</p> <ul> <li>Use environment variables</li> <li>Use a secrets vault</li> <li>Use encrypted properties with jasypt</li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"spring-boot/spring-boot-best-practices/#implement-proper-authentication-authorization","title":"Implement Proper Authentication &amp; Authorization","text":"<p>Configure Spring Security correctly:</p> <pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authorize -&gt; authorize\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .formLogin(withDefaults())\n            .csrf().disable(); // Only disable for REST APIs with proper considerations\n\n        return http.build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#protect-against-common-vulnerabilities","title":"Protect Against Common Vulnerabilities","text":"<p>Implement protections against:</p> <ul> <li>SQL Injection: Use parameterized queries</li> <li>XSS: Ensure proper output encoding</li> <li>CSRF: Enable CSRF protection</li> <li>Authentication bypass: Implement secure authentication</li> </ul>"},{"location":"spring-boot/spring-boot-best-practices/#use-https","title":"Use HTTPS","text":"<p>Configure SSL in production:</p> <pre><code>server.ssl.key-store=classpath:keystore.p12\nserver.ssl.key-store-password=${KEYSTORE_PASSWORD}\nserver.ssl.key-store-type=PKCS12\nserver.ssl.key-alias=tomcat\nserver.port=8443\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#implement-security-headers","title":"Implement Security Headers","text":"<p>Add security headers:</p> <pre><code>@Configuration\npublic class WebSecurityConfig {\n\n    @Bean\n    public WebSecurityCustomizer webSecurityCustomizer() {\n        return (web) -&gt; web.httpFirewall(allowUrlEncodedSlashHttpFirewall());\n    }\n\n    @Bean\n    public HttpFirewall allowUrlEncodedSlashHttpFirewall() {\n        StrictHttpFirewall firewall = new StrictHttpFirewall();\n        firewall.setAllowUrlEncodedSlash(true);\n        return firewall;\n    }\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .headers()\n                .contentSecurityPolicy(\"script-src 'self'\")\n                .and()\n                .frameOptions().deny()\n                .and()\n                .xssProtection()\n                .and()\n                .httpStrictTransportSecurity()\n                    .includeSubDomains(true)\n                    .maxAgeInSeconds(31536000);\n\n        return http.build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#input-validation","title":"Input Validation","text":"<p>Validate all user inputs:</p> <pre><code>@PostMapping(\"/users\")\npublic ResponseEntity&lt;UserDTO&gt; createUser(@Valid @RequestBody UserRequest userRequest) {\n    // Process validated input\n}\n\npublic class UserRequest {\n\n    @NotBlank\n    @Size(min = 3, max = 50)\n    private String username;\n\n    @NotBlank\n    @Email\n    private String email;\n\n    @NotBlank\n    @Pattern(regexp = \"^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).{8,}$\")\n    private String password;\n\n    // Getters and setters\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#database-access-and-data-management","title":"Database Access and Data Management","text":""},{"location":"spring-boot/spring-boot-best-practices/#use-jpa-repositories-correctly","title":"Use JPA Repositories Correctly","text":"<p>Follow best practices for Spring Data JPA:</p> <pre><code>@Repository\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n    List&lt;Product&gt; findByCategory(String category);\n\n    @Query(\"SELECT p FROM Product p WHERE p.price &lt; :maxPrice AND p.active = true\")\n    List&lt;Product&gt; findActiveBelowPrice(@Param(\"maxPrice\") BigDecimal maxPrice);\n\n    @Modifying\n    @Query(\"UPDATE Product p SET p.active = false WHERE p.id = :id\")\n    void deactivate(@Param(\"id\") Long id);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#database-migrations","title":"Database Migrations","text":"<p>Use a database migration tool:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;\n    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Structure migration scripts:</p> <pre><code>-- V1__Initial_schema.sql\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    username VARCHAR(255) NOT NULL UNIQUE,\n    email VARCHAR(255) NOT NULL\n);\n\n-- V2__Add_user_details.sql\nALTER TABLE users ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#use-transactions-appropriately","title":"Use Transactions Appropriately","text":"<p>Implement transaction management:</p> <pre><code>@Service\n@Transactional(readOnly = true)\npublic class OrderService {\n\n    private final OrderRepository orderRepository;\n    private final PaymentService paymentService;\n\n    public OrderService(OrderRepository orderRepository, PaymentService paymentService) {\n        this.orderRepository = orderRepository;\n        this.paymentService = paymentService;\n    }\n\n    @Transactional\n    public Order placeOrder(OrderRequest request) {\n        // Create order\n        Order order = new Order();\n        // Set order details\n        order = orderRepository.save(order);\n\n        // Process payment\n        paymentService.processPayment(order);\n\n        return order;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#connection-pooling","title":"Connection Pooling","text":"<p>Configure connection pooling properly:</p> <pre><code>spring.datasource.hikari.maximum-pool-size=10\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.idle-timeout=30000\nspring.datasource.hikari.connection-timeout=20000\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"spring-boot/spring-boot-best-practices/#implement-caching","title":"Implement Caching","text":"<p>Use Spring's caching abstraction:</p> <pre><code>@Configuration\n@EnableCaching\npublic class CachingConfig {\n\n    @Bean\n    public CacheManager cacheManager() {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        cacheManager.setCaches(Arrays.asList(\n            new ConcurrentMapCache(\"products\"),\n            new ConcurrentMapCache(\"categories\")\n        ));\n        return cacheManager;\n    }\n}\n\n@Service\npublic class ProductService {\n\n    @Cacheable(value = \"products\", key = \"#id\")\n    public Product getProduct(Long id) {\n        // This will be cached\n        return productRepository.findById(id).orElseThrow();\n    }\n\n    @CacheEvict(value = \"products\", key = \"#product.id\")\n    public void updateProduct(Product product) {\n        productRepository.save(product);\n    }\n\n    @CacheEvict(value = \"products\", allEntries = true)\n    public void clearCache() {\n        // Clears the entire cache\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#use-async-processing","title":"Use Async Processing","text":"<p>Implement asynchronous processing for long-running tasks:</p> <pre><code>@Configuration\n@EnableAsync\npublic class AsyncConfig {\n\n    @Bean(name = \"taskExecutor\")\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(25);\n        executor.setThreadNamePrefix(\"AsyncTask-\");\n        return executor;\n    }\n}\n\n@Service\npublic class EmailService {\n\n    @Async(\"taskExecutor\")\n    public CompletableFuture&lt;Void&gt; sendEmail(String to, String subject, String content) {\n        // Send email asynchronously\n        // ...\n        return CompletableFuture.completedFuture(null);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#pagination-and-efficient-querying","title":"Pagination and Efficient Querying","text":"<p>Implement pagination for large result sets:</p> <pre><code>@GetMapping(\"/products\")\npublic Page&lt;ProductDTO&gt; getProducts(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"20\") int size,\n        @RequestParam(defaultValue = \"id\") String sortBy) {\n\n    Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));\n    return productRepository.findAll(pageable).map(productMapper::toDto);\n}\n</code></pre> <p>Use projection for partial data retrieval:</p> <pre><code>public interface ProductSummary {\n    Long getId();\n    String getName();\n    BigDecimal getPrice();\n}\n\n@Repository\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n    List&lt;ProductSummary&gt; findAllBy();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#optimize-jpa","title":"Optimize JPA","text":"<p>Tune JPA for performance:</p> <pre><code># Batch processing\nspring.jpa.properties.hibernate.jdbc.batch_size=50\nspring.jpa.properties.hibernate.order_inserts=true\nspring.jpa.properties.hibernate.order_updates=true\n\n# Second-level cache\nspring.jpa.properties.hibernate.cache.use_second_level_cache=true\nspring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory\nspring.jpa.properties.hibernate.javax.cache.provider=org.ehcache.jsr107.EhcacheCachingProvider\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#testing-strategies","title":"Testing Strategies","text":""},{"location":"spring-boot/spring-boot-best-practices/#unit-testing","title":"Unit Testing","text":"<p>Write effective unit tests:</p> <pre><code>@ExtendWith(MockitoExtension.class)\nclass ProductServiceTests {\n\n    @Mock\n    private ProductRepository productRepository;\n\n    @InjectMocks\n    private ProductService productService;\n\n    @Test\n    void shouldReturnProductWhenExists() {\n        // Arrange\n        Product product = new Product(1L, \"Test Product\", BigDecimal.TEN);\n        when(productRepository.findById(1L)).thenReturn(Optional.of(product));\n\n        // Act\n        Product result = productService.getProduct(1L);\n\n        // Assert\n        assertThat(result).isNotNull();\n        assertThat(result.getName()).isEqualTo(\"Test Product\");\n        verify(productRepository).findById(1L);\n    }\n\n    @Test\n    void shouldThrowExceptionWhenProductNotFound() {\n        // Arrange\n        when(productRepository.findById(anyLong())).thenReturn(Optional.empty());\n\n        // Act &amp; Assert\n        assertThatThrownBy(() -&gt; productService.getProduct(1L))\n                .isInstanceOf(NotFoundException.class);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#integration-testing","title":"Integration Testing","text":"<p>Implement integration tests:</p> <pre><code>@SpringBootTest\n@TestPropertySource(properties = {\n    \"spring.datasource.url=jdbc:h2:mem:testdb\",\n    \"spring.jpa.hibernate.ddl-auto=create-drop\"\n})\nclass ProductIntegrationTests {\n\n    @Autowired\n    private ProductRepository productRepository;\n\n    @Autowired\n    private ProductService productService;\n\n    @Test\n    void shouldSaveAndRetrieveProduct() {\n        // Arrange\n        Product product = new Product();\n        product.setName(\"Integration Test Product\");\n        product.setPrice(BigDecimal.valueOf(29.99));\n\n        // Act\n        Product saved = productRepository.save(product);\n        Product retrieved = productService.getProduct(saved.getId());\n\n        // Assert\n        assertThat(retrieved).isNotNull();\n        assertThat(retrieved.getName()).isEqualTo(\"Integration Test Product\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#test-slices","title":"Test Slices","text":"<p>Use test slices for focused testing:</p> <pre><code>@WebMvcTest(ProductController.class)\nclass ProductControllerTests {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private ProductService productService;\n\n    @Test\n    void shouldReturnProductWhenExists() throws Exception {\n        // Arrange\n        ProductDTO product = new ProductDTO(1L, \"Test Product\", BigDecimal.TEN);\n        when(productService.getProductDto(1L)).thenReturn(product);\n\n        // Act &amp; Assert\n        mockMvc.perform(get(\"/api/products/1\")\n                .contentType(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(jsonPath(\"$.id\").value(1))\n                .andExpect(jsonPath(\"$.name\").value(\"Test Product\"))\n                .andExpect(jsonPath(\"$.price\").value(10));\n    }\n}\n\n@DataJpaTest\nclass ProductRepositoryTests {\n\n    @Autowired\n    private ProductRepository productRepository;\n\n    @Test\n    void shouldFindProductsByCategory() {\n        // Arrange\n        Product product1 = new Product();\n        product1.setName(\"Product 1\");\n        product1.setCategory(\"Electronics\");\n        productRepository.save(product1);\n\n        Product product2 = new Product();\n        product2.setName(\"Product 2\");\n        product2.setCategory(\"Books\");\n        productRepository.save(product2);\n\n        // Act\n        List&lt;Product&gt; electronics = productRepository.findByCategory(\"Electronics\");\n\n        // Assert\n        assertThat(electronics).hasSize(1);\n        assertThat(electronics.get(0).getName()).isEqualTo(\"Product 1\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#deployment-considerations","title":"Deployment Considerations","text":""},{"location":"spring-boot/spring-boot-best-practices/#use-profiles-for-different-environments","title":"Use Profiles for Different Environments","text":"<p>Configure environment-specific settings:</p> <pre><code># application-dev.properties\nlogging.level.org.springframework=DEBUG\nspring.datasource.url=jdbc:h2:mem:devdb\n\n# application-prod.properties\nlogging.level.org.springframework=WARN\nspring.datasource.url=${JDBC_DATABASE_URL}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#implement-health-checks","title":"Implement Health Checks","text":"<p>Add comprehensive health checks:</p> <pre><code>@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n\n    private final DataSource dataSource;\n\n    public DatabaseHealthIndicator(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    @Override\n    public Health health() {\n        try (Connection conn = dataSource.getConnection()) {\n            PreparedStatement ps = conn.prepareStatement(\"SELECT 1\");\n            ps.executeQuery();\n            return Health.up()\n                    .withDetail(\"database\", conn.getMetaData().getDatabaseProductName())\n                    .withDetail(\"version\", conn.getMetaData().getDatabaseProductVersion())\n                    .build();\n        } catch (SQLException e) {\n            return Health.down()\n                    .withDetail(\"error\", e.getMessage())\n                    .build();\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#configure-actuator-for-production","title":"Configure Actuator for Production","text":"<p>Set up Actuator properly:</p> <pre><code># Enable specific endpoints\nmanagement.endpoints.web.exposure.include=health,info,metrics,prometheus\nmanagement.endpoint.health.show-details=when-authorized\nmanagement.health.probes.enabled=true\n\n# Enable Kubernetes probes\nmanagement.endpoint.health.group.readiness.include=readinessState,db\nmanagement.endpoint.health.group.liveness.include=livenessState\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#implement-graceful-shutdown","title":"Implement Graceful Shutdown","text":"<p>Configure graceful application shutdown:</p> <pre><code>server.shutdown=graceful\nspring.lifecycle.timeout-per-shutdown-phase=20s\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#monitoring-and-maintenance","title":"Monitoring and Maintenance","text":""},{"location":"spring-boot/spring-boot-best-practices/#configure-comprehensive-logging","title":"Configure Comprehensive Logging","text":"<p>Set up appropriate logging:</p> <pre><code># File logging\nlogging.file.name=/var/log/myapp.log\nlogging.file.max-size=10MB\nlogging.file.max-history=10\n\n# Log levels\nlogging.level.root=INFO\nlogging.level.org.springframework.web=WARN\nlogging.level.com.example.myapp=DEBUG\n\n# JSON format for cloud\nlogging.pattern.console={\"time\":\"%d\",\"level\":\"%p\",\"thread\":\"%t\",\"class\":\"%logger{40}\",\"message\":\"%m\"}%n\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#implement-metrics-collection","title":"Implement Metrics Collection","text":"<p>Add custom metrics:</p> <pre><code>@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n\n    private final ProductService productService;\n    private final MeterRegistry meterRegistry;\n\n    public ProductController(ProductService productService, MeterRegistry meterRegistry) {\n        this.productService = productService;\n        this.meterRegistry = meterRegistry;\n    }\n\n    @GetMapping(\"/{id}\")\n    public ProductDTO getProduct(@PathVariable Long id) {\n        meterRegistry.counter(\"product.access\", \"id\", id.toString()).increment();\n        return productService.getProductDto(id);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#implement-circuit-breakers","title":"Implement Circuit Breakers","text":"<p>Use circuit breakers for external service calls:</p> <pre><code>@Service\npublic class ExternalServiceClient {\n\n    private final RestTemplate restTemplate;\n\n    // Constructor\n\n    @CircuitBreaker(name = \"externalService\", fallbackMethod = \"getDefaultData\")\n    public ApiResponse getData(String id) {\n        return restTemplate.getForObject(\"/api/data/{id}\", ApiResponse.class, id);\n    }\n\n    public ApiResponse getDefaultData(String id, Exception e) {\n        return new ApiResponse(\"Default data for \" + id);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":""},{"location":"spring-boot/spring-boot-best-practices/#bean-initialization-issues","title":"Bean Initialization Issues","text":"<p>Avoid circular dependencies:</p> <pre><code>// Problem\n@Service\npublic class ServiceA {\n    @Autowired\n    private ServiceB serviceB;\n}\n\n@Service\npublic class ServiceB {\n    @Autowired\n    private ServiceA serviceA;\n}\n\n// Solution\n@Service\npublic class ServiceA {\n    @Autowired\n    private ServiceB serviceB;\n}\n\n@Service\npublic class ServiceB {\n    // Use a different pattern or refactor to eliminate circular dependency\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#n1-query-problem","title":"N+1 Query Problem","text":"<p>Avoid the N+1 query anti-pattern:</p> <pre><code>// Problem\nList&lt;Order&gt; orders = orderRepository.findAll();\nfor (Order order : orders) {\n    // This causes N additional queries\n    List&lt;OrderItem&gt; items = order.getItems();\n}\n\n// Solution\n@Repository\npublic interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {\n    @Query(\"SELECT o FROM Order o LEFT JOIN FETCH o.items\")\n    List&lt;Order&gt; findAllWithItems();\n}\n\nList&lt;Order&gt; orders = orderRepository.findAllWithItems();\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#excessive-memory-usage","title":"Excessive Memory Usage","text":"<p>Avoid loading large datasets into memory:</p> <pre><code>// Problem\nList&lt;User&gt; allUsers = userRepository.findAll(); // Might load millions of records\n\n// Solution\nPageable pageable = PageRequest.of(0, 100);\nPage&lt;User&gt; userPage = userRepository.findAll(pageable);\n\n// Process first page\nprocessUsers(userPage.getContent());\n\n// Process subsequent pages if needed\nwhile (userPage.hasNext()) {\n    pageable = userPage.nextPageable();\n    userPage = userRepository.findAll(pageable);\n    processUsers(userPage.getContent());\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#missing-error-handling","title":"Missing Error Handling","text":"<p>Always handle exceptions properly:</p> <pre><code>// Problem\npublic User getUser(Long id) {\n    return userRepository.findById(id).get(); // NoSuchElementException if not found\n}\n\n// Solution\npublic User getUser(Long id) {\n    return userRepository.findById(id)\n            .orElseThrow(() -&gt; new ResourceNotFoundException(\"User not found: \" + id));\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#security-misconfigurations","title":"Security Misconfigurations","text":"<p>Avoid common security pitfalls:</p> <pre><code>// Problem - disabled CSRF without proper alternative\nhttp.csrf().disable();\n\n// Solution - only disable if you have good reason and implement alternatives\nhttp\n    .csrf().disable() // Only if using token-based auth with proper practices\n    .headers(headers -&gt; headers\n        .contentSecurityPolicy(\"default-src 'self'\")\n        .frameOptions().deny()\n    )\n    .sessionManagement(session -&gt; session\n        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n    );\n</code></pre>"},{"location":"spring-boot/spring-boot-best-practices/#summary","title":"Summary","text":"<p>This guide covered essential best practices for Spring Boot development:</p> <ul> <li>Organize your project with a proper architecture</li> <li>Follow coding practices that enhance maintainability</li> <li>Implement proper configuration management</li> <li>Apply security best practices to protect your application</li> <li>Optimize database access and data management</li> <li>Implement performance optimizations</li> <li>Write effective tests using Spring Boot's testing facilities</li> <li>Follow deployment best practices</li> <li>Implement proper monitoring and maintenance</li> <li>Avoid common pitfalls</li> </ul> <p>Following these practices will help you build robust, maintainable, and efficient Spring Boot applications that are secure and perform well in production.</p>"},{"location":"spring-boot/spring-boot-best-practices/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Documentation</li> <li>Spring Framework Documentation</li> <li>Spring Security Documentation</li> <li>Spring Boot Production-Ready Features</li> <li>Spring Boot Testing Documentation</li> <li>OWASP Top Ten </li> </ul>"},{"location":"spring-boot/spring-boot-configuration/","title":"Spring Boot Configuration","text":""},{"location":"spring-boot/spring-boot-configuration/#overview","title":"Overview","text":"<p>This guide covers the various ways to configure Spring Boot applications. Spring Boot provides a flexible configuration system that allows you to externalize configuration, use profiles for environment-specific settings, and customize nearly every aspect of your application. Understanding these configuration mechanisms is essential for building robust and adaptable Spring Boot applications.</p>"},{"location":"spring-boot/spring-boot-configuration/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Spring Boot</li> <li>Familiarity with Java</li> <li>Understanding of application properties and environment variables</li> <li>Experience with Spring Boot application structure</li> </ul>"},{"location":"spring-boot/spring-boot-configuration/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Spring Boot's configuration hierarchy</li> <li>Master application properties and YAML configuration</li> <li>Use configuration properties classes</li> <li>Work with profiles for different environments</li> <li>Externalize configuration for production deployments</li> <li>Override default configuration</li> <li>Secure sensitive configuration values</li> <li>Implement dynamic configuration updates</li> <li>Create custom property sources</li> <li>Debug configuration-related issues</li> </ul>"},{"location":"spring-boot/spring-boot-configuration/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Configuration Fundamentals</li> <li>Property Sources and Hierarchy</li> <li>Configuration File Formats</li> <li>Type-safe Configuration Properties</li> <li>Profiles</li> <li>Externalized Configuration</li> <li>Environment-Specific Configuration</li> <li>Dynamic Configuration</li> <li>Configuration Security</li> <li>Configuration Best Practices</li> </ol>"},{"location":"spring-boot/spring-boot-configuration/#configuration-fundamentals","title":"Configuration Fundamentals","text":"<p>Spring Boot prioritizes convention over configuration, providing sensible defaults that can be overridden as needed. This approach minimizes the configuration required while maintaining flexibility.</p>"},{"location":"spring-boot/spring-boot-configuration/#basic-configuration","title":"Basic Configuration","text":"<p>The simplest way to configure a Spring Boot application is through <code>application.properties</code> or <code>application.yml</code> files placed in the classpath:</p> <pre><code># application.properties\nserver.port=8080\nspring.application.name=my-application\n</code></pre> <p>or in YAML format:</p> <pre><code># application.yml\nserver:\n  port: 8080\nspring:\n  application:\n    name: my-application\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#accessing-configuration-properties","title":"Accessing Configuration Properties","text":"<p>You can access these properties in your code using the <code>@Value</code> annotation:</p> <pre><code>@RestController\npublic class HelloController {\n\n    @Value(\"${spring.application.name}\")\n    private String applicationName;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello from \" + applicationName;\n    }\n}\n</code></pre> <p>Or through the <code>Environment</code> interface:</p> <pre><code>@RestController\npublic class HelloController {\n\n    private final Environment environment;\n\n    public HelloController(Environment environment) {\n        this.environment = environment;\n    }\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello from \" + environment.getProperty(\"spring.application.name\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#property-sources-and-hierarchy","title":"Property Sources and Hierarchy","text":"<p>Spring Boot considers multiple property sources in a well-defined order, giving you flexibility in how you configure your application.</p>"},{"location":"spring-boot/spring-boot-configuration/#property-source-order","title":"Property Source Order","text":"<p>Property sources are considered in the following order (from highest to lowest precedence):</p> <ol> <li>Command-line arguments</li> <li>Java System properties (<code>System.getProperties()</code>)</li> <li>OS environment variables</li> <li>Profile-specific application properties outside of packaged jar (<code>application-{profile}.properties/yml</code>)</li> <li>Profile-specific application properties packaged inside jar (<code>application-{profile}.properties/yml</code>)</li> <li>Application properties outside of packaged jar (<code>application.properties/yml</code>)</li> <li>Application properties packaged inside jar (<code>application.properties/yml</code>)</li> <li><code>@PropertySource</code> annotations on your <code>@Configuration</code> classes</li> <li>Default properties from <code>SpringApplication.setDefaultProperties</code></li> </ol> <p>This means that properties defined in earlier sources (e.g., command-line) will override those defined in later sources (e.g., packaged properties files).</p>"},{"location":"spring-boot/spring-boot-configuration/#command-line-properties","title":"Command Line Properties","text":"<p>You can set properties via command line:</p> <pre><code>java -jar myapp.jar --server.port=9000\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#system-properties","title":"System Properties","text":"<p>System properties can be set on the command line:</p> <pre><code>java -Dserver.port=9000 -jar myapp.jar\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#environment-variables","title":"Environment Variables","text":"<p>Spring Boot converts environment variables to properties. For example, <code>SERVER_PORT</code> environment variable maps to <code>server.port</code> property:</p> <pre><code>export SERVER_PORT=9000\njava -jar myapp.jar\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#propertysource-annotation","title":"@PropertySource Annotation","text":"<p>You can add custom property sources using the <code>@PropertySource</code> annotation:</p> <pre><code>@Configuration\n@PropertySource(\"classpath:custom.properties\")\npublic class AppConfig {\n    // ...\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#configuration-file-formats","title":"Configuration File Formats","text":"<p>Spring Boot supports different configuration file formats, with properties and YAML being the most common.</p>"},{"location":"spring-boot/spring-boot-configuration/#properties-format","title":"Properties Format","text":"<p>Properties files use key-value pairs:</p> <pre><code># Simple properties\nserver.port=9000\nspring.application.name=my-app\n\n# Lists\nmy.list.values=value1,value2,value3\n\n# Maps\nmy.map.values.key1=value1\nmy.map.values.key2=value2\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#yaml-format","title":"YAML Format","text":"<p>YAML provides a more structured format:</p> <pre><code># Simple properties\nserver:\n  port: 9000\nspring:\n  application:\n    name: my-app\n\n# Lists\nmy:\n  list:\n    values:\n      - value1\n      - value2\n      - value3\n\n# Maps\n  map:\n    values:\n      key1: value1\n      key2: value2\n</code></pre> <p>YAML also supports more complex structures and is often preferred for its readability:</p> <pre><code>spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: user\n    password: pass\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  jpa:\n    hibernate:\n      ddl-auto: update\n    properties:\n      hibernate:\n        dialect: org.hibernate.dialect.MySQL8Dialect\n</code></pre> <p>To use YAML, include the SnakeYAML library in your dependencies:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.yaml&lt;/groupId&gt;\n    &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This is usually included automatically with <code>spring-boot-starter</code>.</p>"},{"location":"spring-boot/spring-boot-configuration/#multi-document-files","title":"Multi-document Files","text":"<p>YAML supports multiple documents in a single file, which can be useful for different profiles:</p> <pre><code># Default profile\nspring:\n  application:\n    name: my-application\nserver:\n  port: 8080\n---\n# Development profile\nspring:\n  config:\n    activate:\n      on-profile: dev\n  datasource:\n    url: jdbc:h2:mem:testdb\n---\n# Production profile\nspring:\n  config:\n    activate:\n      on-profile: prod\n  datasource:\n    url: jdbc:mysql://localhost/prod\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#type-safe-configuration-properties","title":"Type-safe Configuration Properties","text":"<p>Instead of using <code>@Value</code> annotations throughout your code, Spring Boot encourages the use of strongly-typed configuration properties classes.</p>"},{"location":"spring-boot/spring-boot-configuration/#configurationproperties","title":"@ConfigurationProperties","text":"<p>The <code>@ConfigurationProperties</code> annotation binds external properties to a Java class:</p> <pre><code>@Configuration\n@ConfigurationProperties(prefix = \"app.service\")\npublic class ServiceProperties {\n\n    private boolean enabled;\n    private String apiUrl;\n    private int timeout;\n\n    // Getters and setters\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getApiUrl() {\n        return apiUrl;\n    }\n\n    public void setApiUrl(String apiUrl) {\n        this.apiUrl = apiUrl;\n    }\n\n    public int getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n}\n</code></pre> <p>This class can be configured through properties:</p> <pre><code>app.service.enabled=true\napp.service.api-url=https://api.example.com\napp.service.timeout=30\n</code></pre> <p>To use this configuration class:</p> <pre><code>@Service\npublic class MyService {\n\n    private final ServiceProperties properties;\n\n    public MyService(ServiceProperties properties) {\n        this.properties = properties;\n    }\n\n    public void doSomething() {\n        if (properties.isEnabled()) {\n            // Use properties.getApiUrl() and properties.getTimeout()\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#enabling-configurationproperties","title":"Enabling @ConfigurationProperties","text":"<p>To use <code>@ConfigurationProperties</code>, you need to enable it:</p> <pre><code>@SpringBootApplication\n@ConfigurationPropertiesScan // Scans for @ConfigurationProperties classes\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n</code></pre> <p>Or you can explicitly register a configuration properties bean:</p> <pre><code>@Configuration\n@EnableConfigurationProperties(ServiceProperties.class)\npublic class AppConfig {\n    // ...\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#nested-properties","title":"Nested Properties","text":"<p>Configuration properties can have nested structures:</p> <pre><code>@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n\n    private final Service service = new Service();\n    private final Security security = new Security();\n\n    public Service getService() {\n        return service;\n    }\n\n    public Security getSecurity() {\n        return security;\n    }\n\n    public static class Service {\n        private String url;\n        private int timeout;\n\n        // Getters and setters\n    }\n\n    public static class Security {\n        private boolean enabled;\n        private String tokenSecret;\n\n        // Getters and setters\n    }\n}\n</code></pre> <p>Configure with:</p> <pre><code>app.service.url=https://example.com/api\napp.service.timeout=60\napp.security.enabled=true\napp.security.token-secret=abc123\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#validation","title":"Validation","text":"<p>You can validate configuration properties using JSR-303 Bean Validation:</p> <pre><code>@ConfigurationProperties(prefix = \"app.service\")\n@Validated\npublic class ServiceProperties {\n\n    @NotNull\n    @Pattern(regexp = \"^https?://.*\")\n    private String apiUrl;\n\n    @Min(1000)\n    @Max(10000)\n    private int timeout;\n\n    // Getters and setters\n}\n</code></pre> <p>Add the validation dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#property-conversion","title":"Property Conversion","text":"<p>Spring Boot automatically converts properties to the appropriate types. For complex types like <code>Duration</code> or <code>DataSize</code>, you can use appropriate suffixes:</p> <pre><code>app.service.timeout=10s  # 10 seconds\napp.service.max-size=10MB  # 10 megabytes\n</code></pre> <p>In your configuration class:</p> <pre><code>@ConfigurationProperties(prefix = \"app.service\")\npublic class ServiceProperties {\n\n    private Duration timeout;\n    private DataSize maxSize;\n\n    // Getters and setters\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#profiles","title":"Profiles","text":"<p>Profiles are a core feature of Spring Boot that allow different configurations for different environments.</p>"},{"location":"spring-boot/spring-boot-configuration/#basic-profile-configuration","title":"Basic Profile Configuration","text":"<p>Define profile-specific properties in files named <code>application-{profile}.properties</code> or <code>application-{profile}.yml</code>:</p> <pre><code># application-dev.properties\nserver.port=8080\nspring.datasource.url=jdbc:h2:mem:testdb\n\n# application-prod.properties\nserver.port=80\nspring.datasource.url=jdbc:mysql://localhost/prod\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#activating-profiles","title":"Activating Profiles","text":"<p>You can activate profiles in several ways:</p> <ol> <li>Using the <code>spring.profiles.active</code> property:</li> </ol> <pre><code># application.properties\nspring.profiles.active=dev\n</code></pre> <ol> <li>Using the command line:</li> </ol> <pre><code>java -jar myapp.jar --spring.profiles.active=dev\n</code></pre> <ol> <li>Using environment variables:</li> </ol> <pre><code>export SPRING_PROFILES_ACTIVE=dev\njava -jar myapp.jar\n</code></pre> <ol> <li>Programmatically:</li> </ol> <pre><code>SpringApplication app = new SpringApplication(MyApplication.class);\napp.setAdditionalProfiles(\"dev\");\napp.run(args);\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#profile-groups","title":"Profile Groups","text":"<p>Spring Boot 2.4+ supports profile groups to activate multiple profiles at once:</p> <pre><code>spring.profiles.group.production=prod,monitoring,management\n</code></pre> <p>When you activate the <code>production</code> profile, it automatically activates <code>prod</code>, <code>monitoring</code>, and <code>management</code> profiles.</p>"},{"location":"spring-boot/spring-boot-configuration/#profile-specific-beans","title":"Profile-specific Beans","text":"<p>You can define beans that are only created when a specific profile is active:</p> <pre><code>@Configuration\npublic class AppConfig {\n\n    @Bean\n    @Profile(\"dev\")\n    public DataSource devDataSource() {\n        // Return an H2 in-memory database\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n\n    @Bean\n    @Profile(\"prod\")\n    public DataSource prodDataSource() {\n        // Return a production database\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:mysql://localhost/prod\");\n        config.setUsername(\"root\");\n        config.setPassword(\"password\");\n        return new HikariDataSource(config);\n    }\n}\n</code></pre> <p>You can also apply profiles at the class level:</p> <pre><code>@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    // Dev-specific beans\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfig {\n    // Prod-specific beans\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#default-profile","title":"Default Profile","text":"<p>If no profile is explicitly activated, Spring Boot uses the \"default\" profile. You can provide configuration for this profile in <code>application-default.properties</code>.</p>"},{"location":"spring-boot/spring-boot-configuration/#externalized-configuration","title":"Externalized Configuration","text":"<p>Externalizing configuration is crucial for the Twelve-Factor App methodology, allowing applications to be deployed to different environments without code changes.</p>"},{"location":"spring-boot/spring-boot-configuration/#config-server","title":"Config Server","text":"<p>For large applications, consider using Spring Cloud Config Server:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#kubernetes-configmaps-and-secrets","title":"Kubernetes ConfigMaps and Secrets","text":"<p>When deploying to Kubernetes, use ConfigMaps and Secrets:</p> <pre><code># application.yml\nspring:\n  config:\n    import: \"optional:configtree:/etc/config/\"\n</code></pre> <p>Mount your ConfigMap or Secret to <code>/etc/config/</code>.</p>"},{"location":"spring-boot/spring-boot-configuration/#environment-variables_1","title":"Environment Variables","text":"<p>For containerized environments, environment variables are often the preferred way to configure applications:</p> <pre><code>SPRING_DATASOURCE_URL=jdbc:mysql://mysql-service:3306/mydb\nSPRING_DATASOURCE_USERNAME=myuser\nSPRING_DATASOURCE_PASSWORD=mypassword\n</code></pre> <p>Spring Boot will automatically convert these to the appropriate properties.</p>"},{"location":"spring-boot/spring-boot-configuration/#config-data-imports","title":"Config Data Imports","text":"<p>Spring Boot 2.4+ supports importing configuration from various sources:</p> <pre><code>spring.config.import=optional:configserver:http://config-server:8888\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Different environments often require different configurations.</p>"},{"location":"spring-boot/spring-boot-configuration/#development-environment","title":"Development Environment","text":"<p>For development, prioritize ease of use:</p> <pre><code># application-dev.properties\nlogging.level.root=DEBUG\nspring.h2.console.enabled=true\nspring.jpa.show-sql=true\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#testing-environment","title":"Testing Environment","text":"<p>For testing, focus on isolation and reproducibility:</p> <pre><code># application-test.properties\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.jpa.hibernate.ddl-auto=create-drop\nspring.liquibase.enabled=false\nspring.flyway.enabled=false\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#production-environment","title":"Production Environment","text":"<p>For production, prioritize security, performance, and robustness:</p> <pre><code># application-prod.properties\nlogging.level.root=WARN\nserver.tomcat.max-threads=200\nspring.jpa.hibernate.ddl-auto=validate\nmanagement.endpoints.web.exposure.include=health,info,metrics\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Some applications need to update their configuration without restarting.</p>"},{"location":"spring-boot/spring-boot-configuration/#refreshscope","title":"@RefreshScope","text":"<p>Spring Cloud's <code>@RefreshScope</code> enables dynamic config updates:</p> <pre><code>@RestController\n@RefreshScope\npublic class MessageController {\n\n    @Value(\"${message:Hello default}\")\n    private String message;\n\n    @GetMapping(\"/message\")\n    public String getMessage() {\n        return message;\n    }\n}\n</code></pre> <p>With Spring Cloud Config, you can trigger a refresh via actuator:</p> <pre><code>curl -X POST http://localhost:8080/actuator/refresh\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#configuration-changes-at-runtime","title":"Configuration Changes at Runtime","text":"<p>For custom behavior on configuration changes:</p> <pre><code>@Component\npublic class ConfigChangeListener {\n\n    @EventListener\n    public void handleConfigChange(EnvironmentChangeEvent event) {\n        for (String key : event.getKeys()) {\n            // Handle changes to specific properties\n            if (key.equals(\"app.feature.enabled\")) {\n                // Update feature flag status\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#configuration-security","title":"Configuration Security","text":"<p>Securing sensitive configuration is critical for production applications.</p>"},{"location":"spring-boot/spring-boot-configuration/#encrypting-properties","title":"Encrypting Properties","text":"<p>Spring Cloud Config Server can encrypt sensitive properties:</p> <pre><code>spring.datasource.password={cipher}AQCGMXJDkb2iOPTxjCDvHDQchUAe0HVihiQa3BXrTwzwmGlV...\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#using-vault-for-secrets","title":"Using Vault for Secrets","text":"<p>HashiCorp Vault is a secure option for managing secrets:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-vault-config&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>spring.cloud.vault.token=your-vault-token\nspring.cloud.vault.scheme=http\nspring.cloud.vault.host=localhost\nspring.cloud.vault.port=8200\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#masking-sensitive-properties","title":"Masking Sensitive Properties","text":"<p>Prevent sensitive properties from being logged:</p> <pre><code>@SpringBootApplication\npublic class MyApplication {\n\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(MyApplication.class);\n        app.setDefaultProperties(Collections.singletonMap(\"spring.config.additional-location\", \n            \"optional:file:./config/\"));\n        System.setProperty(\"spring.config.hide-on-startup\", \"true\");\n        app.run(args);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"spring-boot/spring-boot-configuration/#use-configuration-properties-classes","title":"Use Configuration Properties Classes","text":"<p>Favor <code>@ConfigurationProperties</code> over <code>@Value</code> for better maintainability and type safety.</p>"},{"location":"spring-boot/spring-boot-configuration/#keep-default-configuration-reasonable","title":"Keep Default Configuration Reasonable","text":"<p>Default values should be sensible so applications work out of the box for development.</p>"},{"location":"spring-boot/spring-boot-configuration/#document-configuration-properties","title":"Document Configuration Properties","text":"<p>Document each property's purpose and acceptable values:</p> <pre><code>@ConfigurationProperties(prefix = \"app.service\")\n@ConfigurationPropertiesMetadata(\n    description = \"Configures the API service client\"\n)\npublic class ServiceProperties {\n\n    /**\n     * Base URL for the API service.\n     * Must be a valid URL starting with http:// or https://\n     */\n    @NotNull\n    @Pattern(regexp = \"^https?://.*\")\n    private String apiUrl;\n\n    /**\n     * Timeout in seconds for API requests.\n     * Must be between 1 and 60.\n     */\n    @Min(1)\n    @Max(60)\n    private int timeout = 30;\n\n    // Getters and setters\n}\n</code></pre> <p>You can generate documentation using the <code>spring-boot-configuration-processor</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#validate-configuration-at-startup","title":"Validate Configuration at Startup","text":"<p>Fail fast if the configuration is invalid:</p> <pre><code>@SpringBootApplication\npublic class MyApplication implements ApplicationRunner {\n\n    private final ServiceProperties serviceProperties;\n\n    public MyApplication(ServiceProperties serviceProperties) {\n        this.serviceProperties = serviceProperties;\n    }\n\n    @Override\n    public void run(ApplicationArguments args) {\n        // Validate critical configuration\n        if (serviceProperties.getApiUrl() == null || \n            !serviceProperties.getApiUrl().startsWith(\"https://\")) {\n            throw new IllegalStateException(\"API URL must be HTTPS for production!\");\n        }\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#use-profiles-effectively","title":"Use Profiles Effectively","text":"<ul> <li>Keep profiles focused on specific environments or features</li> <li>Use profile groups for related profiles</li> <li>Consider the default profile for local development</li> </ul>"},{"location":"spring-boot/spring-boot-configuration/#externalize-secrets","title":"Externalize Secrets","text":"<ul> <li>Never commit secrets to source control</li> <li>Use environment variables or a secrets management system</li> <li>Consider Spring Cloud Config or Vault for centralized configuration</li> </ul>"},{"location":"spring-boot/spring-boot-configuration/#test-configuration","title":"Test Configuration","text":"<p>Write tests for your configuration to catch issues early:</p> <pre><code>@SpringBootTest\n@ActiveProfiles(\"test\")\nclass ServicePropertiesTests {\n\n    @Autowired\n    private ServiceProperties serviceProperties;\n\n    @Test\n    void defaultTimeoutShouldBeThirtySeconds() {\n        assertEquals(30, serviceProperties.getTimeout());\n    }\n\n    @Test\n    void apiUrlShouldBeConfigured() {\n        assertNotNull(serviceProperties.getApiUrl());\n        assertTrue(serviceProperties.getApiUrl().startsWith(\"http\"));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-configuration/#use-appropriate-property-sources","title":"Use Appropriate Property Sources","text":"<ul> <li>Use application properties for defaults and common settings</li> <li>Use profile-specific properties for environment-specific values</li> <li>Use command-line arguments for overrides in specific deployments</li> </ul>"},{"location":"spring-boot/spring-boot-configuration/#summary","title":"Summary","text":"<p>Spring Boot's configuration system offers a powerful and flexible way to configure your applications:</p> <ul> <li>Multiple file formats support structured configuration</li> <li>Property sources hierarchy provides clear precedence rules</li> <li>Type-safe configuration with <code>@ConfigurationProperties</code></li> <li>Profiles for environment-specific configurations</li> <li>Built-in support for externalized configuration</li> <li>Integration with various secrets management systems</li> <li>Dynamic configuration updates for certain scenarios</li> </ul> <p>By mastering these configuration options, you can build applications that are easy to develop, test, and deploy across different environments.</p>"},{"location":"spring-boot/spring-boot-configuration/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Configuration Properties Documentation</li> <li>Externalized Configuration Reference</li> <li>Spring Cloud Config Documentation</li> <li>Twelve-Factor App Methodology</li> <li>Spring Boot Profiles Documentation </li> </ul>"},{"location":"spring-boot/spring-boot-core-concepts/","title":"Spring Boot Core Concepts","text":""},{"location":"spring-boot/spring-boot-core-concepts/#overview","title":"Overview","text":"<p>Spring Boot Core Concepts delves into the fundamental principles and mechanisms that power the Spring Boot framework. Understanding these core concepts is essential for effectively developing robust applications with Spring Boot. This guide explores the architecture behind Spring Boot's \"convention over configuration\" approach, including auto-configuration, dependency injection, the application context, and the component model that makes Spring Boot both powerful and easy to use.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Java programming knowledge</li> <li>Familiarity with build tools (Maven/Gradle)</li> <li>Understanding of Spring Boot basics (from spring-boot-starter.md)</li> <li>Basic knowledge of object-oriented programming principles</li> <li>Familiarity with annotations in Java</li> </ul>"},{"location":"spring-boot/spring-boot-core-concepts/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Spring's Inversion of Control (IoC) and Dependency Injection (DI) principles</li> <li>Master the Spring application context and bean lifecycle</li> <li>Comprehend Spring Boot's auto-configuration mechanism</li> <li>Learn how to use and customize Spring Boot's starters</li> <li>Understand the component scan process and component model</li> <li>Explore conditional configuration in Spring Boot</li> <li>Grasp externalized configuration and property binding</li> <li>Implement proper application event handling</li> <li>Configure and use different bean scopes</li> <li>Apply the Spring Expression Language (SpEL)</li> </ul>"},{"location":"spring-boot/spring-boot-core-concepts/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Inversion of Control and Dependency Injection</li> <li>Spring Application Context</li> <li>Bean Lifecycle</li> <li>Component Scanning</li> <li>Auto-Configuration Mechanism</li> <li>Conditional Configuration</li> <li>Externalized Configuration</li> <li>Spring Boot Starters</li> <li>Application Events</li> <li>Bean Scopes</li> <li>Spring Expression Language (SpEL)</li> <li>AOP in Spring Boot</li> </ol>"},{"location":"spring-boot/spring-boot-core-concepts/#inversion-of-control-and-dependency-injection","title":"Inversion of Control and Dependency Injection","text":"<p>Inversion of Control (IoC) and Dependency Injection (DI) are foundational concepts in Spring that enable loose coupling and better testability.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#inversion-of-control","title":"Inversion of Control","text":"<p>IoC is a design principle where the control flow of a program is inverted: instead of the programmer controlling the flow, the framework controls it. In Spring, IoC means the framework manages object creation and lifecycle rather than the application code.</p> <p>Traditional Approach vs. IoC:</p> <pre><code>// Traditional approach - we control object creation\npublic class TraditionalService {\n    private Database database;\n\n    public TraditionalService() {\n        this.database = new MySQLDatabase(); // Hard-coded dependency\n    }\n\n    public void processData() {\n        database.query();\n    }\n}\n\n// IoC approach - framework manages object creation\npublic class IoCService {\n    private Database database; // Dependency declared but not created\n\n    public IoCService(Database database) {\n        this.database = database; // Injected by the framework\n    }\n\n    public void processData() {\n        database.query();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#dependency-injection","title":"Dependency Injection","text":"<p>DI is a technique where dependencies are provided to objects rather than the objects creating their dependencies. Spring supports three main types of dependency injection:</p>"},{"location":"spring-boot/spring-boot-core-concepts/#1-constructor-injection-recommended","title":"1. Constructor Injection (Recommended)","text":"<pre><code>@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    private final EmailService emailService;\n\n    // Dependencies injected via constructor\n    public UserService(UserRepository userRepository, EmailService emailService) {\n        this.userRepository = userRepository;\n        this.emailService = emailService;\n    }\n\n    public void registerUser(User user) {\n        userRepository.save(user);\n        emailService.sendWelcomeEmail(user);\n    }\n}\n</code></pre> <p>Benefits: - Promotes immutability (fields can be final) - Makes dependencies explicit - Ensures required dependencies are provided - Better for testing</p>"},{"location":"spring-boot/spring-boot-core-concepts/#2-setter-injection","title":"2. Setter Injection","text":"<pre><code>@Service\npublic class UserService {\n    private UserRepository userRepository;\n    private EmailService emailService;\n\n    // Dependencies injected via setters\n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    @Autowired\n    public void setEmailService(EmailService emailService) {\n        this.emailService = emailService;\n    }\n\n    public void registerUser(User user) {\n        userRepository.save(user);\n        emailService.sendWelcomeEmail(user);\n    }\n}\n</code></pre> <p>Benefits: - Useful for optional dependencies - Allows for reconfiguration after construction - Avoids circular dependency issues</p>"},{"location":"spring-boot/spring-boot-core-concepts/#3-field-injection-not-recommended-for-production","title":"3. Field Injection (Not Recommended for Production)","text":"<pre><code>@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private EmailService emailService;\n\n    public void registerUser(User user) {\n        userRepository.save(user);\n        emailService.sendWelcomeEmail(user);\n    }\n}\n</code></pre> <p>Limitations: - Makes testing harder (can't easily inject mocks) - Hides dependencies - Prevents final fields (immutability)</p>"},{"location":"spring-boot/spring-boot-core-concepts/#spring-ioc-container","title":"Spring IoC Container","text":"<p>The Spring IoC container is responsible for: 1. Creating beans 2. Wiring dependencies 3. Managing bean lifecycles 4. Providing beans when requested</p> <p>Spring provides two main types of IoC containers:</p> <ol> <li>BeanFactory: The basic container providing DI and bean management</li> <li>ApplicationContext: Enhanced container with enterprise features (extends BeanFactory)</li> </ol>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions","title":"Bean Definitions","text":"<p>Beans are the objects managed by the Spring IoC container. They can be defined through:</p>"},{"location":"spring-boot/spring-boot-core-concepts/#java-configuration-preferred","title":"Java Configuration (Preferred)","text":"<pre><code>@Configuration\npublic class AppConfig {\n\n    @Bean\n    public UserRepository userRepository() {\n        return new JpaUserRepository();\n    }\n\n    @Bean\n    public EmailService emailService() {\n        return new SmtpEmailService();\n    }\n\n    @Bean\n    public UserService userService(UserRepository userRepository, EmailService emailService) {\n        return new UserService(userRepository, emailService);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#xml-configuration-legacy","title":"XML Configuration (Legacy)","text":"<pre><code>&lt;beans&gt;\n    &lt;bean id=\"userRepository\" class=\"com.example.JpaUserRepository\"/&gt;\n\n    &lt;bean id=\"emailService\" class=\"com.example.SmtpEmailService\"/&gt;\n\n    &lt;bean id=\"userService\" class=\"com.example.UserService\"&gt;\n        &lt;constructor-arg ref=\"userRepository\"/&gt;\n        &lt;constructor-arg ref=\"emailService\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#component-scanning-with-annotations","title":"Component Scanning with Annotations","text":"<pre><code>@SpringBootApplication // Includes @ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n@Repository\npublic class JpaUserRepository implements UserRepository {\n    // Implementation\n}\n\n@Service\npublic class SmtpEmailService implements EmailService {\n    // Implementation\n}\n\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    private final EmailService emailService;\n\n    // Constructor injection\n    public UserService(UserRepository userRepository, EmailService emailService) {\n        this.userRepository = userRepository;\n        this.emailService = emailService;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#benefits-of-ioc-and-di","title":"Benefits of IoC and DI","text":"<ol> <li>Loose coupling: Components depend on abstractions, not implementations</li> <li>Testability: Dependencies can be easily mocked or stubbed</li> <li>Modularity: Components can be developed and tested in isolation</li> <li>Flexibility: Implementations can be swapped without changing client code</li> <li>Maintainability: Reduces boilerplate code and centralizes configuration</li> </ol>"},{"location":"spring-boot/spring-boot-core-concepts/#spring-application-context","title":"Spring Application Context","text":"<p>The Application Context is the central interface within a Spring application that provides configuration information to the application. It represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#types-of-application-contexts","title":"Types of Application Contexts","text":"<p>Spring provides several implementations of the ApplicationContext interface:</p> <ol> <li> <p>AnnotationConfigApplicationContext: For Java-based configurations    <pre><code>ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n</code></pre></p> </li> <li> <p>ClassPathXmlApplicationContext: For XML configurations on the classpath    <pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n</code></pre></p> </li> <li> <p>FileSystemXmlApplicationContext: For XML configurations in the file system    <pre><code>ApplicationContext context = new FileSystemXmlApplicationContext(\"config/beans.xml\");\n</code></pre></p> </li> <li> <p>WebApplicationContext: For web applications</p> </li> <li> <p>SpringApplication.run(): In Spring Boot applications    <pre><code>ApplicationContext context = SpringApplication.run(Application.class, args);\n</code></pre></p> </li> </ol>"},{"location":"spring-boot/spring-boot-core-concepts/#retrieving-beans","title":"Retrieving Beans","text":"<p>You can retrieve beans from the Application Context in several ways:</p> <pre><code>// By type\nUserService userService = context.getBean(UserService.class);\n\n// By name\nUserService userService = (UserService) context.getBean(\"userService\");\n\n// By name and type\nUserService userService = context.getBean(\"customUserService\", UserService.class);\n\n// With generics when multiple beans of the same type exist\n@Autowired\n@Qualifier(\"jpaUserRepository\")\nprivate UserRepository userRepository;\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#application-context-hierarchy","title":"Application Context Hierarchy","text":"<p>Application contexts can be organized in a parent-child hierarchy:</p> <pre><code>// Create parent context\nApplicationContext parent = new AnnotationConfigApplicationContext(ParentConfig.class);\n\n// Create child context\nAnnotationConfigApplicationContext child = new AnnotationConfigApplicationContext();\nchild.setParent(parent);\nchild.register(ChildConfig.class);\nchild.refresh();\n</code></pre> <p>In a hierarchy: - Child contexts can see beans in parent contexts - Parent contexts cannot see beans in child contexts - Child beans can override parent beans</p>"},{"location":"spring-boot/spring-boot-core-concepts/#context-features","title":"Context Features","text":"<p>The ApplicationContext provides several enterprise features beyond basic IoC:</p> <ol> <li> <p>Internationalization (i18n) <pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\nString message = context.getMessage(\"greeting\", null, \"Default greeting\", Locale.ENGLISH);\n</code></pre></p> </li> <li> <p>Event Publication <pre><code>// Publishing events\ncontext.publishEvent(new CustomEvent(this, \"Something happened\"));\n\n// Listening to events\n@EventListener\npublic void handleContextStart(ContextStartedEvent event) {\n     System.out.println(\"Context started at \" + new Date());\n}\n</code></pre></p> </li> <li> <p>Resource Access <pre><code>Resource resource = context.getResource(\"classpath:data.txt\");\nInputStream is = resource.getInputStream();\n</code></pre></p> </li> <li> <p>Environment Access <pre><code>Environment env = context.getEnvironment();\nString property = env.getProperty(\"app.name\");\n</code></pre></p> </li> </ol>"},{"location":"spring-boot/spring-boot-core-concepts/#spring-boot-application-context","title":"Spring Boot Application Context","text":"<p>In Spring Boot, the application context is created by <code>SpringApplication.run()</code>:</p> <pre><code>@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        ApplicationContext context = SpringApplication.run(Application.class, args);\n\n        // Inspect context beans\n        System.out.println(\"Bean count: \" + context.getBeanDefinitionCount());\n\n        // List all beans\n        String[] beanNames = context.getBeanDefinitionNames();\n        Arrays.sort(beanNames);\n        for (String beanName : beanNames) {\n            System.out.println(beanName);\n        }\n    }\n}\n</code></pre> <p>Spring Boot creates a special <code>AnnotationConfigServletWebServerApplicationContext</code> for web applications that includes: - Auto-configuration - Component scanning - Embedded web server - Property source configuration</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-lifecycle","title":"Bean Lifecycle","text":"<p>Understanding the lifecycle of Spring beans is crucial for proper resource management and initialization.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-lifecycle-phases","title":"Bean Lifecycle Phases","text":"<ol> <li>Instantiation: Spring creates an instance of the bean</li> <li>Populate Properties: Dependencies are injected</li> <li>BeanNameAware: <code>setBeanName()</code> method called if implemented</li> <li>BeanFactoryAware: <code>setBeanFactory()</code> method called if implemented</li> <li>ApplicationContextAware: <code>setApplicationContext()</code> method called if implemented</li> <li>PreInitialization: <code>@PostConstruct</code> methods called</li> <li>InitializingBean: <code>afterPropertiesSet()</code> method called if implemented</li> <li>Custom Init Method: Method specified by <code>initMethod</code> attribute called</li> <li>Bean is Ready: Bean is ready for use</li> <li>PreDestruction: <code>@PreDestroy</code> methods called</li> <li>DisposableBean: <code>destroy()</code> method called if implemented</li> <li>Custom Destroy Method: Method specified by <code>destroyMethod</code> attribute called</li> </ol>"},{"location":"spring-boot/spring-boot-core-concepts/#lifecycle-callback-methods","title":"Lifecycle Callback Methods","text":"<p>Several approaches exist for hooking into bean lifecycle events:</p>"},{"location":"spring-boot/spring-boot-core-concepts/#using-annotations-postconstruct-and-predestroy","title":"Using Annotations (@PostConstruct and @PreDestroy)","text":"<pre><code>@Service\npublic class UserService {\n    private final UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    @PostConstruct\n    public void init() {\n        System.out.println(\"UserService initialized\");\n        // Perform any initialization logic\n    }\n\n    @PreDestroy\n    public void cleanup() {\n        System.out.println(\"UserService being destroyed\");\n        // Release resources, close connections, etc.\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#implementing-lifecycle-interfaces","title":"Implementing Lifecycle Interfaces","text":"<pre><code>@Service\npublic class DatabaseService implements InitializingBean, DisposableBean {\n\n    private Connection connection;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        // Called after properties are set\n        System.out.println(\"Initializing database connection\");\n        connection = DriverManager.getConnection(\"jdbc:mysql://localhost/db\", \"user\", \"pass\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        // Called before bean is destroyed\n        System.out.println(\"Closing database connection\");\n        if (connection != null &amp;&amp; !connection.isClosed()) {\n            connection.close();\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#using-bean-annotation-attributes","title":"Using @Bean Annotation Attributes","text":"<pre><code>@Configuration\npublic class AppConfig {\n\n    @Bean(initMethod = \"init\", destroyMethod = \"close\")\n    public DatabaseConnection databaseConnection() {\n        return new DatabaseConnection(\"jdbc:mysql://localhost/db\", \"user\", \"pass\");\n    }\n}\n\npublic class DatabaseConnection {\n    // No Spring-specific imports needed\n\n    private String url;\n    private String username;\n    private String password;\n    private Connection connection;\n\n    public DatabaseConnection(String url, String username, String password) {\n        this.url = url;\n        this.username = username;\n        this.password = password;\n    }\n\n    public void init() throws SQLException {\n        System.out.println(\"Initializing connection\");\n        connection = DriverManager.getConnection(url, username, password);\n    }\n\n    public void close() throws SQLException {\n        System.out.println(\"Closing connection\");\n        if (connection != null &amp;&amp; !connection.isClosed()) {\n            connection.close();\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#startup-and-shutdown-hooks","title":"Startup and Shutdown Hooks","text":"<p>For application-wide initialization and cleanup:</p> <pre><code>@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);\n\n        // Add shutdown hook\n        context.registerShutdownHook();\n    }\n\n    @Bean\n    public ApplicationListener&lt;ContextRefreshedEvent&gt; startupListener() {\n        return event -&gt; {\n            System.out.println(\"Application context refreshed, application is ready!\");\n        };\n    }\n\n    @Bean\n    public ApplicationListener&lt;ContextClosedEvent&gt; shutdownListener() {\n        return event -&gt; {\n            System.out.println(\"Application context is closing, performing cleanup!\");\n        };\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-post-processors","title":"Bean Post Processors","text":"<p>Bean post processors allow you to intercept the initialization process:</p> <pre><code>@Component\npublic class CustomBeanPostProcessor implements BeanPostProcessor {\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (bean instanceof AuditableBean) {\n            System.out.println(\"Before initialization of bean with name: \" + beanName);\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (bean instanceof AuditableBean) {\n            System.out.println(\"After initialization of bean with name: \" + beanName);\n            // Could return a proxy here\n        }\n        return bean;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#lazy-initialization","title":"Lazy Initialization","text":"<p>By default, Spring initializes singleton beans eagerly (at context startup). You can change this behavior:</p> <pre><code>// Lazy-initialize a specific bean\n@Bean\n@Lazy\npublic ExpensiveService expensiveService() {\n    return new ExpensiveService();\n}\n\n// Lazy-initialize all beans\n@SpringBootApplication\n@Lazy\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n// In application.properties\nspring.main.lazy-initialization=true\n</code></pre>"},{"location":"spring-boot/spring-boot-core-concepts/#lifecycle-best-practices","title":"Lifecycle Best Practices","text":"<ol> <li>Prefer Constructor Injection: For required dependencies</li> <li>Use @PostConstruct for Initialization: Cleaner than interface implementations</li> <li>Clean Up Resources: Always release resources in @PreDestroy methods</li> <li>Keep Initialization Fast: Long initialization delays application startup</li> <li>Handle Exceptions: Properly handle exceptions in lifecycle methods</li> <li>Test Lifecycle Methods: Ensure proper initialization and cleanup in tests</li> </ol>"},{"location":"spring-boot/spring-boot-core-concepts/#component-scanning","title":"Component Scanning","text":"<p>Component scanning is a key feature in Spring Boot that allows you to automatically discover and register beans.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#component-scanning-mechanism","title":"Component Scanning Mechanism","text":"<p>Spring Boot uses the <code>@ComponentScan</code> annotation to scan for components in the package structure.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions","title":"Exclusions","text":"<p>You can exclude certain packages or classes from being scanned using the <code>@ComponentScan</code> annotation's <code>excludeFilters</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_1","title":"Bean Definitions","text":"<p>Beans are defined in the scanned components. For example, if a class is annotated with <code>@Service</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#auto-configuration-mechanism","title":"Auto-Configuration Mechanism","text":"<p>Auto-configuration is a key feature in Spring Boot that allows you to configure your application based on dependencies and settings.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#auto-configuration-mechanism_1","title":"Auto-Configuration Mechanism","text":"<p>Spring Boot uses the <code>@EnableAutoConfiguration</code> annotation to enable auto-configuration. It scans for beans and applies configuration based on the dependencies and settings.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_1","title":"Exclusions","text":"<p>You can exclude certain auto-configurations using the <code>@EnableAutoConfiguration</code> annotation's <code>exclude</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_2","title":"Bean Definitions","text":"<p>Beans are defined in the auto-configured components. For example, if a class is annotated with <code>@Configuration</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#conditional-configuration","title":"Conditional Configuration","text":"<p>Conditional configuration allows you to configure your application based on certain conditions.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#conditional-configuration-mechanism","title":"Conditional Configuration Mechanism","text":"<p>Spring Boot uses the <code>@Conditional</code> annotation to enable conditional configuration.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_2","title":"Exclusions","text":"<p>You can exclude certain conditional configurations using the <code>@Conditional</code> annotation's <code>unless</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_3","title":"Bean Definitions","text":"<p>Beans are defined in the conditional components. For example, if a class is annotated with <code>@Conditional</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#externalized-configuration","title":"Externalized Configuration","text":"<p>Externalized configuration allows you to configure your application based on external sources.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#externalized-configuration-mechanism","title":"Externalized Configuration Mechanism","text":"<p>Spring Boot uses the <code>@ConfigurationProperties</code> annotation to enable externalized configuration.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_3","title":"Exclusions","text":"<p>You can exclude certain externalized configurations using the <code>@ConfigurationProperties</code> annotation's <code>ignoreInvalidFields</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_4","title":"Bean Definitions","text":"<p>Beans are defined in the externalized components. For example, if a class is annotated with <code>@ConfigurationProperties</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#spring-boot-starters","title":"Spring Boot Starters","text":"<p>Spring Boot Starters are a way to quickly start a project with a specific set of dependencies.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#spring-boot-starter-mechanism","title":"Spring Boot Starter Mechanism","text":"<p>Spring Boot uses the <code>@SpringBootApplication</code> annotation to enable Spring Boot applications.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_4","title":"Exclusions","text":"<p>You can exclude certain starters using the <code>@SpringBootApplication</code> annotation's <code>exclude</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_5","title":"Bean Definitions","text":"<p>Beans are defined in the starter components. For example, if a class is annotated with <code>@SpringBootApplication</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#application-events","title":"Application Events","text":"<p>Application events allow you to handle events in your application.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#application-event-mechanism","title":"Application Event Mechanism","text":"<p>Spring Boot uses the <code>@EventListener</code> annotation to enable application events.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_5","title":"Exclusions","text":"<p>You can exclude certain events using the <code>@EventListener</code> annotation's <code>condition</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_6","title":"Bean Definitions","text":"<p>Beans are defined in the event listeners. For example, if a class is annotated with <code>@EventListener</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-scopes","title":"Bean Scopes","text":"<p>Bean scopes allow you to control the lifecycle and scope of beans.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-scope-mechanism","title":"Bean Scope Mechanism","text":"<p>Spring Boot uses the <code>@Scope</code> annotation to enable bean scopes.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_6","title":"Exclusions","text":"<p>You can exclude certain scopes using the <code>@Scope</code> annotation's <code>value</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_7","title":"Bean Definitions","text":"<p>Beans are defined in the scoped components. For example, if a class is annotated with <code>@Scope</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#spring-expression-language-spel","title":"Spring Expression Language (SpEL)","text":"<p>Spring Expression Language (SpEL) allows you to evaluate expressions in your application.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#spel-mechanism","title":"SpEL Mechanism","text":"<p>Spring Boot uses the <code>@Value</code> annotation to enable SpEL expressions.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_7","title":"Exclusions","text":"<p>You can exclude certain expressions using the <code>@Value</code> annotation's <code>value</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_8","title":"Bean Definitions","text":"<p>Beans are defined in the SpEL components. For example, if a class is annotated with <code>@Value</code>, it will be registered as a bean.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#aop-in-spring-boot","title":"AOP in Spring Boot","text":"<p>Aspect-Oriented Programming (AOP) allows you to separate cross-cutting concerns from your application code.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#aop-mechanism","title":"AOP Mechanism","text":"<p>Spring Boot uses the <code>@EnableAspectJAutoProxy</code> annotation to enable AOP.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#exclusions_8","title":"Exclusions","text":"<p>You can exclude certain aspects using the <code>@EnableAspectJAutoProxy</code> annotation's <code>proxyTargetClass</code> attribute.</p>"},{"location":"spring-boot/spring-boot-core-concepts/#bean-definitions_9","title":"Bean Definitions","text":"<p>Beans are defined in the AOP components. For example, if a class is annotated with <code>@EnableAspectJAutoProxy</code>, it will be registered as a bean. </p>"},{"location":"spring-boot/spring-boot-data-access/","title":"Spring Boot Data Access","text":""},{"location":"spring-boot/spring-boot-data-access/#overview","title":"Overview","text":"<p>This guide covers data access in Spring Boot applications, exploring the various approaches and technologies for working with databases. It introduces Spring Data's key concepts, Spring Boot's auto-configuration for data sources, transaction management, and different persistence mechanisms. By the end of this guide, you'll understand how to effectively implement data access layers in Spring Boot applications, following best practices for maintainability, performance, and security.</p>"},{"location":"spring-boot/spring-boot-data-access/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Java and Spring Boot concepts</li> <li>Understanding of relational and/or NoSQL database concepts</li> <li>Familiarity with SQL query language</li> <li>Basic understanding of ORM (Object-Relational Mapping) concepts</li> <li>Spring Boot development environment set up</li> </ul>"},{"location":"spring-boot/spring-boot-data-access/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Configure data sources in Spring Boot applications</li> <li>Understand Spring Boot's auto-configuration for data access</li> <li>Implement data access layers using Spring JDBC, JPA, and Spring Data</li> <li>Configure multiple data sources</li> <li>Work with database migrations</li> <li>Understand and implement transaction management</li> <li>Test data access components</li> <li>Optimize database operations for performance</li> </ul>"},{"location":"spring-boot/spring-boot-data-access/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Data Access Overview in Spring Boot</li> <li>Configuring Data Sources</li> <li>Working with JDBC in Spring Boot</li> <li>Introduction to JPA</li> <li>Spring Data JPA Basics</li> <li>Transaction Management</li> <li>Database Migrations</li> <li>Working with Multiple Data Sources</li> <li>Auditing with Spring Data</li> <li>Caching for Data Access</li> <li>Performance Optimization</li> <li>Testing Data Access Layers</li> <li>Security Considerations</li> <li>Best Practices</li> </ol>"},{"location":"spring-boot/spring-boot-data-access/#data-access-overview-in-spring-boot","title":"Data Access Overview in Spring Boot","text":"<p>Spring Boot offers extensive support for data access, building on Spring Framework's data access features while adding auto-configuration and starter dependencies to simplify setup and configuration.</p>"},{"location":"spring-boot/spring-boot-data-access/#spring-data-access-landscape","title":"Spring Data Access Landscape","text":"<p>Spring Boot supports multiple approaches to data access:</p> <ol> <li>Spring JDBC: For low-level JDBC operations with reduced boilerplate</li> <li>Spring Data JPA: For ORM-based access using JPA</li> <li>Spring Data MongoDB: For MongoDB document database access</li> <li>Spring Data Redis: For Redis key-value store operations</li> <li>Spring Data Elasticsearch: For Elasticsearch search operations</li> <li>Spring Data JDBC: For JDBC access with simplified mapping</li> <li>Spring Data R2DBC: For reactive relational database access</li> </ol> <p>Each approach has its strengths and is suitable for different scenarios.</p>"},{"location":"spring-boot/spring-boot-data-access/#spring-boots-auto-configuration","title":"Spring Boot's Auto-Configuration","text":"<p>Spring Boot automatically configures your data access layer based on: - Dependencies on your classpath - Configuration properties in application.properties/application.yml - Beans defined in your application context</p> <p>This auto-configuration typically includes: - DataSource configuration - EntityManagerFactory setup (for JPA) - Transaction manager configuration - Repository interface detection and implementation - Connection pooling setup</p>"},{"location":"spring-boot/spring-boot-data-access/#architecture-of-data-access-in-spring-applications","title":"Architecture of Data Access in Spring Applications","text":"<p>A typical data access architecture in Spring applications consists of:</p> <ol> <li>Entity Layer: Domain model objects representing database tables/documents</li> <li>Repository Layer: Interfaces defining data access operations</li> <li>Service Layer: Business logic using repositories</li> <li>Controller Layer: Exposing data operations via APIs</li> </ol> <pre><code>Controller \u2192 Service \u2192 Repository \u2192 Entity\n</code></pre> <p>The repository layer abstracts the underlying data store, allowing services to focus on business logic rather than data access mechanics.</p>"},{"location":"spring-boot/spring-boot-data-access/#performance-and-maintenance-considerations","title":"Performance and Maintenance Considerations","text":"<p>When setting up data access in Spring Boot, consider:</p> <ul> <li>Connection Pooling: Properly sized connection pools</li> <li>N+1 Query Problem: Fetching relations efficiently</li> <li>Lazy vs. Eager Loading: Choosing appropriate fetch strategies</li> <li>Batch Processing: For handling large datasets</li> <li>Caching: To reduce database load</li> <li>Database Migrations: For maintaining schema changes</li> </ul> <p>In the following sections, we'll explore these concepts in detail, starting with configuring data sources in Spring Boot.</p>"},{"location":"spring-boot/spring-boot-data-access/#configuring-data-sources","title":"Configuring Data Sources","text":"<p>A DataSource is the starting point for database access in a Spring Boot application, representing a connection factory for a database.</p>"},{"location":"spring-boot/spring-boot-data-access/#basic-datasource-configuration","title":"Basic DataSource Configuration","text":"<p>Spring Boot can auto-configure a DataSource based on: - The presence of a database driver on the classpath - Configuration in application.properties/application.yml</p>"},{"location":"spring-boot/spring-boot-data-access/#mavengradle-dependencies","title":"Maven/Gradle Dependencies","text":"<p>For H2 in-memory database (development/testing):</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For MySQL:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For PostgreSQL:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;\n    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#configuration-properties","title":"Configuration Properties","text":"<p>application.properties:</p> <pre><code># H2 Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.driverClassName=org.h2.Driver\nspring.datasource.username=sa\nspring.datasource.password=password\nspring.h2.console.enabled=true\n\n# MySQL\n# spring.datasource.url=jdbc:mysql://localhost:3306/mydb\n# spring.datasource.username=user\n# spring.datasource.password=password\n# spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# PostgreSQL\n# spring.datasource.url=jdbc:postgresql://localhost:5432/mydb\n# spring.datasource.username=user\n# spring.datasource.password=password\n# spring.datasource.driver-class-name=org.postgresql.Driver\n</code></pre> <p>application.yml:</p> <pre><code>spring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: password\n  h2:\n    console:\n      enabled: true\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#connection-pooling","title":"Connection Pooling","text":"<p>Spring Boot uses HikariCP as the default connection pool. You can configure it with:</p> <pre><code># Connection pool settings\nspring.datasource.hikari.maximum-pool-size=10\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.idle-timeout=600000\nspring.datasource.hikari.connection-timeout=30000\nspring.datasource.hikari.max-lifetime=1800000\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#programmatic-datasource-configuration","title":"Programmatic DataSource Configuration","text":"<p>For more control, you can define a DataSource bean:</p> <pre><code>@Configuration\npublic class DataSourceConfig {\n\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    public DataSource dataSource() {\n        return DataSourceBuilder.create().build();\n    }\n}\n</code></pre> <p>Or with more specific configurations:</p> <pre><code>@Configuration\npublic class DataSourceConfig {\n\n    @Bean\n    public DataSource dataSource() {\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydb\");\n        config.setUsername(\"user\");\n        config.setPassword(\"password\");\n        config.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\n        config.setMaximumPoolSize(10);\n        config.setMinimumIdle(5);\n\n        return new HikariDataSource(config);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#embedded-database-configuration","title":"Embedded Database Configuration","text":"<p>For development and testing, you can use embedded databases:</p> <pre><code>@Configuration\npublic class EmbeddedDataSourceConfig {\n\n    @Bean\n    public DataSource dataSource() {\n        return new EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.H2)\n                .addScript(\"schema.sql\")\n                .addScript(\"data.sql\")\n                .build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#jndi-datasource-configuration","title":"JNDI DataSource Configuration","text":"<p>For application servers that provide JNDI resources:</p> <pre><code>spring.datasource.jndi-name=java:comp/env/jdbc/myDataSource\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#datasource-initialization","title":"DataSource Initialization","text":"<p>Spring Boot can initialize your database using SQL scripts:</p> <pre><code># Initialize the schema\nspring.sql.init.mode=always\nspring.sql.init.schema-locations=classpath:schema.sql\nspring.sql.init.data-locations=classpath:data.sql\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#testing-with-test-containers","title":"Testing with Test Containers","text":"<p>For integration tests, TestContainers provides real database instances via Docker:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;testcontainers&lt;/artifactId&gt;\n    &lt;version&gt;1.18.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n    &lt;version&gt;1.18.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>@SpringBootTest\n@Testcontainers\nclass DatabaseIntegrationTest {\n\n    @Container\n    static PostgreSQLContainer&lt;?&gt; postgres = new PostgreSQLContainer&lt;&gt;(\"postgres:14\")\n            .withDatabaseName(\"testdb\")\n            .withUsername(\"test\")\n            .withPassword(\"test\");\n\n    @DynamicPropertySource\n    static void registerPgProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n    }\n\n    @Test\n    void testDatabaseConnection() {\n        // Test code\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#working-with-jdbc-in-spring-boot","title":"Working with JDBC in Spring Boot","text":"<p>While higher-level abstractions like JPA are popular, JDBC remains a powerful option for data access in Spring Boot, especially for: - Simple applications with straightforward data access needs - Performance-critical operations requiring fine-grained control - Legacy database interactions</p>"},{"location":"spring-boot/spring-boot-data-access/#spring-jdbc-templates","title":"Spring JDBC Templates","text":"<p>Spring provides JdbcTemplate to simplify JDBC operations, handling connection management, exception translation, and result set processing:</p>"},{"location":"spring-boot/spring-boot-data-access/#maven-dependencies","title":"Maven Dependencies","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#basic-jdbctemplate-usage","title":"Basic JdbcTemplate Usage","text":"<pre><code>@Service\npublic class ProductService {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public ProductService(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    // Query for a single object\n    public Product findById(Long id) {\n        return jdbcTemplate.queryForObject(\n                \"SELECT id, name, price FROM products WHERE id = ?\",\n                new Object[]{id},\n                (rs, rowNum) -&gt; {\n                    Product product = new Product();\n                    product.setId(rs.getLong(\"id\"));\n                    product.setName(rs.getString(\"name\"));\n                    product.setPrice(rs.getBigDecimal(\"price\"));\n                    return product;\n                });\n    }\n\n    // Query for multiple objects\n    public List&lt;Product&gt; findAll() {\n        return jdbcTemplate.query(\n                \"SELECT id, name, price FROM products\",\n                (rs, rowNum) -&gt; {\n                    Product product = new Product();\n                    product.setId(rs.getLong(\"id\"));\n                    product.setName(rs.getString(\"name\"));\n                    product.setPrice(rs.getBigDecimal(\"price\"));\n                    return product;\n                });\n    }\n\n    // Insert operation\n    public void save(Product product) {\n        jdbcTemplate.update(\n                \"INSERT INTO products (name, price) VALUES (?, ?)\",\n                product.getName(), product.getPrice());\n    }\n\n    // Update operation\n    public void update(Product product) {\n        jdbcTemplate.update(\n                \"UPDATE products SET name = ?, price = ? WHERE id = ?\",\n                product.getName(), product.getPrice(), product.getId());\n    }\n\n    // Delete operation\n    public void delete(Long id) {\n        jdbcTemplate.update(\"DELETE FROM products WHERE id = ?\", id);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#using-namedparameterjdbctemplate","title":"Using NamedParameterJdbcTemplate","text":"<p>For more readable SQL statements with named parameters:</p> <pre><code>@Service\npublic class ProductNamedParamService {\n\n    private final NamedParameterJdbcTemplate jdbcTemplate;\n\n    public ProductNamedParamService(NamedParameterJdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public Product findById(Long id) {\n        Map&lt;String, Object&gt; params = Map.of(\"id\", id);\n\n        return jdbcTemplate.queryForObject(\n                \"SELECT id, name, price FROM products WHERE id = :id\",\n                params,\n                (rs, rowNum) -&gt; {\n                    Product product = new Product();\n                    product.setId(rs.getLong(\"id\"));\n                    product.setName(rs.getString(\"name\"));\n                    product.setPrice(rs.getBigDecimal(\"price\"));\n                    return product;\n                });\n    }\n\n    public void save(Product product) {\n        SqlParameterSource params = new MapSqlParameterSource()\n                .addValue(\"name\", product.getName())\n                .addValue(\"price\", product.getPrice());\n\n        jdbcTemplate.update(\n                \"INSERT INTO products (name, price) VALUES (:name, :price)\",\n                params);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#row-mappers","title":"Row Mappers","text":"<p>Extract the mapping logic for reusability:</p> <pre><code>public class ProductRowMapper implements RowMapper&lt;Product&gt; {\n    @Override\n    public Product mapRow(ResultSet rs, int rowNum) throws SQLException {\n        Product product = new Product();\n        product.setId(rs.getLong(\"id\"));\n        product.setName(rs.getString(\"name\"));\n        product.setPrice(rs.getBigDecimal(\"price\"));\n        return product;\n    }\n}\n\n@Service\npublic class ProductServiceWithMapper {\n    private final JdbcTemplate jdbcTemplate;\n    private final ProductRowMapper rowMapper = new ProductRowMapper();\n\n    public ProductServiceWithMapper(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public List&lt;Product&gt; findAll() {\n        return jdbcTemplate.query(\"SELECT id, name, price FROM products\", rowMapper);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#batch-operations","title":"Batch Operations","text":"<p>For efficient bulk operations:</p> <pre><code>@Service\npublic class ProductBatchService {\n    private final JdbcTemplate jdbcTemplate;\n\n    public ProductBatchService(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void batchInsert(List&lt;Product&gt; products) {\n        jdbcTemplate.batchUpdate(\n                \"INSERT INTO products (name, price) VALUES (?, ?)\",\n                new BatchPreparedStatementSetter() {\n                    @Override\n                    public void setValues(PreparedStatement ps, int i) throws SQLException {\n                        Product product = products.get(i);\n                        ps.setString(1, product.getName());\n                        ps.setBigDecimal(2, product.getPrice());\n                    }\n\n                    @Override\n                    public int getBatchSize() {\n                        return products.size();\n                    }\n                });\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#using-simplejdbcclasses","title":"Using SimpleJdbcClasses","text":"<p>For simpler JDBC operations:</p> <pre><code>@Service\npublic class ProductSimpleJdbcService {\n    private final SimpleJdbcInsert simpleJdbcInsert;\n\n    public ProductSimpleJdbcService(DataSource dataSource) {\n        this.simpleJdbcInsert = new SimpleJdbcInsert(dataSource)\n                .withTableName(\"products\")\n                .usingGeneratedKeyColumns(\"id\");\n    }\n\n    public Long save(Product product) {\n        Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();\n        parameters.put(\"name\", product.getName());\n        parameters.put(\"price\", product.getPrice());\n\n        Number key = simpleJdbcInsert.executeAndReturnKey(parameters);\n        return key.longValue();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#schema-management-with-jdbc","title":"Schema Management with JDBC","text":"<p>Manage database schema with SQL scripts:</p> <pre><code># Schema initialization\nspring.sql.init.mode=always\nspring.sql.init.schema-locations=classpath:schema.sql\nspring.sql.init.data-locations=classpath:data.sql\n</code></pre> <p>schema.sql: <pre><code>CREATE TABLE IF NOT EXISTS products (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n</code></pre></p> <p>data.sql: <pre><code>INSERT INTO products (name, price) VALUES ('Product 1', 19.99);\nINSERT INTO products (name, price) VALUES ('Product 2', 29.99);\n</code></pre></p>"},{"location":"spring-boot/spring-boot-data-access/#transaction-management-with-jdbc","title":"Transaction Management with JDBC","text":"<p>For transaction management:</p> <pre><code>@Service\n@Transactional\npublic class OrderService {\n    private final JdbcTemplate jdbcTemplate;\n\n    public OrderService(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void placeOrder(Order order) {\n        // Create order\n        jdbcTemplate.update(\n                \"INSERT INTO orders (customer_id, total_amount) VALUES (?, ?)\",\n                order.getCustomerId(), order.getTotalAmount());\n\n        // Create order items\n        for (OrderItem item : order.getItems()) {\n            jdbcTemplate.update(\n                    \"INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)\",\n                    order.getId(), item.getProductId(), item.getQuantity(), item.getPrice());\n\n            // Update inventory\n            jdbcTemplate.update(\n                    \"UPDATE inventory SET stock = stock - ? WHERE product_id = ?\",\n                    item.getQuantity(), item.getProductId());\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#jdbc-best-practices","title":"JDBC Best Practices","text":"<ol> <li>Use Connection Pooling: Always configure proper connection pooling</li> <li>Parameterize Queries: Avoid SQL injection with prepared statements</li> <li>Batch Operations: Use batch updates for multiple operations</li> <li>Transaction Management: Properly manage transactions</li> <li>Handle Exceptions: Use Spring's exception translation</li> <li>Close Resources: Ensure all JDBC resources are properly closed</li> <li>Pagination: Implement pagination for large result sets</li> <li>Avoid Over-fetching: Only select the columns you need</li> <li>Use Column Aliases: For clarity in complex queries</li> <li>Consider Stored Procedures: For complex operations</li> </ol>"},{"location":"spring-boot/spring-boot-data-access/#introduction-to-jpa","title":"Introduction to JPA","text":"<p>The Java Persistence API (JPA) provides an object-relational mapping (ORM) approach for Java applications. It allows you to work with relational databases using Java objects, reducing the amount of JDBC code required.</p>"},{"location":"spring-boot/spring-boot-data-access/#jpa-vs-jdbc","title":"JPA vs. JDBC","text":"Aspect JPA JDBC Abstraction Level High Low SQL Knowledge Required Minimal Extensive Code Volume Less More Performance Control Limited Detailed Learning Curve Steeper Simpler Database Portability Better Limited Complex Query Support Limited Complete"},{"location":"spring-boot/spring-boot-data-access/#setting-up-jpa-in-spring-boot","title":"Setting Up JPA in Spring Boot","text":""},{"location":"spring-boot/spring-boot-data-access/#dependencies","title":"Dependencies","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#jpa-configuration","title":"JPA Configuration","text":"<pre><code># Basic JPA properties\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect\n</code></pre> <p>Options for <code>spring.jpa.hibernate.ddl-auto</code>: - <code>none</code>: No schema initialization - <code>validate</code>: Validate schema, no changes to database - <code>update</code>: Update schema - <code>create</code>: Create schema, dropping existing tables first - <code>create-drop</code>: Create schema on startup, drop on shutdown</p>"},{"location":"spring-boot/spring-boot-data-access/#entity-definition","title":"Entity Definition","text":"<p>Entities are Java classes mapped to database tables:</p> <pre><code>@Entity\n@Table(name = \"products\")\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    @Column(nullable = false, precision = 10, scale = 2)\n    private BigDecimal price;\n\n    @Column(name = \"created_at\")\n    private LocalDateTime createdAt;\n\n    // Getters and setters\n\n    @PrePersist\n    public void prePersist() {\n        createdAt = LocalDateTime.now();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#relationships","title":"Relationships","text":""},{"location":"spring-boot/spring-boot-data-access/#one-to-one","title":"One-to-One","text":"<pre><code>@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String username;\n\n    @OneToOne(cascade = CascadeType.ALL)\n    @JoinColumn(name = \"profile_id\", referencedColumnName = \"id\")\n    private UserProfile profile;\n\n    // Getters and setters\n}\n\n@Entity\npublic class UserProfile {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String firstName;\n    private String lastName;\n\n    @OneToOne(mappedBy = \"profile\")\n    private User user;\n\n    // Getters and setters\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#one-to-many","title":"One-to-Many","text":"<pre><code>@Entity\npublic class Category {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    @OneToMany(mappedBy = \"category\", cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Product&gt; products = new ArrayList&lt;&gt;();\n\n    // Getters and setters\n}\n\n@Entity\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"category_id\")\n    private Category category;\n\n    // Getters and setters\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#many-to-many","title":"Many-to-Many","text":"<pre><code>@Entity\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    @ManyToMany\n    @JoinTable(\n        name = \"product_tag\",\n        joinColumns = @JoinColumn(name = \"product_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"tag_id\")\n    )\n    private Set&lt;Tag&gt; tags = new HashSet&lt;&gt;();\n\n    // Getters and setters\n}\n\n@Entity\npublic class Tag {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    @ManyToMany(mappedBy = \"tags\")\n    private Set&lt;Product&gt; products = new HashSet&lt;&gt;();\n\n    // Getters and setters\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#basic-jpa-operations","title":"Basic JPA Operations","text":"<p>Using the EntityManager directly:</p> <pre><code>@Service\npublic class ProductService {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Transactional\n    public void save(Product product) {\n        entityManager.persist(product);\n    }\n\n    @Transactional\n    public Product update(Product product) {\n        return entityManager.merge(product);\n    }\n\n    @Transactional\n    public void delete(Long id) {\n        Product product = entityManager.find(Product.class, id);\n        if (product != null) {\n            entityManager.remove(product);\n        }\n    }\n\n    public Product findById(Long id) {\n        return entityManager.find(Product.class, id);\n    }\n\n    public List&lt;Product&gt; findAll() {\n        return entityManager.createQuery(\"SELECT p FROM Product p\", Product.class)\n                .getResultList();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#jpql-jpa-query-language","title":"JPQL (JPA Query Language)","text":"<p>JPA provides its own query language similar to SQL:</p> <pre><code>@Service\npublic class ProductJPQLService {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List&lt;Product&gt; findByNameLike(String name) {\n        return entityManager.createQuery(\n                \"SELECT p FROM Product p WHERE p.name LIKE :name\", Product.class)\n                .setParameter(\"name\", \"%\" + name + \"%\")\n                .getResultList();\n    }\n\n    public List&lt;Product&gt; findByPriceRange(BigDecimal min, BigDecimal max) {\n        return entityManager.createQuery(\n                \"SELECT p FROM Product p WHERE p.price BETWEEN :min AND :max\", Product.class)\n                .setParameter(\"min\", min)\n                .setParameter(\"max\", max)\n                .getResultList();\n    }\n\n    public List&lt;Object[]&gt; findProductCounts() {\n        return entityManager.createQuery(\n                \"SELECT c.name, COUNT(p) FROM Category c JOIN c.products p GROUP BY c.name\")\n                .getResultList();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#spring-data-jpa-basics","title":"Spring Data JPA Basics","text":"<p>Spring Data JPA simplifies the implementation of JPA-based repositories by abstracting much of the boilerplate code required when working directly with the EntityManager.</p>"},{"location":"spring-boot/spring-boot-data-access/#spring-data-jpa-repositories","title":"Spring Data JPA Repositories","text":"<p>Spring Data JPA provides interfaces that enable you to define repositories with minimal code:</p> <pre><code>public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n    // That's it! You get CRUD operations for free\n}\n</code></pre> <p>The <code>JpaRepository</code> interface provides methods like: - <code>save(entity)</code>: Save or update an entity - <code>findById(id)</code>: Find an entity by ID - <code>findAll()</code>: Get all entities - <code>delete(entity)</code>: Delete an entity - <code>count()</code>: Count total entities - And more...</p>"},{"location":"spring-boot/spring-boot-data-access/#using-the-repository","title":"Using the Repository","text":"<pre><code>@Service\npublic class ProductService {\n\n    private final ProductRepository productRepository;\n\n    public ProductService(ProductRepository productRepository) {\n        this.productRepository = productRepository;\n    }\n\n    public List&lt;Product&gt; findAllProducts() {\n        return productRepository.findAll();\n    }\n\n    public Optional&lt;Product&gt; findProductById(Long id) {\n        return productRepository.findById(id);\n    }\n\n    public Product saveProduct(Product product) {\n        return productRepository.save(product);\n    }\n\n    public void deleteProduct(Long id) {\n        productRepository.deleteById(id);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#repository-query-methods","title":"Repository Query Methods","text":"<p>Spring Data JPA can generate queries based on method names:</p> <pre><code>public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n    // Find by attribute\n    List&lt;Product&gt; findByName(String name);\n\n    // Find with multiple conditions\n    List&lt;Product&gt; findByNameAndPrice(String name, BigDecimal price);\n\n    // Using comparison operators\n    List&lt;Product&gt; findByPriceGreaterThan(BigDecimal price);\n\n    // Using LIKE\n    List&lt;Product&gt; findByNameContaining(String namePart);\n\n    // Order results\n    List&lt;Product&gt; findByNameContainingOrderByPriceDesc(String namePart);\n\n    // Limit results\n    List&lt;Product&gt; findTop5ByOrderByCreatedAtDesc();\n\n    // Using nested properties\n    List&lt;Product&gt; findByCategoryName(String categoryName);\n\n    // Using IN operator\n    List&lt;Product&gt; findByIdIn(List&lt;Long&gt; ids);\n\n    // More advanced expressions\n    List&lt;Product&gt; findByNameIgnoreCaseAndPriceBetween(\n            String name, BigDecimal minPrice, BigDecimal maxPrice);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#custom-queries-with-query","title":"Custom Queries with @Query","text":"<p>For more complex queries, use the <code>@Query</code> annotation:</p> <pre><code>public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n\n    // JPQL query\n    @Query(\"SELECT p FROM Product p WHERE p.price &gt; ?1 AND p.category.name = ?2\")\n    List&lt;Product&gt; findExpensiveProductsByCategory(BigDecimal price, String categoryName);\n\n    // Using named parameters\n    @Query(\"SELECT p FROM Product p WHERE p.name LIKE %:keyword% OR p.description LIKE %:keyword%\")\n    List&lt;Product&gt; searchByKeyword(@Param(\"keyword\") String keyword);\n\n    // Native SQL query\n    @Query(value = \"SELECT * FROM products WHERE created_at &gt; :date\", nativeQuery = true)\n    List&lt;Product&gt; findRecentProductsNative(@Param(\"date\") LocalDateTime date);\n\n    // Count query\n    @Query(\"SELECT COUNT(p) FROM Product p WHERE p.category.id = :categoryId\")\n    long countByCategoryId(@Param(\"categoryId\") Long categoryId);\n\n    // Update query\n    @Modifying\n    @Query(\"UPDATE Product p SET p.price = p.price * :factor WHERE p.category.id = :categoryId\")\n    int updatePriceForCategory(@Param(\"factor\") BigDecimal factor, @Param(\"categoryId\") Long categoryId);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#paging-and-sorting","title":"Paging and Sorting","text":"<p>Spring Data provides built-in support for pagination and sorting:</p> <pre><code>public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n    // Method with paging and sorting\n    Page&lt;Product&gt; findByCategoryId(Long categoryId, Pageable pageable);\n\n    // Method with sorting\n    List&lt;Product&gt; findByNameContaining(String name, Sort sort);\n}\n</code></pre> <p>Using pagination and sorting:</p> <pre><code>@Service\npublic class ProductPageService {\n\n    private final ProductRepository productRepository;\n\n    public ProductPageService(ProductRepository productRepository) {\n        this.productRepository = productRepository;\n    }\n\n    public Page&lt;Product&gt; findProductsByCategoryPaged(Long categoryId, int page, int size) {\n        Pageable pageable = PageRequest.of(page, size, Sort.by(\"name\").ascending());\n        return productRepository.findByCategoryId(categoryId, pageable);\n    }\n\n    public List&lt;Product&gt; findProductsSorted() {\n        // Multiple sort criteria\n        Sort sort = Sort.by(\n                Sort.Order.desc(\"createdAt\"),\n                Sort.Order.asc(\"name\")\n        );\n\n        return productRepository.findAll(sort);\n    }\n\n    public Page&lt;Product&gt; findAllProductsPaged(int page, int size, String sortField, String direction) {\n        Sort.Direction dir = direction.equalsIgnoreCase(\"asc\") ? \n                Sort.Direction.ASC : Sort.Direction.DESC;\n\n        Pageable pageable = PageRequest.of(page, size, Sort.by(dir, sortField));\n        return productRepository.findAll(pageable);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#specifications","title":"Specifications","text":"<p>For dynamic queries, use Specifications:</p> <pre><code>public interface ProductRepository extends JpaRepository&lt;Product, Long&gt;, JpaSpecificationExecutor&lt;Product&gt; {\n    // JpaSpecificationExecutor adds methods like findAll(Specification)\n}\n</code></pre> <p>Using Specifications:</p> <pre><code>@Service\npublic class ProductSpecificationService {\n\n    private final ProductRepository productRepository;\n\n    public ProductSpecificationService(ProductRepository productRepository) {\n        this.productRepository = productRepository;\n    }\n\n    public List&lt;Product&gt; findProductsByFilters(\n            String name, \n            BigDecimal minPrice, \n            BigDecimal maxPrice, \n            Long categoryId) {\n\n        Specification&lt;Product&gt; spec = Specification.where(null);\n\n        if (name != null &amp;&amp; !name.isEmpty()) {\n            spec = spec.and((root, query, cb) -&gt; \n                    cb.like(cb.lower(root.get(\"name\")), \"%\" + name.toLowerCase() + \"%\"));\n        }\n\n        if (minPrice != null) {\n            spec = spec.and((root, query, cb) -&gt; \n                    cb.greaterThanOrEqualTo(root.get(\"price\"), minPrice));\n        }\n\n        if (maxPrice != null) {\n            spec = spec.and((root, query, cb) -&gt; \n                    cb.lessThanOrEqualTo(root.get(\"price\"), maxPrice));\n        }\n\n        if (categoryId != null) {\n            spec = spec.and((root, query, cb) -&gt; \n                    cb.equal(root.get(\"category\").get(\"id\"), categoryId));\n        }\n\n        return productRepository.findAll(spec);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#projection-interfaces","title":"Projection Interfaces","text":"<p>To retrieve only specific fields:</p> <pre><code>public interface ProductSummary {\n    Long getId();\n    String getName();\n    BigDecimal getPrice();\n\n    // Computed attribute\n    @Value(\"#{target.name + ' - $' + target.price}\")\n    String getNameWithPrice();\n}\n\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n    List&lt;ProductSummary&gt; findByCategory_Name(String categoryName);\n\n    // Dynamically choose between projections\n    &lt;T&gt; List&lt;T&gt; findByPriceGreaterThan(BigDecimal price, Class&lt;T&gt; type);\n}\n</code></pre> <p>Using projections:</p> <pre><code>@Service\npublic class ProductProjectionService {\n\n    private final ProductRepository productRepository;\n\n    public ProductProjectionService(ProductRepository productRepository) {\n        this.productRepository = productRepository;\n    }\n\n    public List&lt;ProductSummary&gt; findProductSummariesByCategory(String categoryName) {\n        return productRepository.findByCategory_Name(categoryName);\n    }\n\n    public List&lt;ProductSummary&gt; findExpensiveProductSummaries(BigDecimal minPrice) {\n        return productRepository.findByPriceGreaterThan(minPrice, ProductSummary.class);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#custom-repository-implementations","title":"Custom Repository Implementations","text":"<p>For methods that can't be expressed with query methods or <code>@Query</code>:</p> <pre><code>// Define custom functionality\npublic interface CustomProductRepository {\n    List&lt;Product&gt; findBySalesStats(int minSales, double ratingThreshold);\n}\n\n// Main repository interface\npublic interface ProductRepository extends \n        JpaRepository&lt;Product, Long&gt;, \n        CustomProductRepository {\n    // Regular Spring Data JPA methods\n}\n\n// Implementation\n@Repository\npublic class CustomProductRepositoryImpl implements CustomProductRepository {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Override\n    public List&lt;Product&gt; findBySalesStats(int minSales, double ratingThreshold) {\n        // Complex query using criteria API\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery&lt;Product&gt; query = cb.createQuery(Product.class);\n        Root&lt;Product&gt; product = query.from(Product.class);\n\n        // Join to sales statistics\n        Join&lt;Product, SalesStatistics&gt; stats = product.join(\"salesStatistics\");\n\n        // Build predicates\n        Predicate salesPredicate = cb.greaterThanOrEqualTo(stats.get(\"totalSales\"), minSales);\n        Predicate ratingPredicate = cb.greaterThanOrEqualTo(stats.get(\"averageRating\"), ratingThreshold);\n\n        // Combine predicates and execute\n        query.where(cb.and(salesPredicate, ratingPredicate));\n        return entityManager.createQuery(query).getResultList();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#auditing-with-spring-data","title":"Auditing with Spring Data","text":"<p>Track entity creation and modification:</p> <pre><code>@Configuration\n@EnableJpaAuditing\npublic class AuditingConfig {\n\n    @Bean\n    public AuditorAware&lt;String&gt; auditorProvider() {\n        return () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())\n                .map(SecurityContext::getAuthentication)\n                .filter(Authentication::isAuthenticated)\n                .map(Authentication::getName);\n    }\n}\n\n@MappedSuperclass\n@EntityListeners(AuditingEntityListener.class)\npublic abstract class Auditable {\n\n    @CreatedDate\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private LocalDateTime createdAt;\n\n    @LastModifiedDate\n    @Column(name = \"updated_at\")\n    private LocalDateTime updatedAt;\n\n    @CreatedBy\n    @Column(name = \"created_by\", updatable = false)\n    private String createdBy;\n\n    @LastModifiedBy\n    @Column(name = \"updated_by\")\n    private String updatedBy;\n\n    // Getters\n}\n\n@Entity\npublic class Product extends Auditable {\n    // Product fields\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#event-listeners","title":"Event Listeners","text":"<p>React to entity lifecycle events:</p> <pre><code>@Entity\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String status;\n\n    // Other fields\n\n    @PrePersist\n    public void onPrePersist() {\n        if (status == null) {\n            status = \"PENDING\";\n        }\n    }\n\n    @PostPersist\n    public void onPostPersist() {\n        System.out.println(\"Order created with ID: \" + id);\n    }\n\n    @PreUpdate\n    public void onPreUpdate() {\n        // Logic before update\n    }\n\n    @PostUpdate\n    public void onPostUpdate() {\n        // Logic after update\n    }\n\n    @PreRemove\n    public void onPreRemove() {\n        // Logic before removal\n    }\n\n    @PostRemove\n    public void onPostRemove() {\n        // Logic after removal\n    }\n\n    @PostLoad\n    public void onPostLoad() {\n        // Logic after entity is loaded\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#entity-graphs","title":"Entity Graphs","text":"<p>To solve the N+1 query problem with lazy loading:</p> <pre><code>@Entity\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    private Category category;\n\n    @OneToMany(mappedBy = \"product\", fetch = FetchType.LAZY)\n    private Set&lt;Review&gt; reviews;\n\n    // Named entity graph\n    @NamedEntityGraph(\n        name = \"Product.withCategoryAndReviews\",\n        attributeNodes = {\n            @NamedAttributeNode(\"category\"),\n            @NamedAttributeNode(\"reviews\")\n        }\n    )\n\n    // Getters and setters\n}\n\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n\n    // Use predefined entity graph\n    @EntityGraph(value = \"Product.withCategoryAndReviews\")\n    List&lt;Product&gt; findAll();\n\n    // Define ad-hoc entity graph\n    @EntityGraph(attributePaths = {\"category\"})\n    Optional&lt;Product&gt; findById(Long id);\n\n    // Use different fetch modes\n    @EntityGraph(value = \"Product.withCategoryAndReviews\", type = EntityGraph.EntityGraphType.LOAD)\n    List&lt;Product&gt; findByNameContaining(String name);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#spring-data-jpa-best-practices","title":"Spring Data JPA Best Practices","text":"<ol> <li>Use DTOs: Avoid returning entities directly from controllers to prevent serialization issues</li> <li>Pagination: Always use pagination for large result sets</li> <li>Batch Processing: Use batch operations for bulk database operations</li> <li>Avoid N+1 Queries: Use entity graphs or fetch joins for related entities</li> <li>Eager vs. Lazy Loading: Choose appropriate fetch strategies</li> <li>Minimize Locking: Be cautious with pessimistic locking</li> <li>Transactional Management: Use appropriate transaction boundaries</li> <li>Cache Wisely: Configure second-level cache for read-heavy entities</li> <li>Projection Over Full Entities: Use projections when you don't need all fields</li> <li>Query Method Naming: Follow the Spring Data naming conventions</li> </ol>"},{"location":"spring-boot/spring-boot-data-access/#transaction-management","title":"Transaction Management","text":"<p>Transactions ensure that database operations are executed reliably, following the ACID properties (Atomicity, Consistency, Isolation, Durability).</p>"},{"location":"spring-boot/spring-boot-data-access/#declarative-transaction-management","title":"Declarative Transaction Management","text":"<p>Spring's declarative transaction management using <code>@Transactional</code>:</p> <pre><code>@Service\n@Transactional\npublic class OrderService {\n\n    private final OrderRepository orderRepository;\n    private final ProductRepository productRepository;\n    private final InventoryRepository inventoryRepository;\n\n    // Constructor\n\n    // Inherits transaction from class-level annotation\n    public Order createOrder(OrderRequest request) {\n        // Check inventory\n        for (OrderItemRequest item : request.getItems()) {\n            Inventory inventory = inventoryRepository.findByProductId(item.getProductId())\n                    .orElseThrow(() -&gt; new RuntimeException(\"Product not in inventory\"));\n\n            if (inventory.getQuantity() &lt; item.getQuantity()) {\n                throw new InsufficientInventoryException(\"Not enough inventory\");\n            }\n        }\n\n        // Create order\n        Order order = new Order();\n        order.setCustomerId(request.getCustomerId());\n        order.setStatus(\"PENDING\");\n\n        Set&lt;OrderItem&gt; items = request.getItems().stream()\n                .map(this::createOrderItem)\n                .collect(Collectors.toSet());\n\n        order.setItems(items);\n        order.calculateTotal();\n\n        Order savedOrder = orderRepository.save(order);\n\n        // Update inventory\n        for (OrderItemRequest item : request.getItems()) {\n            inventoryRepository.decrementQuantity(item.getProductId(), item.getQuantity());\n        }\n\n        return savedOrder;\n    }\n\n    // Override class-level transaction settings\n    @Transactional(readOnly = true)\n    public Order findOrderById(Long id) {\n        return orderRepository.findById(id)\n                .orElseThrow(() -&gt; new OrderNotFoundException(\"Order not found\"));\n    }\n\n    // Custom transaction attributes\n    @Transactional(timeout = 5, propagation = Propagation.REQUIRES_NEW)\n    public void processPayment(Long orderId, PaymentRequest paymentRequest) {\n        // Process payment...\n    }\n\n    private OrderItem createOrderItem(OrderItemRequest itemRequest) {\n        Product product = productRepository.findById(itemRequest.getProductId())\n                .orElseThrow(() -&gt; new ProductNotFoundException(\"Product not found\"));\n\n        OrderItem item = new OrderItem();\n        item.setProduct(product);\n        item.setQuantity(itemRequest.getQuantity());\n        item.setPrice(product.getPrice());\n\n        return item;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#transaction-attributes","title":"Transaction Attributes","text":"<p>The <code>@Transactional</code> annotation supports several attributes:</p> <ul> <li>propagation: How transactions relate to each other</li> <li><code>REQUIRED</code>: Use current transaction or create new one (default)</li> <li><code>REQUIRES_NEW</code>: Always create a new transaction</li> <li><code>SUPPORTS</code>: Use current transaction if exists, otherwise non-transactional</li> <li><code>NOT_SUPPORTED</code>: Execute non-transactionally</li> <li><code>MANDATORY</code>: Must run within existing transaction</li> <li><code>NEVER</code>: Must not run within a transaction</li> <li> <p><code>NESTED</code>: Execute within nested transaction if one exists</p> </li> <li> <p>isolation: Transaction isolation level</p> </li> <li><code>DEFAULT</code>: Database default</li> <li><code>READ_UNCOMMITTED</code>: Dirty reads, non-repeatable reads, phantom reads possible</li> <li><code>READ_COMMITTED</code>: Dirty reads prevented, non-repeatable reads and phantom reads possible</li> <li><code>REPEATABLE_READ</code>: Dirty reads and non-repeatable reads prevented, phantom reads possible</li> <li> <p><code>SERIALIZABLE</code>: All concurrency issues prevented but lowest concurrency</p> </li> <li> <p>timeout: Transaction timeout (seconds)</p> </li> <li>readOnly: Hint to optimize read-only transactions</li> <li>rollbackFor: Exception types that trigger rollback</li> <li>noRollbackFor: Exception types that don't trigger rollback</li> </ul>"},{"location":"spring-boot/spring-boot-data-access/#programmatic-transaction-management","title":"Programmatic Transaction Management","text":"<p>For more control, use programmatic transaction management:</p> <pre><code>@Service\npublic class ManualTransactionService {\n\n    private final PlatformTransactionManager transactionManager;\n    private final OrderRepository orderRepository;\n\n    public ManualTransactionService(\n            PlatformTransactionManager transactionManager,\n            OrderRepository orderRepository) {\n        this.transactionManager = transactionManager;\n        this.orderRepository = orderRepository;\n    }\n\n    public void processOrdersInBatch(List&lt;OrderRequest&gt; orderRequests) {\n        TransactionDefinition definition = new DefaultTransactionDefinition();\n        TransactionStatus status = transactionManager.getTransaction(definition);\n\n        try {\n            for (OrderRequest request : orderRequests) {\n                // Process each order\n                Order order = createOrder(request);\n                if (!validateOrder(order)) {\n                    // If any order is invalid, roll back all\n                    transactionManager.rollback(status);\n                    return;\n                }\n            }\n\n            // If all successful, commit\n            transactionManager.commit(status);\n        } catch (Exception e) {\n            // Any exception causes rollback\n            transactionManager.rollback(status);\n            throw e;\n        }\n    }\n\n    private Order createOrder(OrderRequest request) {\n        // Create and save order...\n        return new Order();\n    }\n\n    private boolean validateOrder(Order order) {\n        // Validate order\n        return true;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#transaction-template","title":"Transaction Template","text":"<p>For a middle ground between declarative and programmatic approaches:</p> <pre><code>@Service\npublic class TransactionTemplateService {\n\n    private final TransactionTemplate transactionTemplate;\n    private final OrderRepository orderRepository;\n\n    public TransactionTemplateService(\n            PlatformTransactionManager transactionManager,\n            OrderRepository orderRepository) {\n        this.transactionTemplate = new TransactionTemplate(transactionManager);\n        this.orderRepository = orderRepository;\n    }\n\n    public Order createOrderWithTemplate(OrderRequest request) {\n        return transactionTemplate.execute(status -&gt; {\n            try {\n                Order order = new Order();\n                // Set order properties\n\n                // Save the order\n                Order savedOrder = orderRepository.save(order);\n\n                // Update inventory and other operations\n\n                return savedOrder;\n            } catch (Exception e) {\n                status.setRollbackOnly();\n                throw e;\n            }\n        });\n    }\n\n    public List&lt;Order&gt; findOrdersWithReadOnlyTransaction(Long customerId) {\n        TransactionTemplate readOnlyTx = new TransactionTemplate(transactionTemplate);\n        readOnlyTx.setReadOnly(true);\n\n        return readOnlyTx.execute(status -&gt; \n                orderRepository.findByCustomerId(customerId));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#distributed-transactions","title":"Distributed Transactions","text":"<p>For operations spanning multiple databases:</p> <pre><code>@Configuration\n@EnableTransactionManagement\npublic class DistributedTransactionConfig {\n\n    @Bean\n    public PlatformTransactionManager transactionManager() {\n        return new JtaTransactionManager();\n    }\n}\n\n@Service\n@Transactional\npublic class DistributedService {\n\n    private final MainRepository mainRepository;\n    private final AuditRepository auditRepository; // In different database\n\n    // Both operations will be part of the same distributed transaction\n    public void performDistributedOperation(Data data) {\n        mainRepository.save(data);\n        auditRepository.saveAuditLog(\"Data saved: \" + data.getId());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-data-access/#transaction-best-practices","title":"Transaction Best Practices","text":"<ol> <li>Keep Transactions Short: Long-running transactions can lead to lock contention</li> <li>Use Appropriate Isolation Level: Higher isolation levels reduce concurrency</li> <li>Consider Read-Only Transactions: Mark read-only operations for performance</li> <li>Watch Transaction Boundaries: Be aware of where transactions start and end</li> <li>Handle Exceptions Properly: Understand which exceptions trigger rollback</li> <li>Be Careful with Self-Invocation: Calls within same class bypass transaction proxy</li> <li>Avoid Unnecessary Transactions: Don't use transactions for simple operations</li> <li>Test Transaction Boundaries: Verify rollback behavior functions correctly</li> <li>Be Cautious with Distributed Transactions: They can significantly impact performance</li> <li>Monitor Transaction Performance: Watch transaction times and locking in production</li> </ol>"},{"location":"spring-boot/spring-boot-deployment/","title":"Macro Rendering Error","text":"<p>File: <code>spring-boot/spring-boot-deployment.md</code></p> <p>UndefinedError: 'secrets' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mkdocs_macros/plugin.py\", line 527, in render\n    return md_template.render(**page_variables)\n           ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 966, in top-level template code\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\njinja2.exceptions.UndefinedError: 'secrets' is undefined\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/","title":"Spring Boot RESTful API Development","text":""},{"location":"spring-boot/spring-boot-rest-api/#overview","title":"Overview","text":"<p>This guide explores how to build RESTful APIs using Spring Boot. It covers the fundamentals of REST architecture, implementing endpoints with Spring MVC's powerful annotations, handling requests and responses, validating input, documenting APIs, implementing HATEOAS, versioning strategies, security considerations, and testing methodologies. By following this guide, you'll learn how to create robust, scalable, and maintainable REST APIs that follow industry best practices.</p>"},{"location":"spring-boot/spring-boot-rest-api/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Java and Spring Boot</li> <li>Understanding of HTTP protocol fundamentals</li> <li>Familiarity with Spring core concepts (from spring-boot-core-concepts.md)</li> <li>Basic understanding of JSON and API design principles</li> <li>Development environment with Java and Maven/Gradle</li> </ul>"},{"location":"spring-boot/spring-boot-rest-api/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand REST architectural principles and constraints</li> <li>Implement RESTful endpoints using Spring MVC annotations</li> <li>Handle various HTTP methods and status codes appropriately</li> <li>Process request parameters, path variables, and request bodies</li> <li>Implement proper error handling and validation</li> <li>Configure content negotiation and message conversion</li> <li>Document APIs using OpenAPI/Swagger</li> <li>Implement HATEOAS for truly RESTful services</li> <li>Apply API versioning strategies</li> <li>Secure REST APIs</li> <li>Test REST endpoints effectively</li> </ul>"},{"location":"spring-boot/spring-boot-rest-api/#table-of-contents","title":"Table of Contents","text":"<ol> <li>REST Fundamentals</li> <li>Setting Up a REST API Project</li> <li>Creating REST Controllers</li> <li>Request Mapping and HTTP Methods</li> <li>Request and Response Handling</li> <li>Input Validation</li> <li>Exception Handling</li> <li>Content Negotiation</li> <li>API Documentation with OpenAPI/Swagger</li> <li>HATEOAS Implementation</li> <li>API Versioning Strategies</li> <li>REST API Security</li> <li>Testing REST APIs</li> <li>Performance Optimization</li> <li>Best Practices</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#rest-fundamentals","title":"REST Fundamentals","text":"<p>Representational State Transfer (REST) is an architectural style for designing networked applications. It was introduced by Roy Fielding in his 2000 doctoral dissertation and has become the predominant approach for building web APIs.</p>"},{"location":"spring-boot/spring-boot-rest-api/#what-is-rest","title":"What is REST?","text":"<p>REST is not a protocol or standard, but an architectural style that uses simple HTTP protocol for making calls between machines. In REST architecture, a REST Server provides access to resources, and a REST client accesses and modifies these resources using HTTP protocol.</p>"},{"location":"spring-boot/spring-boot-rest-api/#rest-architectural-constraints","title":"REST Architectural Constraints","text":"<p>A truly RESTful API adheres to the following six constraints:</p> <ol> <li>Client-Server Architecture</li> <li>Separation of concerns between client and server</li> <li>Clients are not concerned with data storage</li> <li>Servers are not concerned with user interface</li> <li> <p>Improves portability and scalability</p> </li> <li> <p>Statelessness</p> </li> <li>No client context is stored on the server between requests</li> <li>Each request contains all information necessary to serve it</li> <li>Session state is kept entirely on the client</li> <li> <p>Improves visibility, reliability, and scalability</p> </li> <li> <p>Cacheability</p> </li> <li>Responses must define themselves as cacheable or non-cacheable</li> <li>Caching eliminates some client-server interactions</li> <li> <p>Improves scalability and performance</p> </li> <li> <p>Uniform Interface</p> </li> <li>Resource identification in requests</li> <li>Resource manipulation through representations</li> <li>Self-descriptive messages</li> <li>Hypermedia as the engine of application state (HATEOAS)</li> <li> <p>Simplifies and decouples the architecture</p> </li> <li> <p>Layered System</p> </li> <li>Client cannot ordinarily tell if it is connected directly to the end server</li> <li>Intermediate servers can improve scalability</li> <li> <p>Layers can enforce security policies</p> </li> <li> <p>Code on Demand (optional)</p> </li> <li>Servers can temporarily extend client functionality by transferring executable code</li> <li>Simplifies clients by reducing the number of features required</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#restful-resources","title":"RESTful Resources","text":"<p>In REST, everything is a resource, which is any information that can be named: a document, an image, a service, a collection of resources, etc.</p> <p>Each resource is identified by a unique identifier, typically a URI in web-based REST systems.</p>"},{"location":"spring-boot/spring-boot-rest-api/#http-methods-and-crud-operations","title":"HTTP Methods and CRUD Operations","text":"<p>REST uses HTTP methods explicitly for resource operations:</p> HTTP Method CRUD Operation Description GET Read Retrieve a resource or collection of resources POST Create Create a new resource PUT Update Update an existing resource completely PATCH Update Update an existing resource partially DELETE Delete Delete a resource"},{"location":"spring-boot/spring-boot-rest-api/#http-status-codes","title":"HTTP Status Codes","text":"<p>Proper use of HTTP status codes is an important part of a RESTful API:</p> Code Range Category Examples 2xx Success 200 OK, 201 Created, 204 No Content 3xx Redirection 301 Moved Permanently, 304 Not Modified 4xx Client Error 400 Bad Request, 401 Unauthorized, 404 Not Found 5xx Server Error 500 Internal Server Error, 503 Service Unavailable"},{"location":"spring-boot/spring-boot-rest-api/#richardson-maturity-model","title":"Richardson Maturity Model","text":"<p>The Richardson Maturity Model describes the maturity of a RESTful API across four levels:</p> <ul> <li>Level 0: The Swamp of POX (Plain Old XML) - Uses HTTP as a transport protocol for remote interactions, typically with a single endpoint.</li> <li>Level 1: Resources - Introduces the concept of resources with individual URIs.</li> <li>Level 2: HTTP Verbs - Uses HTTP methods appropriately.</li> <li>Level 3: Hypermedia Controls - Implements HATEOAS by providing links to related resources within responses.</li> </ul>"},{"location":"spring-boot/spring-boot-rest-api/#rest-vs-soap","title":"REST vs SOAP","text":"Feature REST SOAP Style Architectural style Protocol Data Format Typically JSON/XML XML only Bandwidth Less usage (lightweight) More usage (XML overhead) Learning Curve Easy to learn and implement Steeper learning curve Caching Can leverage HTTP caching Requires custom implementation Security Uses HTTP security features Built-in security (WS-Security) State Stateless Can be stateful or stateless"},{"location":"spring-boot/spring-boot-rest-api/#json-and-rest","title":"JSON and REST","text":"<p>JavaScript Object Notation (JSON) has become the predominant data format for REST APIs due to its:</p> <ul> <li>Lightweight nature</li> <li>Human-readable format</li> <li>Language independence</li> <li>Easy parsing in JavaScript and other languages</li> <li>Support for common data types (strings, numbers, booleans, arrays, objects, null)</li> </ul> <p>Example JSON representation of a resource:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Product Name\",\n  \"price\": 29.99,\n  \"inStock\": true,\n  \"categories\": [\"electronics\", \"gadgets\"],\n  \"details\": {\n    \"description\": \"Product description\",\n    \"manufacturer\": \"Manufacturer name\"\n  }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#api-design-principles","title":"API Design Principles","text":"<p>When designing REST APIs, consider these principles:</p> <ol> <li>Use nouns, not verbs in endpoint paths</li> <li>Good: <code>/users</code>, <code>/users/123</code></li> <li> <p>Avoid: <code>/getUsers</code>, <code>/createUser</code></p> </li> <li> <p>Use plural nouns for collections</p> </li> <li> <p><code>/products</code> instead of <code>/product</code></p> </li> <li> <p>Use HTTP methods appropriately</p> </li> <li>Don't create endpoints like <code>/deleteUser/123</code></li> <li> <p>Instead use: <code>DELETE /users/123</code></p> </li> <li> <p>Use nested resources for relationships</p> </li> <li> <p><code>/users/123/orders</code> to get orders for user 123</p> </li> <li> <p>Use query parameters for filtering, sorting, and pagination</p> </li> <li> <p><code>/products?category=electronics&amp;sort=price&amp;page=2</code></p> </li> <li> <p>Be consistent</p> </li> <li> <p>Use consistent naming, plural/singular conventions, error formats, etc.</p> </li> <li> <p>Version your API</p> </li> <li><code>/v1/users</code>, <code>/v2/users</code> or using headers/parameters</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#setting-up-a-rest-api-project","title":"Setting Up a REST API Project","text":"<p>Creating a Spring Boot REST API project is straightforward. You can start with a minimal setup and expand as needed.</p>"},{"location":"spring-boot/spring-boot-rest-api/#using-spring-initializr","title":"Using Spring Initializr","text":"<p>The quickest way to set up a new Spring Boot REST API project is through the Spring Initializr:</p> <ol> <li>Go to start.spring.io</li> <li>Choose your project settings:</li> <li>Project: Maven or Gradle</li> <li>Language: Java</li> <li>Spring Boot version: Latest stable version</li> <li>Group: com.example</li> <li>Artifact: rest-api-demo</li> <li>Packaging: Jar</li> <li> <p>Java version: 17 (or your preferred version)</p> </li> <li> <p>Add the following dependencies:</p> </li> <li>Spring Web</li> <li>Spring Data JPA (if you need database access)</li> <li>H2 Database (for development/testing)</li> <li>Spring Boot DevTools (optional, for development)</li> <li>Validation</li> <li> <p>Lombok (optional, to reduce boilerplate code)</p> </li> <li> <p>Click \"Generate\" to download the project zip file</p> </li> <li>Extract the zip file and import it into your IDE</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#project-structure","title":"Project Structure","text":"<p>A typical Spring Boot REST API project follows this structure:</p> <pre><code>rest-api-demo/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 com/\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 example/\n\u2502   \u2502   \u2502           \u2514\u2500\u2500 restapidemo/\n\u2502   \u2502   \u2502               \u251c\u2500\u2500 RestApiDemoApplication.java\n\u2502   \u2502   \u2502               \u251c\u2500\u2500 controller/\n\u2502   \u2502   \u2502               \u251c\u2500\u2500 service/\n\u2502   \u2502   \u2502               \u251c\u2500\u2500 repository/\n\u2502   \u2502   \u2502               \u251c\u2500\u2500 model/ or domain/\n\u2502   \u2502   \u2502               \u251c\u2500\u2500 dto/\n\u2502   \u2502   \u2502               \u251c\u2500\u2500 exception/\n\u2502   \u2502   \u2502               \u2514\u2500\u2500 config/\n\u2502   \u2502   \u2514\u2500\u2500 resources/\n\u2502   \u2502       \u251c\u2500\u2500 application.properties\n\u2502   \u2502       \u251c\u2500\u2500 static/\n\u2502   \u2502       \u2514\u2500\u2500 templates/\n\u2502   \u2514\u2500\u2500 test/\n\u2502       \u2514\u2500\u2500 java/\n\u2502           \u2514\u2500\u2500 com/\n\u2502               \u2514\u2500\u2500 example/\n\u2502                   \u2514\u2500\u2500 restapidemo/\n\u2502                       \u251c\u2500\u2500 controller/\n\u2502                       \u2514\u2500\u2500 service/\n\u2514\u2500\u2500 pom.xml or build.gradle\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#maven-configuration-pomxml","title":"Maven Configuration (pom.xml)","text":"<p>A typical <code>pom.xml</code> for a Spring Boot REST API project:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.1.0&lt;/version&gt;\n        &lt;relativePath/&gt;\n    &lt;/parent&gt;\n\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;rest-api-demo&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;rest-api-demo&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot REST API&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;17&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;excludes&gt;\n                        &lt;exclude&gt;\n                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n                        &lt;/exclude&gt;\n                    &lt;/excludes&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#gradle-configuration-buildgradle","title":"Gradle Configuration (build.gradle)","text":"<p>A typical <code>build.gradle</code> for a Spring Boot REST API project:</p> <pre><code>plugins {\n    id 'java'\n    id 'org.springframework.boot' version '3.1.0'\n    id 'io.spring.dependency-management' version '1.1.0'\n}\n\ngroup = 'com.example'\nversion = '0.0.1-SNAPSHOT'\n\njava {\n    sourceCompatibility = '17'\n}\n\nconfigurations {\n    compileOnly {\n        extendsFrom annotationProcessor\n    }\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.boot:spring-boot-starter-validation'\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    compileOnly 'org.projectlombok:lombok'\n    developmentOnly 'org.springframework.boot:spring-boot-devtools'\n    runtimeOnly 'com.h2database:h2'\n    annotationProcessor 'org.projectlombok:lombok'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#application-properties","title":"Application Properties","text":"<p>Configure your application in <code>src/main/resources/application.properties</code>:</p> <pre><code># Server configuration\nserver.port=8080\nserver.servlet.context-path=/api\n\n# H2 Database configuration\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.driverClassName=org.h2.Driver\nspring.datasource.username=sa\nspring.datasource.password=password\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.h2.console.enabled=true\nspring.h2.console.path=/h2-console\n\n# JPA/Hibernate configuration\nspring.jpa.show-sql=true\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.properties.hibernate.format_sql=true\n\n# Jackson configuration\nspring.jackson.serialization.indent-output=true\nspring.jackson.default-property-inclusion=non_null\n\n# Logging configuration\nlogging.level.org.springframework.web=INFO\nlogging.level.org.hibernate=ERROR\nlogging.level.com.example=DEBUG\n</code></pre> <p>Or using YAML in <code>src/main/resources/application.yml</code>:</p> <pre><code>server:\n  port: 8080\n  servlet:\n    context-path: /api\n\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: password\n\n  jpa:\n    database-platform: org.hibernate.dialect.H2Dialect\n    show-sql: true\n    hibernate:\n      ddl-auto: update\n    properties:\n      hibernate:\n        format_sql: true\n\n  h2:\n    console:\n      enabled: true\n      path: /h2-console\n\n  jackson:\n    serialization:\n      indent-output: true\n    default-property-inclusion: non_null\n\nlogging:\n  level:\n    org.springframework.web: INFO\n    org.hibernate: ERROR\n    com.example: DEBUG\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#main-application-class","title":"Main Application Class","text":"<p>The main application class with <code>@SpringBootApplication</code> annotation:</p> <pre><code>package com.example.restapidemo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class RestApiDemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(RestApiDemoApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#domain-model","title":"Domain Model","text":"<p>Let's create a simple domain model for a product entity:</p> <pre><code>package com.example.restapidemo.model;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Positive;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.math.BigDecimal;\n\n@Entity\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @NotBlank(message = \"Product name is required\")\n    private String name;\n\n    private String description;\n\n    @NotNull(message = \"Price is required\")\n    @Positive(message = \"Price must be positive\")\n    private BigDecimal price;\n\n    private boolean inStock;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#repository-interface","title":"Repository Interface","text":"<p>Create a repository interface using Spring Data JPA:</p> <pre><code>package com.example.restapidemo.repository;\n\nimport com.example.restapidemo.model.Product;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n\n    List&lt;Product&gt; findByNameContainingIgnoreCase(String name);\n\n    List&lt;Product&gt; findByInStockTrue();\n}\n</code></pre> <p>With this setup, you're ready to start implementing REST controllers and services for your API. The following sections will guide you through creating controllers, handling requests and responses, validating input, and implementing other important aspects of a robust REST API.</p>"},{"location":"spring-boot/spring-boot-rest-api/#creating-rest-controllers","title":"Creating REST Controllers","text":"<p>In Spring Boot, REST controllers handle HTTP requests and produce responses. They are the entry point to your API and map client requests to your business logic.</p>"},{"location":"spring-boot/spring-boot-rest-api/#controller-basics","title":"Controller Basics","text":"<p>To create a REST controller, use the <code>@RestController</code> annotation, which combines <code>@Controller</code> and <code>@ResponseBody</code> annotations:</p> <pre><code>package com.example.restapidemo.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello, REST API!\";\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#understanding-key-annotations","title":"Understanding Key Annotations","text":"<p>Spring MVC provides several key annotations for building REST controllers:</p> <ol> <li>@RestController: Marks the class as a REST controller where every method returns a domain object instead of a view</li> <li>@RequestMapping: Maps HTTP requests to handler methods</li> <li>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping: Shortcuts for @RequestMapping with specific HTTP methods</li> <li>@PathVariable: Extracts values from the URI path</li> <li>@RequestParam: Extracts query parameters</li> <li>@RequestBody: Maps the HTTP request body to a domain object</li> <li>@ResponseStatus: Specifies the HTTP status code to return</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#building-a-crud-controller","title":"Building a CRUD Controller","text":"<p>Here's a complete CRUD (Create, Read, Update, Delete) controller for our Product entity:</p> <pre><code>package com.example.restapidemo.controller;\n\nimport com.example.restapidemo.model.Product;\nimport com.example.restapidemo.service.ProductService;\nimport jakarta.validation.Valid;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    private final ProductService productService;\n\n    // Constructor injection\n    public ProductController(ProductService productService) {\n        this.productService = productService;\n    }\n\n    // GET /products - Get all products\n    @GetMapping\n    public List&lt;Product&gt; getAllProducts() {\n        return productService.findAllProducts();\n    }\n\n    // GET /products/{id} - Get a product by ID\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Product&gt; getProductById(@PathVariable Long id) {\n        return productService.findProductById(id)\n                .map(ResponseEntity::ok)\n                .orElse(ResponseEntity.notFound().build());\n    }\n\n    // POST /products - Create a new product\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public Product createProduct(@Valid @RequestBody Product product) {\n        return productService.saveProduct(product);\n    }\n\n    // PUT /products/{id} - Update a product completely\n    @PutMapping(\"/{id}\")\n    public ResponseEntity&lt;Product&gt; updateProduct(\n            @PathVariable Long id, \n            @Valid @RequestBody Product product) {\n\n        return productService.findProductById(id)\n                .map(existingProduct -&gt; {\n                    product.setId(id);\n                    return ResponseEntity.ok(productService.saveProduct(product));\n                })\n                .orElse(ResponseEntity.notFound().build());\n    }\n\n    // PATCH /products/{id} - Update a product partially\n    @PatchMapping(\"/{id}\")\n    public ResponseEntity&lt;Product&gt; partialUpdateProduct(\n            @PathVariable Long id, \n            @RequestBody Product productUpdates) {\n\n        return productService.findProductById(id)\n                .map(existingProduct -&gt; {\n                    // Update only non-null fields\n                    if (productUpdates.getName() != null) {\n                        existingProduct.setName(productUpdates.getName());\n                    }\n                    if (productUpdates.getDescription() != null) {\n                        existingProduct.setDescription(productUpdates.getDescription());\n                    }\n                    if (productUpdates.getPrice() != null) {\n                        existingProduct.setPrice(productUpdates.getPrice());\n                    }\n                    // Boolean is a primitive, so it's always updated\n                    existingProduct.setInStock(productUpdates.isInStock());\n\n                    return ResponseEntity.ok(productService.saveProduct(existingProduct));\n                })\n                .orElse(ResponseEntity.notFound().build());\n    }\n\n    // DELETE /products/{id} - Delete a product\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteProduct(@PathVariable Long id) {\n        return productService.findProductById(id)\n                .map(product -&gt; {\n                    productService.deleteProductById(id);\n                    return ResponseEntity.noContent().&lt;Void&gt;build();\n                })\n                .orElse(ResponseEntity.notFound().build());\n    }\n\n    // GET /products/search - Search products by name\n    @GetMapping(\"/search\")\n    public List&lt;Product&gt; searchProducts(@RequestParam String name) {\n        return productService.findProductsByName(name);\n    }\n\n    // GET /products/in-stock - Get products in stock\n    @GetMapping(\"/in-stock\")\n    public List&lt;Product&gt; getProductsInStock() {\n        return productService.findProductsInStock();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#service-layer","title":"Service Layer","text":"<p>The controller should delegate business logic to a service layer:</p> <pre><code>package com.example.restapidemo.service;\n\nimport com.example.restapidemo.model.Product;\nimport com.example.restapidemo.repository.ProductRepository;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class ProductService {\n\n    private final ProductRepository productRepository;\n\n    public ProductService(ProductRepository productRepository) {\n        this.productRepository = productRepository;\n    }\n\n    public List&lt;Product&gt; findAllProducts() {\n        return productRepository.findAll();\n    }\n\n    public Optional&lt;Product&gt; findProductById(Long id) {\n        return productRepository.findById(id);\n    }\n\n    public Product saveProduct(Product product) {\n        return productRepository.save(product);\n    }\n\n    public void deleteProductById(Long id) {\n        productRepository.deleteById(id);\n    }\n\n    public List&lt;Product&gt; findProductsByName(String name) {\n        return productRepository.findByNameContainingIgnoreCase(name);\n    }\n\n    public List&lt;Product&gt; findProductsInStock() {\n        return productRepository.findByInStockTrue();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#different-response-types","title":"Different Response Types","text":"<p>REST controllers can return various types that Spring automatically converts to HTTP responses:</p>"},{"location":"spring-boot/spring-boot-rest-api/#1-domain-objects","title":"1. Domain Objects","text":"<p>Spring automatically converts them to JSON (or XML if configured):</p> <pre><code>@GetMapping(\"/{id}\")\npublic Product getProduct(@PathVariable Long id) {\n    return productService.findProductById(id)\n            .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product not found\"));\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#2-collections","title":"2. Collections","text":"<p>Lists, Sets, or Maps are automatically converted to JSON arrays:</p> <pre><code>@GetMapping\npublic List&lt;Product&gt; getAllProducts() {\n    return productService.findAllProducts();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#3-responseentity","title":"3. ResponseEntity","text":"<p>Gives you control over the HTTP response status codes, headers, and body:</p> <pre><code>@GetMapping(\"/{id}\")\npublic ResponseEntity&lt;ProductResponseDto&gt; getProductById(@PathVariable Long id) {\n    return productService.findById(id)\n            .map(product -&gt; {\n                ProductResponseDto dto = productMapper.toDto(product);\n                return ResponseEntity.ok()\n                        .header(\"Custom-Header\", \"Value\")\n                        .body(dto);\n            })\n            .orElse(ResponseEntity.notFound().build());\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#4-void-with-responsestatus","title":"4. Void with @ResponseStatus","text":"<p>When you don't need to return a body:</p> <pre><code>@DeleteMapping(\"/{id}\")\n@ResponseStatus(HttpStatus.NO_CONTENT)\npublic void deleteProduct(@PathVariable Long id) {\n    productService.deleteProductById(id);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#organizing-controllers","title":"Organizing Controllers","text":"<p>For larger applications, organize controllers logically:</p>"},{"location":"spring-boot/spring-boot-rest-api/#by-resource","title":"By Resource","text":"<p>Each controller handles operations for a specific resource:</p> <pre><code>com.example.controller\n\u251c\u2500\u2500 ProductController.java\n\u251c\u2500\u2500 CustomerController.java\n\u251c\u2500\u2500 OrderController.java\n\u2514\u2500\u2500 PaymentController.java\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#by-functionality","title":"By Functionality","text":"<p>Group controllers by functionality area:</p> <pre><code>com.example.controller\n\u251c\u2500\u2500 admin\n\u2502   \u251c\u2500\u2500 AdminProductController.java\n\u2502   \u2514\u2500\u2500 AdminUserController.java\n\u251c\u2500\u2500 customer\n\u2502   \u251c\u2500\u2500 CustomerProductController.java\n\u2502   \u2514\u2500\u2500 CustomerOrderController.java\n\u2514\u2500\u2500 public\n    \u2514\u2500\u2500 PublicProductController.java\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#controller-best-practices","title":"Controller Best Practices","text":"<ol> <li>Keep controllers thin: Delegate business logic to services</li> <li>Use proper HTTP methods: GET for reading, POST for creating, PUT/PATCH for updating, DELETE for removing</li> <li>Return appropriate status codes: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 404 Not Found, etc.</li> <li>Use DTOs for request/response: Separate your API model from your domain model</li> <li>Validate input: Use JSR-380 annotations for validation</li> <li>Handle exceptions centrally: Use @ControllerAdvice for global exception handling</li> <li>Document your API: Add OpenAPI/Swagger annotations</li> <li>Use meaningful URI paths: Follow REST naming conventions</li> <li>Implement pagination: For collections that can grow large</li> <li>Version your API: Allow for evolution without breaking clients</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#request-mapping-and-http-methods","title":"Request Mapping and HTTP Methods","text":"<p>Request mapping is a crucial aspect of Spring MVC that links HTTP requests to controller methods. Proper mapping ensures that your API follows RESTful conventions and is intuitive to use.</p>"},{"location":"spring-boot/spring-boot-rest-api/#request-mapping-basics","title":"Request Mapping Basics","text":"<p>The <code>@RequestMapping</code> annotation maps web requests to controller methods. It can be applied at both the class and method levels:</p> <pre><code>@RestController\n@RequestMapping(\"/api/v1/products\")  // Base path for all methods in this controller\npublic class ProductController {\n\n    @RequestMapping(method = RequestMethod.GET)  // Maps to GET /api/v1/products\n    public List&lt;Product&gt; getAllProducts() {\n        // ...\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.GET)  // Maps to GET /api/v1/products/{id}\n    public Product getProductById(@PathVariable Long id) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#http-method-specific-annotations","title":"HTTP Method-Specific Annotations","text":"<p>Spring provides dedicated annotations for each HTTP method, which are more concise and readable than using <code>@RequestMapping</code> with a method parameter:</p> <pre><code>@RestController\n@RequestMapping(\"/api/v1/products\")\npublic class ProductController {\n\n    @GetMapping  // Equivalent to @RequestMapping(method = RequestMethod.GET)\n    public List&lt;Product&gt; getAllProducts() {\n        // ...\n    }\n\n    @GetMapping(\"/{id}\")  // Equivalent to @RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public Product getProductById(@PathVariable Long id) {\n        // ...\n    }\n\n    @PostMapping  // Maps to POST /api/v1/products\n    public Product createProduct(@RequestBody Product product) {\n        // ...\n    }\n\n    @PutMapping(\"/{id}\")  // Maps to PUT /api/v1/products/{id}\n    public Product updateProduct(@PathVariable Long id, @RequestBody Product product) {\n        // ...\n    }\n\n    @PatchMapping(\"/{id}\")  // Maps to PATCH /api/v1/products/{id}\n    public Product partialUpdateProduct(@PathVariable Long id, @RequestBody Product product) {\n        // ...\n    }\n\n    @DeleteMapping(\"/{id}\")  // Maps to DELETE /api/v1/products/{id}\n    public void deleteProduct(@PathVariable Long id) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#url-patterns-and-path-variables","title":"URL Patterns and Path Variables","text":"<p>Path variables are dynamic parts of the URL enclosed in curly braces. They are extracted using the <code>@PathVariable</code> annotation:</p> <pre><code>@GetMapping(\"/{id}\")\npublic Product getProductById(@PathVariable Long id) {\n    // The 'id' parameter is bound to the {id} in the URL\n    return productService.findById(id);\n}\n\n// Multiple path variables\n@GetMapping(\"/categories/{categoryId}/products/{productId}\")\npublic Product getProductFromCategory(\n        @PathVariable Long categoryId, \n        @PathVariable Long productId) {\n    return productService.findByCategoryAndId(categoryId, productId);\n}\n\n// Custom path variable name\n@GetMapping(\"/users/{userId}/orders/{orderId}\")\npublic Order getOrder(\n        @PathVariable(\"userId\") Long userIdentifier, \n        @PathVariable(\"orderId\") Long orderIdentifier) {\n    return orderService.findByUserAndOrder(userIdentifier, orderIdentifier);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#request-parameters","title":"Request Parameters","text":"<p>Query string parameters are accessed with the <code>@RequestParam</code> annotation:</p> <pre><code>// Required parameter - /products/search?name=Laptop\n@GetMapping(\"/search\")\npublic List&lt;Product&gt; searchProducts(@RequestParam String name) {\n    return productService.findByName(name);\n}\n\n// Optional parameter with default value - /products/filter?minPrice=100&amp;maxPrice=500&amp;inStock=true\n@GetMapping(\"/filter\")\npublic List&lt;Product&gt; filterProducts(\n        @RequestParam(defaultValue = \"0\") BigDecimal minPrice,\n        @RequestParam(defaultValue = \"10000\") BigDecimal maxPrice,\n        @RequestParam(defaultValue = \"false\") boolean inStock) {\n    return productService.filterProducts(minPrice, maxPrice, inStock);\n}\n\n// Multiple values - /products/byCategories?category=Electronics&amp;category=Computers\n@GetMapping(\"/byCategories\")\npublic List&lt;Product&gt; getProductsByCategories(@RequestParam List&lt;String&gt; category) {\n    return productService.findByCategories(category);\n}\n\n// Map of params - /products/custom?param1=value1&amp;param2=value2\n@GetMapping(\"/custom\")\npublic List&lt;Product&gt; customSearch(@RequestParam Map&lt;String, String&gt; params) {\n    return productService.customSearch(params);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#request-headers","title":"Request Headers","text":"<p>Access HTTP headers using the <code>@RequestHeader</code> annotation:</p> <pre><code>@GetMapping(\"/with-header\")\npublic String withHeader(@RequestHeader(\"User-Agent\") String userAgent) {\n    return \"Request with User-Agent: \" + userAgent;\n}\n\n// Optional header\n@GetMapping(\"/optional-header\")\npublic String withOptionalHeader(\n        @RequestHeader(value = \"Optional-Header\", required = false) String optionalHeader) {\n    if (optionalHeader != null) {\n        return \"Header value: \" + optionalHeader;\n    }\n    return \"No header provided\";\n}\n\n// All headers\n@GetMapping(\"/all-headers\")\npublic Map&lt;String, String&gt; getAllHeaders(@RequestHeader Map&lt;String, String&gt; headers) {\n    return headers;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#consuming-and-producing-media-types","title":"Consuming and Producing Media Types","text":"<p>Specify what media types your methods can consume and produce:</p> <pre><code>@PostMapping(\n    value = \"/upload\",\n    consumes = MediaType.MULTIPART_FORM_DATA_VALUE\n)\npublic String uploadFile(@RequestParam(\"file\") MultipartFile file) {\n    // Handle file upload\n    return \"File uploaded: \" + file.getOriginalFilename();\n}\n\n@GetMapping(\n    value = \"/{id}\",\n    produces = MediaType.APPLICATION_JSON_VALUE\n)\npublic Product getProductJson(@PathVariable Long id) {\n    return productService.findById(id);\n}\n\n@GetMapping(\n    value = \"/{id}\",\n    produces = MediaType.APPLICATION_XML_VALUE\n)\npublic Product getProductXml(@PathVariable Long id) {\n    return productService.findById(id);\n}\n\n// Support multiple media types\n@PostMapping(\n    consumes = {\n        MediaType.APPLICATION_JSON_VALUE,\n        MediaType.APPLICATION_XML_VALUE\n    },\n    produces = MediaType.APPLICATION_JSON_VALUE\n)\npublic Product createProduct(@RequestBody Product product) {\n    return productService.save(product);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#content-negotiation","title":"Content Negotiation","text":"<p>Spring Boot supports content negotiation, allowing clients to specify the desired response format:</p> <pre><code>@GetMapping(\n    value = \"/{id}\",\n    produces = {\n        MediaType.APPLICATION_JSON_VALUE,\n        MediaType.APPLICATION_XML_VALUE\n    }\n)\npublic Product getProduct(@PathVariable Long id) {\n    return productService.findById(id);\n}\n</code></pre> <p>Clients can request different formats using: - The <code>Accept</code> header: <code>Accept: application/xml</code> - Format extension: <code>/products/123.xml</code> - Query parameter: <code>/products/123?format=xml</code></p>"},{"location":"spring-boot/spring-boot-rest-api/#matrix-variables","title":"Matrix Variables","text":"<p>Matrix variables are name-value pairs embedded in the path segment:</p> <pre><code>// URL: /products/filter;minPrice=100;maxPrice=500;brand=Samsung,Apple\n@GetMapping(\"/filter\")\npublic List&lt;Product&gt; findProducts(\n        @MatrixVariable(defaultValue = \"0\") int minPrice,\n        @MatrixVariable(defaultValue = \"10000\") int maxPrice,\n        @MatrixVariable List&lt;String&gt; brand) {\n    return productService.findByPriceAndBrands(minPrice, maxPrice, brand);\n}\n\n// Multiple path segments with matrix variables\n// URL: /products/price;range=100-500/brand;names=Samsung,Apple\n@GetMapping(\"/products/{priceSegment}/{brandSegment}\")\npublic List&lt;Product&gt; findByPriceAndBrand(\n        @MatrixVariable(name = \"range\", pathVar = \"priceSegment\") String priceRange,\n        @MatrixVariable(name = \"names\", pathVar = \"brandSegment\") List&lt;String&gt; brands) {\n    // Parse priceRange (e.g., \"100-500\") and use with brands\n    String[] prices = priceRange.split(\"-\");\n    int min = Integer.parseInt(prices[0]);\n    int max = Integer.parseInt(prices[1]);\n    return productService.findByPriceRangeAndBrands(min, max, brands);\n}\n</code></pre> <p>To enable matrix variables, you need to configure a <code>WebMvcConfigurer</code>:</p> <pre><code>@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) {\n        UrlPathHelper urlPathHelper = new UrlPathHelper();\n        urlPathHelper.setRemoveSemicolonContent(false);\n        configurer.setUrlPathHelper(urlPathHelper);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#handling-http-methods","title":"Handling HTTP Methods","text":"<p>Each HTTP method has a specific purpose in a RESTful API:</p>"},{"location":"spring-boot/spring-boot-rest-api/#get","title":"GET","text":"<p>Used to retrieve information and should be idempotent (multiple identical requests should have the same effect).</p> <pre><code>@GetMapping\npublic List&lt;Product&gt; getAllProducts() {\n    return productService.findAll();\n}\n\n@GetMapping(\"/{id}\")\npublic ResponseEntity&lt;ProductResponseDto&gt; getProductById(@PathVariable Long id) {\n    return productService.findById(id)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#post","title":"POST","text":"<p>Used to create a new resource. Not idempotent - multiple identical POST requests will create multiple resources.</p> <pre><code>@PostMapping\n@ResponseStatus(HttpStatus.CREATED)\npublic Product createProduct(@Valid @RequestBody Product product) {\n    return productService.save(product);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#put","title":"PUT","text":"<p>Used to update or replace an existing resource or create it if it doesn't exist. Should be idempotent.</p> <pre><code>@PutMapping(\"/{id}\")\npublic ResponseEntity&lt;Product&gt; updateProduct(\n        @PathVariable Long id, \n        @Valid @RequestBody Product product) {\n\n    product.setId(id);\n    Product updatedProduct = productService.update(product);\n\n    return ResponseEntity.ok(updatedProduct);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#patch","title":"PATCH","text":"<p>Used for partial updates to a resource. May or may not be idempotent.</p> <pre><code>@PatchMapping(\"/{id}\")\npublic ResponseEntity&lt;Product&gt; partialUpdateProduct(\n        @PathVariable Long id, \n        @RequestBody Map&lt;String, Object&gt; updates) {\n\n    Product product = productService.findById(id)\n            .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product not found\"));\n\n    // Apply partial updates\n    if (updates.containsKey(\"name\")) {\n        product.setName((String) updates.get(\"name\"));\n    }\n    if (updates.containsKey(\"price\")) {\n        product.setPrice(new BigDecimal(updates.get(\"price\").toString()));\n    }\n    // ... other fields\n\n    Product updatedProduct = productService.save(product);\n    return ResponseEntity.ok(updatedProduct);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#delete","title":"DELETE","text":"<p>Used to delete a resource. Idempotent - multiple DELETE requests to the same resource should have the same effect.</p> <pre><code>@DeleteMapping(\"/{id}\")\npublic ResponseEntity&lt;Void&gt; deleteProduct(@PathVariable Long id) {\n    boolean deleted = productService.deleteById(id);\n\n    if (deleted) {\n        return ResponseEntity.noContent().build();\n    } else {\n        return ResponseEntity.notFound().build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#customizing-url-mappings","title":"Customizing URL Mappings","text":"<p>Spring MVC provides various ways to customize URL mappings:</p>"},{"location":"spring-boot/spring-boot-rest-api/#regex-in-path-variables","title":"Regex in Path Variables","text":"<pre><code>@GetMapping(\"/{id:[0-9]+}\")\npublic Product getProductById(@PathVariable Long id) {\n    return productService.findById(id);\n}\n\n@GetMapping(\"/{sku:[A-Z]{2}-[0-9]{6}}\")\npublic Product getProductBySku(@PathVariable String sku) {\n    return productService.findBySku(sku);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#ant-style-path-patterns","title":"Ant-Style Path Patterns","text":"<pre><code>@GetMapping(\"/images/**\")\npublic List&lt;String&gt; getProductImages() {\n    return productService.getAllImages();\n}\n\n@GetMapping(\"/public/?\")\npublic String getSingleCharPath(@PathVariable String path) {\n    return \"Path: \" + path;\n}\n\n@GetMapping(\"/*.json\")\npublic String getJsonEndpoint() {\n    return \"JSON endpoint\";\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#best-practices-for-request-mapping","title":"Best Practices for Request Mapping","text":"<ol> <li>Use proper HTTP methods: Follow RESTful conventions.</li> <li>Use meaningful resource paths: <code>/users/{id}/orders</code> is more intuitive than <code>/get-orders-by-user-id/{id}</code>.</li> <li>Keep URLs clean: Use query parameters for filtering, sorting, and pagination.</li> <li>Use plural nouns for collections: <code>/products</code> instead of <code>/product</code>.</li> <li>Be consistent with naming: Choose a convention for case (e.g., kebab-case) and stick to it.</li> <li>Structure API hierarchically: Represent resource relationships in the URL structure.</li> <li>Versioning: Include API version in the URL or headers.</li> <li>Use status codes properly: 200 for success, 201 for creation, 204 for deletion, etc.</li> <li>Make URLs predictable: Follow consistent patterns across your API.</li> <li>Keep URLs relatively short: Don't go overboard with nested paths.</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#request-and-response-handling","title":"Request and Response Handling","text":"<p>Properly handling HTTP requests and responses is crucial for building robust REST APIs. Spring Boot provides powerful tools for processing request data and formatting responses.</p>"},{"location":"spring-boot/spring-boot-rest-api/#handling-request-bodies","title":"Handling Request Bodies","text":"<p>The <code>@RequestBody</code> annotation maps the HTTP request body to a Java object:</p> <pre><code>@PostMapping\npublic ResponseEntity&lt;Product&gt; createProduct(@RequestBody Product product) {\n    Product savedProduct = productService.save(product);\n    return ResponseEntity.status(HttpStatus.CREATED).body(savedProduct);\n}\n</code></pre> <p>Spring automatically deserializes the incoming JSON (or XML) to your object using HTTP message converters.</p>"},{"location":"spring-boot/spring-boot-rest-api/#data-transfer-objects-dtos","title":"Data Transfer Objects (DTOs)","text":"<p>It's often better to use dedicated DTOs instead of domain entities for API requests and responses:</p> <pre><code>// DTO for product creation requests\npublic class ProductCreateDto {\n    @NotBlank\n    private String name;\n\n    private String description;\n\n    @NotNull\n    @Positive\n    private BigDecimal price;\n\n    private boolean inStock;\n\n    // Getters and setters\n}\n\n// DTO for product responses\npublic class ProductResponseDto {\n    private Long id;\n    private String name;\n    private String description;\n    private BigDecimal price;\n    private boolean inStock;\n    private LocalDateTime createdAt;\n    private LocalDateTime updatedAt;\n\n    // Getters and setters\n}\n\n@PostMapping\npublic ResponseEntity&lt;ProductResponseDto&gt; createProduct(@Valid @RequestBody ProductCreateDto productDto) {\n    // Convert DTO to entity\n    Product product = new Product();\n    product.setName(productDto.getName());\n    product.setDescription(productDto.getDescription());\n    product.setPrice(productDto.getPrice());\n    product.setInStock(productDto.isInStock());\n\n    // Save entity\n    Product savedProduct = productService.save(product);\n\n    // Convert entity to response DTO\n    ProductResponseDto responseDto = new ProductResponseDto();\n    responseDto.setId(savedProduct.getId());\n    responseDto.setName(savedProduct.getName());\n    responseDto.setDescription(savedProduct.getDescription());\n    responseDto.setPrice(savedProduct.getPrice());\n    responseDto.setInStock(savedProduct.isInStock());\n    responseDto.setCreatedAt(savedProduct.getCreatedAt());\n    responseDto.setUpdatedAt(savedProduct.getUpdatedAt());\n\n    return ResponseEntity.status(HttpStatus.CREATED).body(responseDto);\n}\n</code></pre> <p>Using a mapping library like MapStruct or ModelMapper can simplify this conversion:</p> <pre><code>@Mapper(componentModel = \"spring\")\npublic interface ProductMapper {\n    ProductResponseDto toDto(Product product);\n    Product toEntity(ProductCreateDto dto);\n}\n\n@PostMapping\npublic ResponseEntity&lt;ProductResponseDto&gt; createProduct(@Valid @RequestBody ProductCreateDto productDto) {\n    Product product = productMapper.toEntity(productDto);\n    Product savedProduct = productService.save(product);\n    ProductResponseDto responseDto = productMapper.toDto(savedProduct);\n    return ResponseEntity.status(HttpStatus.CREATED).body(responseDto);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#responseentity","title":"ResponseEntity","text":"<p>The <code>ResponseEntity</code> class gives you control over HTTP response status codes, headers, and body:</p> <pre><code>@GetMapping(\"/{id}\")\npublic ResponseEntity&lt;ProductResponseDto&gt; getProductById(@PathVariable Long id) {\n    return productService.findById(id)\n            .map(product -&gt; {\n                ProductResponseDto dto = productMapper.toDto(product);\n                return ResponseEntity.ok()\n                        .header(\"Custom-Header\", \"Value\")\n                        .body(dto);\n            })\n            .orElse(ResponseEntity.notFound().build());\n}\n\n// Returning different status codes\n@PostMapping\npublic ResponseEntity&lt;ProductResponseDto&gt; createProduct(@Valid @RequestBody ProductCreateDto productDto) {\n    Product product = productMapper.toEntity(productDto);\n    Product savedProduct = productService.save(product);\n    ProductResponseDto responseDto = productMapper.toDto(savedProduct);\n\n    URI location = ServletUriComponentsBuilder\n            .fromCurrentRequest()\n            .path(\"/{id}\")\n            .buildAndExpand(savedProduct.getId())\n            .toUri();\n\n    return ResponseEntity.created(location).body(responseDto);\n}\n\n// Conditional responses\n@GetMapping(\"/{id}\")\npublic ResponseEntity&lt;ProductResponseDto&gt; getProductWithETag(\n        @PathVariable Long id,\n        @RequestHeader(value = \"If-None-Match\", required = false) String ifNoneMatch) {\n\n    Optional&lt;Product&gt; productOpt = productService.findById(id);\n\n    if (productOpt.isEmpty()) {\n        return ResponseEntity.notFound().build();\n    }\n\n    Product product = productOpt.get();\n    String eTag = \"\\\"\" + product.getVersion() + \"\\\"\";\n\n    if (eTag.equals(ifNoneMatch)) {\n        return ResponseEntity.status(HttpStatus.NOT_MODIFIED).build();\n    }\n\n    ProductResponseDto dto = productMapper.toDto(product);\n    return ResponseEntity.ok()\n            .eTag(eTag)\n            .body(dto);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#customizing-response-status-codes","title":"Customizing Response Status Codes","text":"<p>Besides <code>ResponseEntity</code>, you can use <code>@ResponseStatus</code> to customize response status codes:</p> <pre><code>@PostMapping\n@ResponseStatus(HttpStatus.CREATED)\npublic ProductResponseDto createProduct(@Valid @RequestBody ProductCreateDto productDto) {\n    Product product = productMapper.toEntity(productDto);\n    Product savedProduct = productService.save(product);\n    return productMapper.toDto(savedProduct);\n}\n\n@DeleteMapping(\"/{id}\")\n@ResponseStatus(HttpStatus.NO_CONTENT)\npublic void deleteProduct(@PathVariable Long id) {\n    productService.deleteById(id);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#response-headers","title":"Response Headers","text":"<p>Adding custom headers to your responses:</p> <pre><code>@GetMapping(\"/{id}\")\npublic ResponseEntity&lt;ProductResponseDto&gt; getProductWithHeaders(@PathVariable Long id) {\n    return productService.findById(id)\n            .map(product -&gt; {\n                ProductResponseDto dto = productMapper.toDto(product);\n\n                return ResponseEntity.ok()\n                        .header(\"X-Custom-Header\", \"Value\")\n                        .header(\"Cache-Control\", \"max-age=3600\")\n                        .lastModified(product.getUpdatedAt().toEpochMilli())\n                        .body(dto);\n            })\n            .orElse(ResponseEntity.notFound().build());\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#working-with-file-uploads","title":"Working with File Uploads","text":"<p>Handling file uploads in REST APIs:</p> <pre><code>@PostMapping(\"/upload\")\npublic ResponseEntity&lt;String&gt; uploadFile(@RequestParam(\"file\") MultipartFile file) {\n    if (file.isEmpty()) {\n        return ResponseEntity.badRequest().body(\"Please upload a file\");\n    }\n\n    try {\n        // Save the file\n        String fileName = StringUtils.cleanPath(file.getOriginalFilename());\n        Path targetLocation = Paths.get(\"uploads\").resolve(fileName);\n        Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);\n\n        return ResponseEntity.ok(\"File uploaded successfully: \" + fileName);\n    } catch (IOException ex) {\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"Could not upload file: \" + ex.getMessage());\n    }\n}\n\n// Multiple file upload\n@PostMapping(\"/upload-multiple\")\npublic ResponseEntity&lt;List&lt;String&gt;&gt; uploadMultipleFiles(@RequestParam(\"files\") MultipartFile[] files) {\n    List&lt;String&gt; uploadedFiles = new ArrayList&lt;&gt;();\n\n    for (MultipartFile file : files) {\n        if (!file.isEmpty()) {\n            try {\n                String fileName = StringUtils.cleanPath(file.getOriginalFilename());\n                Path targetLocation = Paths.get(\"uploads\").resolve(fileName);\n                Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);\n                uploadedFiles.add(fileName);\n            } catch (IOException ex) {\n                // Log exception\n            }\n        }\n    }\n\n    return ResponseEntity.ok(uploadedFiles);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#file-downloads","title":"File Downloads","text":"<p>Handling file downloads in REST APIs:</p> <pre><code>@GetMapping(\"/download/{fileName:.+}\")\npublic ResponseEntity&lt;Resource&gt; downloadFile(@PathVariable String fileName, HttpServletRequest request) {\n    // Load file as Resource\n    Path filePath = Paths.get(\"uploads\").resolve(fileName).normalize();\n    Resource resource;\n\n    try {\n        resource = new UrlResource(filePath.toUri());\n\n        if (resource.exists()) {\n            // Determine content type\n            String contentType = request.getServletContext().getMimeType(resource.getFile().getAbsolutePath());\n\n            if (contentType == null) {\n                contentType = \"application/octet-stream\";\n            }\n\n            return ResponseEntity.ok()\n                    .contentType(MediaType.parseMediaType(contentType))\n                    .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + resource.getFilename() + \"\\\"\")\n                    .body(resource);\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    } catch (IOException ex) {\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#streaming-responses","title":"Streaming Responses","text":"<p>For large responses, streaming can be more efficient:</p> <pre><code>@GetMapping(value = \"/stream\", produces = MediaType.APPLICATION_JSON_VALUE)\npublic ResponseEntity&lt;StreamingResponseBody&gt; streamData() {\n    StreamingResponseBody responseBody = outputStream -&gt; {\n        for (int i = 0; i &lt; 1000; i++) {\n            Product product = productService.generateRandomProduct();\n            String jsonProduct = objectMapper.writeValueAsString(product);\n            outputStream.write(jsonProduct.getBytes());\n            outputStream.write(\"\\n\".getBytes());\n            outputStream.flush();\n\n            // Simulate processing time\n            Thread.sleep(10);\n        }\n    };\n\n    return ResponseEntity.ok()\n            .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n            .body(responseBody);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>For real-time updates to clients:</p> <pre><code>@GetMapping(value = \"/sse-events\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\npublic SseEmitter streamEvents() {\n    SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);\n\n    // Save the emitter somewhere to use it to send events\n    // For example, in a concurrent map with a UUID as key\n    String emitterId = UUID.randomUUID().toString();\n    emitterService.addEmitter(emitterId, emitter);\n\n    emitter.onCompletion(() -&gt; emitterService.removeEmitter(emitterId));\n    emitter.onTimeout(() -&gt; emitterService.removeEmitter(emitterId));\n\n    // Send initial events\n    try {\n        emitter.send(SseEmitter.event()\n                .name(\"INIT\")\n                .data(\"Connected\"));\n    } catch (IOException e) {\n        emitter.completeWithError(e);\n    }\n\n    return emitter;\n}\n\n// Service to send events to all connected clients\n@Scheduled(fixedRate = 1000)\npublic void sendEvents() {\n    List&lt;Product&gt; products = productService.getRecentProducts();\n    emitterService.getAllEmitters().forEach((id, emitter) -&gt; {\n        try {\n            emitter.send(SseEmitter.event()\n                    .name(\"PRODUCTS_UPDATE\")\n                    .data(products));\n        } catch (IOException e) {\n            emitterService.removeEmitter(id);\n        }\n    });\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#working-with-json","title":"Working with JSON","text":"<p>Customizing JSON serialization/deserialization:</p> <pre><code>// Using Jackson annotations in DTOs\npublic class ProductResponseDto {\n    private Long id;\n\n    private String name;\n\n    @JsonProperty(\"product_description\")  // Custom field name in JSON\n    private String description;\n\n    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyy-MM-dd HH:mm:ss\")\n    private LocalDateTime createdAt;\n\n    @JsonInclude(JsonInclude.Include.NON_NULL)  // Skip null values\n    private String optionalField;\n\n    @JsonIgnore  // Exclude from JSON\n    private String internalNote;\n\n    // Getters and setters\n}\n</code></pre> <p>Custom serialization with Jackson:</p> <pre><code>@Bean\npublic ObjectMapper objectMapper() {\n    ObjectMapper mapper = new ObjectMapper();\n\n    // Configure dates to be serialized as ISO strings\n    mapper.registerModule(new JavaTimeModule());\n    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n\n    // Don't fail on unknown properties\n    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\n    // Exclude null fields\n    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n\n    return mapper;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#pagination-and-sorting","title":"Pagination and Sorting","text":"<p>Spring Data provides built-in support for pagination and sorting:</p> <pre><code>@GetMapping\npublic ResponseEntity&lt;Page&lt;ProductResponseDto&gt;&gt; getAllProducts(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"10\") int size,\n        @RequestParam(defaultValue = \"id\") String sortBy,\n        @RequestParam(defaultValue = \"asc\") String direction) {\n\n    Sort.Direction sortDirection = direction.equalsIgnoreCase(\"desc\") ? \n            Sort.Direction.DESC : Sort.Direction.ASC;\n\n    Pageable pageable = PageRequest.of(page, size, Sort.by(sortDirection, sortBy));\n\n    Page&lt;Product&gt; productPage = productService.findAll(pageable);\n\n    Page&lt;ProductResponseDto&gt; dtoPage = productPage.map(productMapper::toDto);\n\n    return ResponseEntity.ok(dtoPage);\n}\n</code></pre> <p>Custom response format for pagination:</p> <pre><code>@GetMapping\npublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getAllProducts(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"10\") int size) {\n\n    Pageable pageable = PageRequest.of(page, size);\n    Page&lt;Product&gt; productPage = productService.findAll(pageable);\n\n    List&lt;ProductResponseDto&gt; products = productPage.getContent()\n            .stream()\n            .map(productMapper::toDto)\n            .collect(Collectors.toList());\n\n    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();\n    response.put(\"products\", products);\n    response.put(\"currentPage\", productPage.getNumber());\n    response.put(\"totalItems\", productPage.getTotalElements());\n    response.put(\"totalPages\", productPage.getTotalPages());\n    response.put(\"first\", productPage.isFirst());\n    response.put(\"last\", productPage.isLast());\n    response.put(\"hasNext\", productPage.hasNext());\n    response.put(\"hasPrevious\", productPage.hasPrevious());\n\n    return ResponseEntity.ok(response);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#request-and-response-best-practices","title":"Request and Response Best Practices","text":"<ol> <li>Use DTOs: Separate your API models from domain entities</li> <li>Validate input: Use JSR-380 annotations for validation</li> <li>Follow HTTP semantics: Use appropriate status codes and methods</li> <li>Provide meaningful error responses: Include error details and codes</li> <li>Use pagination: For collections that can grow large</li> <li>Include hypermedia links: Follow HATEOAS principles</li> <li>Document your API: Add OpenAPI/Swagger annotations</li> <li>Use content negotiation: Support multiple formats if needed</li> <li>Implement conditional requests: Use ETags for caching</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#exception-handling","title":"Exception Handling","text":"<p>Proper exception handling is crucial for building robust REST APIs. It improves error visibility, enhances API usability, and provides better security. Spring Boot offers several mechanisms for handling exceptions in a consistent and maintainable way.</p>"},{"location":"spring-boot/spring-boot-rest-api/#global-exception-handling-with-controlleradvice","title":"Global Exception Handling with @ControllerAdvice","text":"<p>Spring's <code>@ControllerAdvice</code> and <code>@RestControllerAdvice</code> annotations provide a centralized way to handle exceptions across all controllers:</p> <pre><code>@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    public Map&lt;String, String&gt; handleResourceNotFoundException(ResourceNotFoundException ex) {\n        Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();\n        errorResponse.put(\"message\", ex.getMessage());\n        errorResponse.put(\"status\", HttpStatus.NOT_FOUND.toString());\n        errorResponse.put(\"timestamp\", new Date().toString());\n        return errorResponse;\n    }\n\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    public Map&lt;String, String&gt; handleGenericException(Exception ex) {\n        Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();\n        errorResponse.put(\"message\", \"An unexpected error occurred\");\n        errorResponse.put(\"status\", HttpStatus.INTERNAL_SERVER_ERROR.toString());\n        errorResponse.put(\"timestamp\", new Date().toString());\n        errorResponse.put(\"error\", ex.getMessage());\n        return errorResponse;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#creating-custom-exceptions","title":"Creating Custom Exceptions","text":"<p>Define custom exceptions to represent specific error cases in your application:</p> <pre><code>public class ResourceNotFoundException extends RuntimeException {\n\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n\n    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {\n        super(String.format(\"%s not found with %s: '%s'\", resourceName, fieldName, fieldValue));\n    }\n}\n\npublic class BadRequestException extends RuntimeException {\n\n    public BadRequestException(String message) {\n        super(message);\n    }\n}\n\npublic class ResourceAlreadyExistsException extends RuntimeException {\n\n    public ResourceAlreadyExistsException(String message) {\n        super(message);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#handling-validation-errors","title":"Handling Validation Errors","text":"<p>As seen in the previous section, you can handle validation errors in a dedicated method:</p> <pre><code>@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    // ... other exception handlers\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    public Map&lt;String, Object&gt; handleValidationErrors(MethodArgumentNotValidException ex) {\n        Map&lt;String, Object&gt; errorResponse = new HashMap&lt;&gt;();\n        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();\n\n        ex.getBindingResult().getFieldErrors().forEach(error -&gt; \n            errors.put(error.getField(), error.getDefaultMessage())\n        );\n\n        errorResponse.put(\"status\", HttpStatus.BAD_REQUEST.value());\n        errorResponse.put(\"timestamp\", new Date());\n        errorResponse.put(\"errors\", errors);\n\n        return errorResponse;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#handling-request-body-parsing-errors","title":"Handling Request Body Parsing Errors","text":"<p>Handle malformed JSON or XML in request bodies:</p> <pre><code>@ExceptionHandler(HttpMessageNotReadableException.class)\n@ResponseStatus(HttpStatus.BAD_REQUEST)\npublic Map&lt;String, String&gt; handleHttpMessageNotReadable(HttpMessageNotReadableException ex) {\n    Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();\n    errorResponse.put(\"message\", \"Malformed request body\");\n    errorResponse.put(\"error\", ex.getMessage());\n    errorResponse.put(\"status\", HttpStatus.BAD_REQUEST.toString());\n    return errorResponse;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#handling-method-argument-type-mismatch","title":"Handling Method Argument Type Mismatch","text":"<p>Handle cases where request parameters have incorrect types:</p> <pre><code>@ExceptionHandler(MethodArgumentTypeMismatchException.class)\n@ResponseStatus(HttpStatus.BAD_REQUEST)\npublic Map&lt;String, String&gt; handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {\n    Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();\n    errorResponse.put(\"message\", String.format(\n            \"The parameter '%s' of value '%s' could not be converted to type '%s'\",\n            ex.getName(), ex.getValue(), ex.getRequiredType().getSimpleName()));\n    errorResponse.put(\"status\", HttpStatus.BAD_REQUEST.toString());\n    return errorResponse;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#handling-missing-path-variables","title":"Handling Missing Path Variables","text":"<p>Handle cases where path variables are missing:</p> <pre><code>@ExceptionHandler(MissingPathVariableException.class)\n@ResponseStatus(HttpStatus.BAD_REQUEST)\npublic Map&lt;String, String&gt; handleMissingPathVariable(MissingPathVariableException ex) {\n    Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();\n    errorResponse.put(\"message\", String.format(\"The path variable '%s' is missing\", ex.getVariableName()));\n    errorResponse.put(\"status\", HttpStatus.BAD_REQUEST.toString());\n    return errorResponse;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#handling-missing-request-parameters","title":"Handling Missing Request Parameters","text":"<p>Handle cases where required request parameters are missing:</p> <pre><code>@ExceptionHandler(MissingServletRequestParameterException.class)\n@ResponseStatus(HttpStatus.BAD_REQUEST)\npublic Map&lt;String, String&gt; handleMissingRequestParameter(MissingServletRequestParameterException ex) {\n    Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;();\n    errorResponse.put(\"message\", String.format(\"The parameter '%s' of type '%s' is required\", \n            ex.getParameterName(), ex.getParameterType()));\n    errorResponse.put(\"status\", HttpStatus.BAD_REQUEST.toString());\n    return errorResponse;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#error-response-structure","title":"Error Response Structure","text":"<p>It's important to have a consistent error response structure. Here's an example of a well-structured error response:</p> <pre><code>public class ErrorResponse {\n    private int status;\n    private String message;\n    private String path;\n    private Date timestamp;\n    private Map&lt;String, String&gt; errors;\n\n    // Constructors, getters, setters\n}\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @Autowired\n    private HttpServletRequest request;\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    public ErrorResponse handleResourceNotFoundException(ResourceNotFoundException ex) {\n        ErrorResponse errorResponse = new ErrorResponse();\n        errorResponse.setStatus(HttpStatus.NOT_FOUND.value());\n        errorResponse.setMessage(ex.getMessage());\n        errorResponse.setPath(request.getRequestURI());\n        errorResponse.setTimestamp(new Date());\n        return errorResponse;\n    }\n\n    // Other exception handlers...\n}\n</code></pre> <p>The JSON output for this structure would look like:</p> <pre><code>{\n  \"status\": 404,\n  \"message\": \"Product not found with id: '123'\",\n  \"path\": \"/api/v1/products/123\",\n  \"timestamp\": \"2023-07-20T15:30:45.123Z\",\n  \"errors\": null\n}\n</code></pre> <p>For validation errors:</p> <pre><code>{\n  \"status\": 400,\n  \"message\": \"Validation failed\",\n  \"path\": \"/api/v1/products\",\n  \"timestamp\": \"2023-07-20T15:30:45.123Z\",\n  \"errors\": {\n    \"name\": \"Product name is required\",\n    \"price\": \"Price must be positive\"\n  }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#exception-handling-best-practices","title":"Exception Handling Best Practices","text":"<ol> <li>Use Custom Exceptions: Create specific exceptions for different error cases.</li> <li>Centralize Exception Handling: Use <code>@ControllerAdvice</code> to handle exceptions globally.</li> <li>Provide Clear Error Messages: Error messages should be clear and helpful.</li> <li>Include Error Details: Include all relevant details (timestamp, path, error code, etc.).</li> <li>Use Appropriate HTTP Status Codes: Map exceptions to appropriate HTTP status codes.</li> <li>Avoid Exposing Sensitive Information: Don't leak implementation details or stack traces.</li> <li>Log Exceptions: Log exceptions properly, especially unexpected ones.</li> <li>Consistent Response Format: Maintain a consistent error response format across your API.</li> <li>Internationalization: Consider supporting multiple languages for error messages.</li> <li>Document Error Responses: Include error responses in your API documentation.</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#examples-of-status-code-mappings","title":"Examples of Status Code Mappings","text":"<p>Here's a mapping of common exceptions to appropriate HTTP status codes:</p> Exception Status Code Description ResourceNotFoundException 404 Not Found Resource doesn't exist BadRequestException 400 Bad Request Invalid request parameters or format ValidationException 400 Bad Request Input validation failures AccessDeniedException 403 Forbidden Authenticated but not authorized AuthenticationException 401 Unauthorized Not authenticated ResourceAlreadyExistsException 409 Conflict Resource already exists MethodArgumentNotValidException 400 Bad Request Bean validation errors HttpMessageNotReadableException 400 Bad Request Malformed request body MethodNotAllowedException 405 Method Not Allowed HTTP method not supported HttpMediaTypeNotSupportedException 415 Unsupported Media Type Unsupported content type HttpMediaTypeNotAcceptableException 406 Not Acceptable Cannot generate response in requested format ConcurrencyFailureException 409 Conflict Concurrent modification issues RuntimeException 500 Internal Server Error Unexpected server errors"},{"location":"spring-boot/spring-boot-rest-api/#creating-a-unified-exception-handler","title":"Creating a Unified Exception Handler","text":"<p>For larger applications, consider creating a more structured exception handling system:</p> <pre><code>@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    @Autowired\n    private MessageSource messageSource;\n\n    @Autowired\n    private HttpServletRequest request;\n\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    public ErrorResponse handleException(Exception ex, Locale locale) {\n        logger.error(\"Unexpected error\", ex);\n        return buildErrorResponse(\n                HttpStatus.INTERNAL_SERVER_ERROR, \n                \"error.unexpected\", \n                new Object[]{}, \n                locale, \n                ex);\n    }\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    public ErrorResponse handleResourceNotFoundException(ResourceNotFoundException ex, Locale locale) {\n        return buildErrorResponse(\n                HttpStatus.NOT_FOUND, \n                \"error.resource.notfound\", \n                new Object[]{ex.getResourceName(), ex.getFieldName(), ex.getFieldValue()}, \n                locale, \n                ex);\n    }\n\n    // Other exception handlers...\n\n    private ErrorResponse buildErrorResponse(\n            HttpStatus status, \n            String messageKey, \n            Object[] args, \n            Locale locale, \n            Exception ex) {\n\n        ErrorResponse errorResponse = new ErrorResponse();\n        errorResponse.setStatus(status.value());\n        errorResponse.setError(status.getReasonPhrase());\n        errorResponse.setMessage(messageSource.getMessage(messageKey, args, locale));\n        errorResponse.setPath(request.getRequestURI());\n        errorResponse.setTimestamp(new Date());\n\n        if (ex instanceof MethodArgumentNotValidException) {\n            Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();\n            ((MethodArgumentNotValidException) ex).getBindingResult().getFieldErrors()\n                    .forEach(error -&gt; errors.put(error.getField(), error.getDefaultMessage()));\n            errorResponse.setErrors(errors);\n        }\n\n        return errorResponse;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#content-negotiation_1","title":"Content Negotiation","text":"<p>Content negotiation is the process of selecting the best representation for a resource when there are multiple representations available. In REST APIs, it allows clients to request resources in the format they prefer, such as JSON, XML, or custom media types.</p>"},{"location":"spring-boot/spring-boot-rest-api/#media-types","title":"Media Types","text":"<p>Common media types used in REST APIs:</p> Media Type Description Common Use <code>application/json</code> JSON format Most widely used format for modern APIs <code>application/xml</code> XML format Still used in enterprise systems <code>application/x-www-form-urlencoded</code> Form data Common for HTML form submissions <code>multipart/form-data</code> File uploads with form data Used for file uploads <code>text/plain</code> Plain text Simple text responses <code>text/html</code> HTML format Rendering HTML pages <code>application/pdf</code> PDF document Document download <code>application/octet-stream</code> Binary data Generic binary data <code>application/vnd.api+json</code> JSON:API specification Standardized JSON format <code>application/hal+json</code> HAL specification Hypermedia-enabled JSON"},{"location":"spring-boot/spring-boot-rest-api/#content-negotiation-strategies","title":"Content Negotiation Strategies","text":"<p>Spring Boot supports several content negotiation strategies:</p> <ol> <li>HTTP Headers: Using the <code>Accept</code> header</li> <li>Path Extensions: Using file extensions like <code>.json</code>, <code>.xml</code></li> <li>Query Parameters: Using parameters like <code>?format=json</code></li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#configuring-content-negotiation","title":"Configuring Content Negotiation","text":"<p>Configure content negotiation in your application:</p> <pre><code>@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer\n            .favorParameter(true)          // Enable parameter strategy\n            .parameterName(\"format\")        // Parameter name (e.g., ?format=json)\n            .ignoreAcceptHeader(false)      // Don't ignore Accept header\n            .useRegisteredExtensionsOnly(false)\n            .defaultContentType(MediaType.APPLICATION_JSON)\n            .mediaType(\"json\", MediaType.APPLICATION_JSON)\n            .mediaType(\"xml\", MediaType.APPLICATION_XML)\n            .mediaType(\"pdf\", MediaType.APPLICATION_PDF);\n    }\n}\n</code></pre> <p>With YAML configuration in <code>application.yml</code>:</p> <pre><code>spring:\n  mvc:\n    contentnegotiation:\n      favor-parameter: true\n      parameter-name: format\n      media-types:\n        json: application/json\n        xml: application/xml\n        pdf: application/pdf\n      default-content-type: application/json\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#supporting-multiple-formats-in-controllers","title":"Supporting Multiple Formats in Controllers","text":"<p>Controllers can respond with different formats:</p> <pre><code>@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    private final ProductService productService;\n\n    // Constructor...\n\n    @GetMapping(value = \"/{id}\", \n                produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})\n    public Product getProduct(@PathVariable Long id) {\n        return productService.findById(id)\n                .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#custom-media-types","title":"Custom Media Types","text":"<p>You can define custom media types for specialized responses:</p> <pre><code>// Custom media type constants\npublic final class CustomMediaTypes {\n    public static final String APPLICATION_JSON_V1_VALUE = \"application/vnd.myapp.v1+json\";\n    public static final String APPLICATION_JSON_V2_VALUE = \"application/vnd.myapp.v2+json\";\n\n    public static final MediaType APPLICATION_JSON_V1 = MediaType.valueOf(APPLICATION_JSON_V1_VALUE);\n    public static final MediaType APPLICATION_JSON_V2 = MediaType.valueOf(APPLICATION_JSON_V2_VALUE);\n}\n\n// Controller with custom media types\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    @GetMapping(value = \"/{id}\", produces = CustomMediaTypes.APPLICATION_JSON_V1_VALUE)\n    public ProductV1Dto getProductV1(@PathVariable Long id) {\n        Product product = productService.findById(id)\n                .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n        return productMapperV1.toDto(product);\n    }\n\n    @GetMapping(value = \"/{id}\", produces = CustomMediaTypes.APPLICATION_JSON_V2_VALUE)\n    public ProductV2Dto getProductV2(@PathVariable Long id) {\n        Product product = productService.findById(id)\n                .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n        return productMapperV2.toDto(product);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#message-converters","title":"Message Converters","text":"<p>Spring uses message converters to convert between HTTP requests/responses and Java objects. The most common converters are:</p> <ol> <li><code>MappingJackson2HttpMessageConverter</code> - Converts JSON to/from Java objects</li> <li><code>MappingJackson2XmlHttpMessageConverter</code> - Converts XML to/from Java objects</li> <li><code>StringHttpMessageConverter</code> - Converts plain text</li> <li><code>ByteArrayHttpMessageConverter</code> - Converts byte arrays</li> </ol> <p>You can customize these converters or add your own:</p> <pre><code>@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {\n        // Customize existing converters\n        converters.forEach(converter -&gt; {\n            if (converter instanceof MappingJackson2HttpMessageConverter) {\n                MappingJackson2HttpMessageConverter jsonConverter = (MappingJackson2HttpMessageConverter) converter;\n                ObjectMapper objectMapper = jsonConverter.getObjectMapper();\n                objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n                objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n                objectMapper.registerModule(new JavaTimeModule());\n            }\n        });\n\n        // Add custom converter\n        converters.add(new CsvHttpMessageConverter());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#accept-header-handling","title":"Accept Header Handling","text":"<p>The <code>Accept</code> header specifies which media types are acceptable for the response:</p> <ul> <li><code>Accept: application/json</code> - Client accepts only JSON</li> <li><code>Accept: application/xml</code> - Client accepts only XML</li> <li><code>Accept: application/json, application/xml</code> - Client accepts JSON or XML (JSON preferred)</li> <li><code>Accept: application/json;q=0.5, application/xml;q=0.8</code> - Client accepts JSON or XML (XML preferred)</li> </ul> <p>Spring handles this automatically based on your controller's <code>produces</code> attribute and configured message converters.</p>"},{"location":"spring-boot/spring-boot-rest-api/#content-type-header-for-requests","title":"Content Type Header for Requests","text":"<p>For requests with a body, clients should specify the <code>Content-Type</code> header to indicate the format of the data they're sending:</p> <ul> <li><code>Content-Type: application/json</code> - Request body is in JSON format</li> <li><code>Content-Type: application/xml</code> - Request body is in XML format</li> <li><code>Content-Type: multipart/form-data</code> - Request body is form data with file uploads</li> </ul> <p>Spring uses this header to determine which message converter to use for parsing the request body.</p>"},{"location":"spring-boot/spring-boot-rest-api/#json-configuration","title":"JSON Configuration","text":"<p>Customize JSON serialization/deserialization with Jackson:</p> <pre><code>@Configuration\npublic class JacksonConfig {\n\n    @Bean\n    public ObjectMapper objectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n\n        // Don't include null values in JSON output\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n\n        // Use ISO-8601 format for dates\n        mapper.registerModule(new JavaTimeModule());\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        // Don't fail on unknown properties\n        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\n        // Use camelCase for property names (default in Java)\n        // For snake_case, uncomment:\n        // objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n\n        return mapper;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#xml-configuration","title":"XML Configuration","text":"<p>Configure XML serialization/deserialization:</p> <pre><code>@Configuration\npublic class XmlConfig {\n\n    @Bean\n    public Jackson2ObjectMapperBuilder jacksonXmlBuilder() {\n        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();\n        builder.indentOutput(true);\n        builder.featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        builder.modules(new JavaTimeModule());\n        builder.defaultUseWrapper(false);  // Don't wrap collections\n        return builder;\n    }\n\n    @Bean\n    public XmlMapper xmlMapper(Jackson2ObjectMapperBuilder jacksonXmlBuilder) {\n        XmlMapper xmlMapper = jacksonXmlBuilder.createXmlMapper(true).build();\n        xmlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        return xmlMapper;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#response-format-selection-order","title":"Response Format Selection Order","text":"<p>Spring Boot determines the response format in this order:</p> <ol> <li>Format parameter in the URL if enabled (e.g., <code>?format=json</code>)</li> <li>Path extension if enabled (e.g., <code>/products/123.json</code>)</li> <li><code>Accept</code> header in the request</li> <li>Default content type configured in the application</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#handling-unsupported-media-types","title":"Handling Unsupported Media Types","text":"<p>When a client requests a media type that your API doesn't support, Spring Boot returns a 406 Not Acceptable status. You can customize this behavior:</p> <pre><code>@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(HttpMediaTypeNotAcceptableException.class)\n    @ResponseStatus(HttpStatus.NOT_ACCEPTABLE)\n    public Map&lt;String, String&gt; handleMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex) {\n        Map&lt;String, String&gt; response = new HashMap&lt;&gt;();\n        response.put(\"error\", \"Unsupported media type\");\n        response.put(\"message\", \"This API supports only application/json and application/xml\");\n        response.put(\"supported_types\", \"application/json, application/xml\");\n        return response;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#content-negotiation-best-practices","title":"Content Negotiation Best Practices","text":"<ol> <li>Use JSON as Default: JSON is the most widely used format for modern APIs.</li> <li>Support Multiple Formats: Consider supporting both JSON and XML for broader compatibility.</li> <li>Use Standard Headers: Prefer Accept/Content-Type headers over URL parameters for format selection.</li> <li>Document Supported Formats: Clearly document which formats your API supports.</li> <li>Consistent Media Types: Use consistent media types across your API.</li> <li>Test Different Formats: Test your API with different content negotiation methods.</li> <li>Meaningful Error Messages: Return helpful error messages for unsupported formats.</li> <li>Avoid Path Extensions: Path extensions (e.g., <code>.json</code>) are being deprecated in modern APIs.</li> <li>Use Version-Specific Media Types: For versioning, consider using custom media types.</li> <li>Keep Default Configuration: Spring Boot's default content negotiation configuration works well for most cases.</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#api-documentation-with-openapiswagger","title":"API Documentation with OpenAPI/Swagger","text":"<p>Good API documentation is essential for developers using your API. OpenAPI (formerly known as Swagger) is a specification for documenting REST APIs that Spring Boot can easily integrate with.</p>"},{"location":"spring-boot/spring-boot-rest-api/#introduction-to-openapi","title":"Introduction to OpenAPI","text":"<p>OpenAPI is a specification for machine-readable API documentation files that describe RESTful APIs. It allows both humans and computers to understand the capabilities of a service without direct access to its implementation or source code.</p>"},{"location":"spring-boot/spring-boot-rest-api/#adding-springdoc-openapi-to-your-project","title":"Adding SpringDoc OpenAPI to Your Project","text":"<p>To add OpenAPI documentation to your Spring Boot application, use the SpringDoc OpenAPI library:</p> <pre><code>&lt;!-- For Maven --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n    &lt;version&gt;2.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>// For Gradle\nimplementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'\n</code></pre> <p>This dependency provides: - OpenAPI 3 specification generation - Swagger UI integration - Spring Boot integration</p>"},{"location":"spring-boot/spring-boot-rest-api/#basic-configuration","title":"Basic Configuration","text":"<p>Once added, SpringDoc automatically generates an OpenAPI specification for your API. Access the documentation at:</p> <ul> <li>OpenAPI JSON: <code>/v3/api-docs</code></li> <li>OpenAPI YAML: <code>/v3/api-docs.yaml</code></li> <li>Swagger UI: <code>/swagger-ui.html</code></li> </ul> <p>You can customize the OpenAPI configuration using <code>application.properties</code>:</p> <pre><code># OpenAPI properties\nspringdoc.api-docs.path=/api-docs\nspringdoc.swagger-ui.path=/swagger-ui\nspringdoc.swagger-ui.operationsSorter=method\nspringdoc.swagger-ui.tagsSorter=alpha\nspringdoc.swagger-ui.tryItOutEnabled=true\n\n# API info\nspringdoc.info.title=Product API\nspringdoc.info.description=Spring Boot REST API for Product Management\nspringdoc.info.version=1.0.0\nspringdoc.info.termsOfService=http://example.com/terms/\nspringdoc.info.contact.name=API Support\nspringdoc.info.contact.url=https://example.com/support\nspringdoc.info.contact.email=support@example.com\nspringdoc.info.license.name=Apache 2.0\nspringdoc.info.license.url=https://www.apache.org/licenses/LICENSE-2.0.html\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#java-configuration","title":"Java Configuration","text":"<p>For more control, configure OpenAPI using a configuration class:</p> <pre><code>@Configuration\npublic class OpenApiConfig {\n\n    @Bean\n    public OpenAPI customOpenAPI() {\n        return new OpenAPI()\n                .info(new Info()\n                        .title(\"Product API\")\n                        .description(\"Spring Boot REST API for Product Management\")\n                        .version(\"1.0.0\")\n                        .termsOfService(\"http://example.com/terms/\")\n                        .contact(new Contact()\n                                .name(\"API Support\")\n                                .url(\"https://example.com/support\")\n                                .email(\"support@example.com\"))\n                        .license(new License()\n                                .name(\"Apache 2.0\")\n                                .url(\"https://www.apache.org/licenses/LICENSE-2.0\")))\n                .externalDocs(new ExternalDocumentation()\n                        .description(\"Product API Documentation\")\n                        .url(\"https://example.com/docs\"));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#documenting-controllers","title":"Documenting Controllers","text":"<p>Use OpenAPI annotations to document your controllers:</p> <pre><code>@RestController\n@RequestMapping(\"/products\")\n@Tag(name = \"Product Management\", description = \"API endpoints for product management\")\npublic class ProductController {\n\n    private final ProductService productService;\n\n    public ProductController(ProductService productService) {\n        this.productService = productService;\n    }\n\n    @GetMapping\n    @Operation(\n        summary = \"Get all products\",\n        description = \"Returns a list of all products with pagination support\",\n        responses = {\n            @ApiResponse(responseCode = \"200\", description = \"Successfully retrieved products\",\n                    content = @Content(\n                            mediaType = MediaType.APPLICATION_JSON_VALUE,\n                            array = @ArraySchema(schema = @Schema(implementation = ProductResponseDto.class))\n                    )),\n            @ApiResponse(responseCode = \"500\", description = \"Internal server error\",\n                    content = @Content(\n                            mediaType = MediaType.APPLICATION_JSON_VALUE,\n                            schema = @Schema(implementation = ErrorResponse.class)\n                    ))\n        }\n    )\n    public Page&lt;ProductResponseDto&gt; getAllProducts(\n            @Parameter(description = \"Page number (zero-based)\", example = \"0\")\n            @RequestParam(defaultValue = \"0\") int page,\n\n            @Parameter(description = \"Page size\", example = \"10\")\n            @RequestParam(defaultValue = \"10\") int size,\n\n            @Parameter(description = \"Sort field\", example = \"name\")\n            @RequestParam(defaultValue = \"id\") String sortBy) {\n\n        Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));\n\n        Page&lt;Product&gt; productPage = productService.findAll(pageable);\n\n        Page&lt;ProductResponseDto&gt; dtoPage = productPage.map(productMapper::toDto);\n\n        return ResponseEntity.ok(dtoPage);\n    }\n\n    @GetMapping(\"/{id}\")\n    @Operation(\n        summary = \"Get product by ID\",\n        description = \"Returns a single product by its ID\",\n        responses = {\n            @ApiResponse(responseCode = \"200\", description = \"Product found\",\n                    content = @Content(\n                            mediaType = MediaType.APPLICATION_JSON_VALUE,\n                            schema = @Schema(implementation = ProductResponseDto.class)\n                    )),\n            @ApiResponse(responseCode = \"404\", description = \"Product not found\",\n                    content = @Content(\n                            mediaType = MediaType.APPLICATION_JSON_VALUE,\n                            schema = @Schema(implementation = ErrorResponse.class)\n                    ))\n        }\n    )\n    public ResponseEntity&lt;ProductResponseDto&gt; getProductById(\n            @Parameter(description = \"Product ID\", example = \"1\", required = true)\n            @PathVariable Long id) {\n\n        return productService.findById(id)\n                .map(product -&gt; ResponseEntity.ok(productMapper.toDto(product)))\n                .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n    }\n\n    @PostMapping\n    @Operation(\n        summary = \"Create new product\",\n        description = \"Creates a new product with the provided information\",\n        responses = {\n            @ApiResponse(responseCode = \"201\", description = \"Product created successfully\",\n                    content = @Content(\n                            mediaType = MediaType.APPLICATION_JSON_VALUE,\n                            schema = @Schema(implementation = ProductResponseDto.class)\n                    )),\n            @ApiResponse(responseCode = \"400\", description = \"Invalid product data\",\n                    content = @Content(\n                            mediaType = MediaType.APPLICATION_JSON_VALUE,\n                            schema = @Schema(implementation = ErrorResponse.class)\n                    ))\n        }\n    )\n    @ApiResponse(responseCode = \"201\", description = \"Product created successfully\")\n    public ResponseEntity&lt;ProductResponseDto&gt; createProduct(\n            @Parameter(description = \"Product details\", required = true)\n            @Valid @RequestBody ProductCreateDto productDto) {\n\n        Product product = productMapper.toEntity(productDto);\n        Product savedProduct = productService.save(product);\n        ProductResponseDto responseDto = productMapper.toDto(savedProduct);\n\n        URI location = ServletUriComponentsBuilder\n                .fromCurrentRequest()\n                .path(\"/{id}\")\n                .buildAndExpand(savedProduct.getId())\n                .toUri();\n\n        return ResponseEntity.created(location).body(responseDto);\n    }\n\n    // Other methods...\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#documenting-data-models","title":"Documenting Data Models","text":"<p>Add documentation to your data models:</p> <pre><code>@Schema(description = \"Product creation request\")\npublic class ProductCreateDto {\n\n    @Schema(description = \"Product name\", example = \"Smartphone\", required = true)\n    @NotBlank\n    private String name;\n\n    @Schema(description = \"Product description\", example = \"Latest smartphone model with advanced features\")\n    private String description;\n\n    @Schema(description = \"Product price\", example = \"799.99\", required = true)\n    @NotNull\n    @Positive\n    private BigDecimal price;\n\n    @Schema(description = \"Whether the product is in stock\", example = \"true\", defaultValue = \"false\")\n    private boolean inStock;\n\n    // Getters and setters\n}\n\n@Schema(description = \"Product response\")\npublic class ProductResponseDto {\n\n    @Schema(description = \"Product ID\", example = \"1\")\n    private Long id;\n\n    @Schema(description = \"Product name\", example = \"Smartphone\")\n    private String name;\n\n    @Schema(description = \"Product description\", example = \"Latest smartphone model with advanced features\")\n    private String description;\n\n    @Schema(description = \"Product price\", example = \"799.99\")\n    private BigDecimal price;\n\n    @Schema(description = \"Whether the product is in stock\", example = \"true\")\n    private boolean inStock;\n\n    @Schema(description = \"Creation timestamp\", example = \"2023-07-20T15:30:45.123Z\")\n    private LocalDateTime createdAt;\n\n    @Schema(description = \"Last update timestamp\", example = \"2023-07-20T16:45:12.456Z\")\n    private LocalDateTime updatedAt;\n\n    // Getters and setters\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#global-api-information","title":"Global API Information","text":"<p>Set up global API information:</p> <pre><code>@Bean\npublic OpenAPI customOpenAPI() {\n    return new OpenAPI()\n            .components(new Components()\n                    .addSecuritySchemes(\"bearerAuth\", new SecurityScheme()\n                            .type(SecurityScheme.Type.HTTP)\n                            .scheme(\"bearer\")\n                            .bearerFormat(\"JWT\")))\n            .info(new Info()\n                    .title(\"Product API\")\n                    .description(\"Spring Boot REST API for Product Management\")\n                    .version(\"1.0.0\")\n                    .contact(new Contact()\n                            .name(\"API Support\")\n                            .url(\"https://example.com/support\")\n                            .email(\"support@example.com\"))\n                    .license(new License()\n                            .name(\"Apache 2.0\")\n                            .url(\"https://www.apache.org/licenses/LICENSE-2.0\")))\n            .externalDocs(new ExternalDocumentation()\n                    .description(\"Product API Documentation\")\n                    .url(\"https://example.com/docs\"))\n            .addSecurityItem(new SecurityRequirement().addList(\"bearerAuth\"));\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#server-information","title":"Server Information","text":"<p>Define server information:</p> <pre><code>@Bean\npublic OpenAPI customOpenAPI() {\n    return new OpenAPI()\n            // Other configuration...\n            .servers(List.of(\n                    new Server()\n                            .url(\"https://api.example.com\")\n                            .description(\"Production server\"),\n                    new Server()\n                            .url(\"https://staging-api.example.com\")\n                            .description(\"Staging server\"),\n                    new Server()\n                            .url(\"http://localhost:8080\")\n                            .description(\"Development server\")\n            ));\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#security-documentation","title":"Security Documentation","text":"<p>Document security requirements:</p> <pre><code>@Bean\npublic OpenAPI customOpenAPI() {\n    return new OpenAPI()\n            .components(new Components()\n                    .addSecuritySchemes(\"bearerAuth\", new SecurityScheme()\n                            .type(SecurityScheme.Type.HTTP)\n                            .scheme(\"bearer\")\n                            .bearerFormat(\"JWT\")\n                            .description(\"JWT token authentication\"))\n                    .addSecuritySchemes(\"basicAuth\", new SecurityScheme()\n                            .type(SecurityScheme.Type.HTTP)\n                            .scheme(\"basic\")\n                            .description(\"Basic authentication\")))\n            // Other configuration...\n            .addSecurityItem(new SecurityRequirement().addList(\"bearerAuth\"));\n}\n</code></pre> <p>For method-level security:</p> <pre><code>@DeleteMapping(\"/{id}\")\n@Operation(\n    summary = \"Delete product\",\n    description = \"Deletes a product by its ID. Requires admin role.\",\n    security = @SecurityRequirement(name = \"bearerAuth\"),\n    responses = {\n        @ApiResponse(responseCode = \"204\", description = \"Product deleted successfully\"),\n        @ApiResponse(responseCode = \"404\", description = \"Product not found\"),\n        @ApiResponse(responseCode = \"403\", description = \"Forbidden - requires admin role\")\n    }\n)\npublic ResponseEntity&lt;Void&gt; deleteProduct(@PathVariable Long id) {\n    // ...\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#tags-for-grouping","title":"Tags for Grouping","text":"<p>Use tags to group API endpoints:</p> <pre><code>@RestController\n@RequestMapping(\"/products\")\n@Tag(name = \"Products\", description = \"Product management endpoints\")\npublic class ProductController {\n    // ...\n}\n\n@RestController\n@RequestMapping(\"/orders\")\n@Tag(name = \"Orders\", description = \"Order management endpoints\")\npublic class OrderController {\n    // ...\n}\n</code></pre> <p>And in the OpenAPI configuration:</p> <pre><code>@Bean\npublic OpenAPI customOpenAPI() {\n    return new OpenAPI()\n            // Other configuration...\n            .tags(List.of(\n                    new Tag().name(\"Products\").description(\"Product management endpoints\"),\n                    new Tag().name(\"Orders\").description(\"Order management endpoints\"),\n                    new Tag().name(\"Authentication\").description(\"Authentication endpoints\")\n            ));\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#customizing-the-swagger-ui","title":"Customizing the Swagger UI","text":"<p>Configure the Swagger UI appearance:</p> <pre><code>@Bean\npublic SwaggerUiConfigParameters swaggerUiConfigParameters() {\n    return new SwaggerUiConfigParameters()\n            .displayOperationId(false)\n            .defaultModelsExpandDepth(1)\n            .defaultModelExpandDepth(1)\n            .defaultModelRendering(ModelRendering.EXAMPLE)\n            .displayRequestDuration(true)\n            .docExpansion(DocExpansion.NONE)\n            .filter(\"\")\n            .maxDisplayedTags(null)\n            .operationsSorter(OperationsSorter.ALPHA)\n            .showExtensions(false)\n            .showCommonExtensions(false)\n            .tagsSorter(TagsSorter.ALPHA)\n            .supportedSubmitMethods(UiConfiguration.Constants.DEFAULT_SUBMIT_METHODS)\n            .validatorUrl(null);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#controlling-what-gets-documented","title":"Controlling What Gets Documented","text":"<p>You can control which endpoints are documented:</p> <pre><code>@Bean\npublic GroupedOpenApi publicApi() {\n    return GroupedOpenApi.builder()\n            .group(\"public-api\")\n            .pathsToMatch(\"/api/v1/public/**\")\n            .build();\n}\n\n@Bean\npublic GroupedOpenApi adminApi() {\n    return GroupedOpenApi.builder()\n            .group(\"admin-api\")\n            .pathsToMatch(\"/api/v1/admin/**\")\n            .build();\n}\n</code></pre> <p>Or exclude specific paths:</p> <pre><code>@Bean\npublic GroupedOpenApi productApi() {\n    return GroupedOpenApi.builder()\n            .group(\"product-api\")\n            .pathsToMatch(\"/api/v1/**\")\n            .pathsToExclude(\"/api/v1/admin/**\")\n            .build();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#openapiswagger-best-practices","title":"OpenAPI/Swagger Best Practices","text":"<ol> <li>Document Everything: All endpoints, parameters, request bodies, and responses.</li> <li>Use Meaningful Examples: Provide realistic examples in your documentation.</li> <li>Group Related Endpoints: Use tags to group related endpoints.</li> <li>Document Security Requirements: Clearly explain authentication and authorization requirements.</li> <li>Include Error Responses: Document all possible error responses and codes.</li> <li>Keep Documentation Updated: Update the documentation when you change the API.</li> <li>Use Descriptive Operation IDs: These can be used for client code generation.</li> <li>Validate Your Specification: Ensure your OpenAPI specification is valid.</li> <li>Disable in Production: Consider disabling Swagger UI in production environments.</li> <li>Use Markdown in Descriptions: Enhance your descriptions with Markdown formatting.</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#hateoas-implementation","title":"HATEOAS Implementation","text":"<p>HATEOAS (Hypermedia as the Engine of Application State) is a constraint of the REST architectural style that keeps a RESTful service truly RESTful. It allows clients to navigate APIs dynamically by including hypermedia links in responses.</p>"},{"location":"spring-boot/spring-boot-rest-api/#what-is-hateoas","title":"What is HATEOAS?","text":"<p>HATEOAS makes your API self-descriptive and discoverable. Instead of clients having hard-coded knowledge of API endpoints, the API responses include hypermedia links that guide clients on what they can do next.</p> <p>A typical HATEOAS response includes: - Resource data (like product information) - Links to related resources (like related products) - Links to actions that can be performed on the resource (like update or delete)</p>"},{"location":"spring-boot/spring-boot-rest-api/#spring-hateoas","title":"Spring HATEOAS","text":"<p>To implement HATEOAS in a Spring Boot application, use the Spring HATEOAS library:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#basic-link-creation","title":"Basic Link Creation","text":"<p>Spring HATEOAS provides classes for creating links:</p> <pre><code>@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    private final ProductService productService;\n\n    public ProductController(ProductService productService) {\n        this.productService = productService;\n    }\n\n    @GetMapping(\"/{id}\")\n    public EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {\n        Product product = productService.findById(id)\n                .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n\n        // Create links\n        Link selfLink = linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel();\n        Link allProductsLink = linkTo(methodOn(ProductController.class).getAllProducts(null, null)).withRel(\"products\");\n\n        // Return the resource with links\n        return EntityModel.of(product, selfLink, allProductsLink);\n    }\n\n    @GetMapping\n    public CollectionModel&lt;EntityModel&lt;Product&gt;&gt; getAllProducts(\n            @RequestParam(required = false) Integer page,\n            @RequestParam(required = false) Integer size) {\n\n        List&lt;Product&gt; products = productService.findAll();\n\n        List&lt;EntityModel&lt;Product&gt;&gt; productResources = products.stream()\n                .map(product -&gt; EntityModel.of(product,\n                        linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel(),\n                        linkTo(methodOn(ProductController.class).getAllProducts(null, null)).withRel(\"products\")))\n                .collect(Collectors.toList());\n\n        Link selfLink = linkTo(methodOn(ProductController.class).getAllProducts(page, size)).withSelfRel();\n\n        return CollectionModel.of(productResources, selfLink);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#creating-custom-resource-classes","title":"Creating Custom Resource Classes","text":"<p>For more complex APIs, create dedicated resource classes:</p> <pre><code>@Relation(collectionRelation = \"products\", itemRelation = \"product\")\npublic class ProductModel extends RepresentationModel&lt;ProductModel&gt; {\n\n    private Long id;\n    private String name;\n    private String description;\n    private BigDecimal price;\n    private boolean inStock;\n\n    // Constructors, getters, setters...\n}\n\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    private final ProductService productService;\n    private final ProductModelAssembler productModelAssembler;\n\n    public ProductController(ProductService productService, ProductModelAssembler productModelAssembler) {\n        this.productService = productService;\n        this.productModelAssembler = productModelAssembler;\n    }\n\n    @GetMapping(\"/{id}\")\n    public ProductModel getProduct(@PathVariable Long id) {\n        Product product = productService.findById(id)\n                .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n\n        return productModelAssembler.toModel(product);\n    }\n\n    @GetMapping\n    public CollectionModel&lt;ProductModel&gt; getAllProducts() {\n        List&lt;Product&gt; products = productService.findAll();\n        return productModelAssembler.toCollectionModel(products);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#resource-assemblers","title":"Resource Assemblers","text":"<p>Resource assemblers convert domain objects to resource models with links:</p> <pre><code>@Component\npublic class ProductModelAssembler implements RepresentationModelAssembler&lt;Product, ProductModel&gt; {\n\n    @Override\n    public ProductModel toModel(Product product) {\n        ProductModel productModel = new ProductModel();\n        productModel.setId(product.getId());\n        productModel.setName(product.getName());\n        productModel.setDescription(product.getDescription());\n        productModel.setPrice(product.getPrice());\n        productModel.setInStock(product.isInStock());\n\n        // Add links\n        productModel.add(linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel());\n        productModel.add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel(\"products\"));\n\n        // Conditional links based on resource state\n        if (product.isInStock()) {\n            productModel.add(linkTo(methodOn(OrderController.class).createOrder(null))\n                    .withRel(\"order\"));\n        }\n\n        return productModel;\n    }\n\n    @Override\n    public CollectionModel&lt;ProductModel&gt; toCollectionModel(Iterable&lt;? extends Product&gt; products) {\n        List&lt;ProductModel&gt; productModels = StreamSupport.stream(products.spliterator(), false)\n                .map(this::toModel)\n                .collect(Collectors.toList());\n\n        return CollectionModel.of(productModels,\n                linkTo(methodOn(ProductController.class).getAllProducts()).withSelfRel());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#conditional-links","title":"Conditional Links","text":"<p>Add links conditionally based on the resource state or user permissions:</p> <pre><code>@Component\npublic class ProductModelAssembler implements RepresentationModelAssembler&lt;Product, ProductModel&gt; {\n\n    private final SecurityService securityService;\n\n    public ProductModelAssembler(SecurityService securityService) {\n        this.securityService = securityService;\n    }\n\n    @Override\n    public ProductModel toModel(Product product) {\n        ProductModel productModel = // ... create model\n\n        // Always add self link\n        productModel.add(linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel());\n\n        // Only add edit/delete links if user has permission\n        if (securityService.canEditProduct(product)) {\n            productModel.add(linkTo(methodOn(ProductController.class).updateProduct(product.getId(), null))\n                    .withRel(\"update\"));\n        }\n\n        if (securityService.canDeleteProduct(product)) {\n            productModel.add(linkTo(methodOn(ProductController.class).deleteProduct(product.getId()))\n                    .withRel(\"delete\"));\n        }\n\n        // Add category link\n        if (product.getCategory() != null) {\n            productModel.add(linkTo(methodOn(CategoryController.class).getCategory(product.getCategory().getId()))\n                    .withRel(\"category\"));\n        }\n\n        return productModel;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#pagination-with-hateoas","title":"Pagination with HATEOAS","text":"<p>Combine pagination with HATEOAS:</p> <pre><code>@GetMapping\npublic PagedModel&lt;EntityModel&lt;Product&gt;&gt; getAllProducts(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"10\") int size) {\n\n    Pageable pageable = PageRequest.of(page, size, Sort.by(\"name\"));\n    Page&lt;Product&gt; productPage = productService.findAll(pageable);\n\n    // Convert products to entity models with links\n    List&lt;EntityModel&lt;Product&gt;&gt; productModels = productPage.getContent().stream()\n            .map(product -&gt; EntityModel.of(product,\n                    linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel()))\n            .collect(Collectors.toList());\n\n    // Create page metadata\n    PagedModel.PageMetadata pageMetadata = new PagedModel.PageMetadata(\n            productPage.getSize(),\n            productPage.getNumber(),\n            productPage.getTotalElements(),\n            productPage.getTotalPages());\n\n    // Create links for paged response\n    Link selfLink = linkTo(methodOn(ProductController.class).getAllProducts(page, size)).withSelfRel();\n\n    Link firstLink = linkTo(methodOn(ProductController.class).getAllProducts(0, size)).withRel(IanaLinkRelations.FIRST);\n    Link lastLink = linkTo(methodOn(ProductController.class).getAllProducts(productPage.getTotalPages() - 1, size)).withRel(IanaLinkRelations.LAST);\n\n    Link nextLink = productPage.hasNext() ?\n            linkTo(methodOn(ProductController.class).getAllProducts(page + 1, size)).withRel(IanaLinkRelations.NEXT) :\n            null;\n\n    Link prevLink = productPage.hasPrevious() ?\n            linkTo(methodOn(ProductController.class).getAllProducts(page - 1, size)).withRel(IanaLinkRelations.PREV) :\n            null;\n\n    // Build and return the paged model\n    PagedModel&lt;EntityModel&lt;Product&gt;&gt; pagedModel = PagedModel.of(\n            productModels,\n            pageMetadata,\n            selfLink,\n            firstLink,\n            lastLink);\n\n    if (nextLink != null) pagedModel.add(nextLink);\n    if (prevLink != null) pagedModel.add(prevLink);\n\n    return pagedModel;\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#affordances","title":"Affordances","text":"<p>Affordances represent available actions on a resource:</p> <pre><code>@GetMapping(\"/{id}\")\npublic EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {\n    Product product = productService.findById(id)\n            .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n\n    // Create affordances\n    Link selfLink = linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel();\n\n    // Add affordance for updating the product\n    Affordance updateAffordance = afford(methodOn(ProductController.class).updateProduct(id, null));\n    selfLink = selfLink.andAffordance(updateAffordance);\n\n    // Add affordance for deleting the product\n    Affordance deleteAffordance = afford(methodOn(ProductController.class).deleteProduct(id));\n    selfLink = selfLink.andAffordance(deleteAffordance);\n\n    return EntityModel.of(product, selfLink);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#profiles-and-documentation","title":"Profiles and Documentation","text":"<p>Use profiles to link to documentation about resources:</p> <pre><code>@GetMapping(\"/{id}\")\npublic EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {\n    Product product = productService.findById(id)\n            .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n\n    Link selfLink = linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel();\n    Link profileLink = Link.of(\"https://example.com/docs/api/products\").withRel(\"profile\");\n\n    return EntityModel.of(product, selfLink, profileLink);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#hypermedia-types","title":"Hypermedia Types","text":"<p>Spring HATEOAS supports different hypermedia types:</p> <ol> <li>HAL (Hypertext Application Language) - Default format</li> <li>HAL-FORMS - HAL with form support</li> <li>Collection+JSON - Collection representation</li> <li>UBER (Uniform Basis for Exchanging Representations) - Alternate hypermedia format</li> </ol> <p>Configure the hypermedia type:</p> <pre><code>@Configuration\npublic class HypermediaConfig {\n\n    @Bean\n    public HypermediaMappingInformation hypermediaMappingInformation() {\n        // Use HAL as default but support other formats\n        return new HalConfiguration()\n                .withMediaType(MediaTypes.HAL_JSON)\n                .withMediaType(MediaTypes.HAL_FORMS_JSON);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#hateoas-response-examples","title":"HATEOAS Response Examples","text":"<p>Here's an example of a HAL response for a single product:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Smartphone\",\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#api-versioning-strategies","title":"API Versioning Strategies","text":"<p>API versioning is essential for evolving your API without breaking existing client applications. There are several approaches to versioning REST APIs in Spring Boot.</p>"},{"location":"spring-boot/spring-boot-rest-api/#why-version-apis","title":"Why Version APIs?","text":"<ol> <li>Backward Compatibility: Allows existing clients to continue functioning</li> <li>Evolving Features: Enables adding new features or changing existing ones</li> <li>Deprecation Strategy: Provides a pathway for phasing out old functionality</li> <li>Client Migration: Gives clients time to migrate to newer versions</li> </ol>"},{"location":"spring-boot/spring-boot-rest-api/#common-versioning-strategies","title":"Common Versioning Strategies","text":""},{"location":"spring-boot/spring-boot-rest-api/#1-uri-path-versioning","title":"1. URI Path Versioning","text":"<p>Include the version in the URI path:</p> <pre><code>/v1/products\n/v2/products\n</code></pre> <p>Implementation in Spring Boot:</p> <pre><code>@RestController\n@RequestMapping(\"/v1/products\")\npublic class ProductV1Controller {\n\n    @GetMapping(\"/{id}\")\n    public ProductV1Dto getProduct(@PathVariable Long id) {\n        // Return v1 representation\n    }\n}\n\n@RestController\n@RequestMapping(\"/v2/products\")\npublic class ProductV2Controller {\n\n    @GetMapping(\"/{id}\")\n    public ProductV2Dto getProduct(@PathVariable Long id) {\n        // Return v2 representation with new fields\n    }\n}\n</code></pre> <p>Pros: - Simple to implement and understand - Explicit and visible in the URL - Easy to route and document - Works with caching</p> <p>Cons: - URLs change as the API evolves - URI should ideally represent the resource, not the API version</p>"},{"location":"spring-boot/spring-boot-rest-api/#2-request-parameter-versioning","title":"2. Request Parameter Versioning","text":"<p>Specify the version as a query parameter:</p> <pre><code>/products?version=1\n/products?version=2\n</code></pre> <p>Implementation:</p> <pre><code>@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    @GetMapping(value = \"/{id}\", params = \"version=1\")\n    public ProductV1Dto getProductV1(@PathVariable Long id) {\n        // Return v1 representation\n    }\n\n    @GetMapping(value = \"/{id}\", params = \"version=2\")\n    public ProductV2Dto getProductV2(@PathVariable Long id) {\n        // Return v2 representation\n    }\n}\n</code></pre> <p>Pros: - Keeps the resource URI clean - Easy to implement - Default version possible by omitting the parameter</p> <p>Cons: - Harder to route at the infrastructure level - Might be missed in documentation - Can cause confusion with other query parameters</p>"},{"location":"spring-boot/spring-boot-rest-api/#3-http-header-versioning","title":"3. HTTP Header Versioning","text":"<p>Use a custom HTTP header to specify the version:</p> <pre><code>X-API-Version: 1\nX-API-Version: 2\n</code></pre> <p>Implementation:</p> <pre><code>@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    @GetMapping(value = \"/{id}\", headers = \"X-API-Version=1\")\n    public ProductV1Dto getProductV1(@PathVariable Long id) {\n        // Return v1 representation\n    }\n\n    @GetMapping(value = \"/{id}\", headers = \"X-API-Version=2\")\n    public ProductV2Dto getProductV2(@PathVariable Long id) {\n        // Return v2 representation\n    }\n}\n</code></pre> <p>Pros: - Keeps the resource URI clean - Separates versioning concerns from the URI - Can be standardized across APIs</p> <p>Cons: - Less visible, harder to test - May not work well with caching - Custom headers might be stripped by proxies</p>"},{"location":"spring-boot/spring-boot-rest-api/#4-media-type-versioning-content-negotiation","title":"4. Media Type Versioning (Content Negotiation)","text":"<p>Use the <code>Accept</code> header with a versioned media type:</p> <pre><code>Accept: application/vnd.company.app-v1+json\nAccept: application/vnd.company.app-v2+json\n</code></pre> <p>Implementation:</p> <pre><code>@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n\n    @GetMapping(value = \"/{id}\", produces = \"application/vnd.company.app-v1+json\")\n    public ProductV1Dto getProductV1(@PathVariable Long id) {\n        // Return v1 representation\n    }\n\n    @GetMapping(value = \"/{id}\", produces = \"application/vnd.company.app-v2+json\")\n    public ProductV2Dto getProductV2(@PathVariable Long id) {\n        // Return v2 representation\n    }\n}\n</code></pre> <p>Pros: - Follows HTTP content negotiation principles - Keeps the resource URI clean - Formal approach to versioning API representations</p> <p>Cons: - More complex to implement and test - Custom media types are less widely understood - May require special client configuration</p>"},{"location":"spring-boot/spring-boot-rest-api/#combining-strategies","title":"Combining Strategies","text":"<p>You can combine multiple versioning strategies:</p> <pre><code>@RestController\npublic class ProductController {\n\n    // URI versioning\n    @GetMapping(\"/v1/products/{id}\")\n    public ProductV1Dto getProductByUri(@PathVariable Long id) {\n        // V1 implementation\n    }\n\n    // Parameter versioning\n    @GetMapping(value = \"/products/{id}\", params = \"version=1\")\n    public ProductV1Dto getProductByParam(@PathVariable Long id) {\n        // V1 implementation\n    }\n\n    // Header versioning\n    @GetMapping(value = \"/products/{id}\", headers = \"X-API-Version=1\")\n    public ProductV1Dto getProductByHeader(@PathVariable Long id) {\n        // V1 implementation\n    }\n\n    // Media type versioning\n    @GetMapping(value = \"/products/{id}\", produces = \"application/vnd.company.app-v1+json\")\n    public ProductV1Dto getProductByMediaType(@PathVariable Long id) {\n        // V1 implementation\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-rest-api/#handling-multiple-versions-with-a-single-controller","title":"Handling Multiple Versions with a Single Controller","text":"<p>For simpler APIs, you can handle versioning in a single controller:</p> <p>```java @RestController @RequestMapping(\"/products\") public class ProductController {</p> <pre><code>private final ProductService productService;\nprivate final ProductV1Mapper productV1Mapper;\nprivate final ProductV2Mapper productV2Mapper;\n\n// Constructor injection...\n\n@GetMapping(\"/{id}\")\npublic ResponseEntity&lt;?&gt; getProduct(\n        @PathVariable Long id,\n        @RequestHeader(value = \"X-API-Version\", defaultValue = \"1\") Integer apiVersion) {\n\n    Product product = productService.findById(id)\n            .orElseThrow(() -&gt; new ResourceNotFoundException(\"Product\", \"id\", id));\n\n    if (apiVersion == 1) {\n        ProductV1Dto dto = productV1Mapper.toDto(product);\n        return ResponseEntity.ok(dto);\n    } else if (apiVersion == 2) {\n        ProductV2Dto dto = productV2Mapper.toDto(product);\n        return ResponseEntity.ok(dto);\n    } else {\n        return ResponseEntity.badRequest().body(\"Unsupported API version: \" + apiVersion);\n    }\n</code></pre>"},{"location":"spring-boot/spring-boot-security/","title":"Spring Boot Security","text":""},{"location":"spring-boot/spring-boot-security/#overview","title":"Overview","text":"<p>This guide provides a comprehensive overview of Spring Security in Spring Boot applications. It covers the core concepts, configuration approaches, authentication and authorization mechanisms, and advanced topics including JWT-based authentication, OAuth2, and Keycloak integration. By the end of this guide, you'll understand how Spring Security works internally and be able to implement robust security solutions for your Spring Boot applications.</p>"},{"location":"spring-boot/spring-boot-security/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Java and Spring Boot</li> <li>Understanding of web security concepts (authentication, authorization)</li> <li>Familiarity with RESTful APIs</li> <li>Development environment with Spring Boot set up</li> </ul>"},{"location":"spring-boot/spring-boot-security/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand Spring Security's architecture and core components</li> <li>Configure Spring Security in Spring Boot applications</li> <li>Implement various authentication mechanisms</li> <li>Secure RESTful APIs using Spring Security</li> <li>Apply proper authorization controls</li> <li>Implement JWT-based authentication</li> <li>Integrate with OAuth2 and OpenID Connect</li> <li>Configure Keycloak as an identity provider</li> <li>Test secured applications</li> <li>Apply security best practices</li> </ul>"},{"location":"spring-boot/spring-boot-security/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Spring Security Fundamentals</li> <li>Spring Security Architecture</li> <li>Authentication Mechanisms</li> <li>Authorization and Access Control</li> <li>Securing RESTful APIs</li> <li>CSRF, CORS, and XSS Protection</li> <li>JWT-Based Authentication</li> <li>OAuth2 and OpenID Connect</li> <li>Keycloak Integration</li> <li>Method Security</li> <li>Testing Secured Applications</li> <li>Security Best Practices</li> </ol>"},{"location":"spring-boot/spring-boot-security/#spring-security-fundamentals","title":"Spring Security Fundamentals","text":"<p>Spring Security is a powerful and highly customizable authentication and access control framework. It is the de-facto standard for securing Spring-based applications.</p>"},{"location":"spring-boot/spring-boot-security/#core-concepts","title":"Core Concepts","text":"<ol> <li>Authentication: The process of verifying the identity of a user, system, or entity.</li> <li>Authorization: The process of determining if an authenticated entity has permission to access a resource or perform an action.</li> <li>Principal: Currently authenticated user.</li> <li>Granted Authority: Permission granted to the principal.</li> <li>Role: A group of permissions/authorities.</li> </ol>"},{"location":"spring-boot/spring-boot-security/#spring-security-features","title":"Spring Security Features","text":"<ul> <li>Comprehensive authentication support</li> <li>Protection against common attacks (CSRF, Session Fixation)</li> <li>Servlet API integration</li> <li>Optional integration with Spring Web MVC</li> <li>Support for multiple security contexts and authentication providers</li> <li>Extensible and customizable security architecture</li> </ul>"},{"location":"spring-boot/spring-boot-security/#getting-started-with-spring-security","title":"Getting Started with Spring Security","text":"<p>To add Spring Security to a Spring Boot application, include the following dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This single dependency brings: - Authentication and authorization support - Default security configuration - Login/logout functionality - CSRF protection - Session management - Security header integration</p>"},{"location":"spring-boot/spring-boot-security/#default-security-configuration","title":"Default Security Configuration","text":"<p>When you add the Spring Security starter dependency without any additional configuration, Spring Boot applies default security settings:</p> <ol> <li>Secures all HTTP endpoints with basic authentication</li> <li>Generates a default user with a random password (printed in the console)</li> <li>Enables CSRF protection, XSS protection, and secure HTTP headers</li> <li>Creates login/logout endpoints</li> </ol> <p>To override these defaults, you need to provide custom configuration.</p>"},{"location":"spring-boot/spring-boot-security/#spring-security-architecture","title":"Spring Security Architecture","text":"<p>Understanding the internal architecture is crucial for effective customization of Spring Security. Let's explore the key components and their interactions.</p>"},{"location":"spring-boot/spring-boot-security/#spring-security-architecture_1","title":"Spring Security Architecture","text":""},{"location":"spring-boot/spring-boot-security/#spring-security-with-keycloak-architecture","title":"Spring Security with keycloak Architecture","text":""},{"location":"spring-boot/spring-boot-security/#security-filters-chain","title":"Security Filters Chain","text":"<p>Spring Security is primarily filter-based. It adds a chain of filters to the Servlet container's filter chain. These filters are executed in a specific order to implement security features:</p> <ol> <li>ChannelProcessingFilter: Ensures requests go through required channels (e.g., HTTPS)</li> <li>SecurityContextPersistenceFilter: Establishes SecurityContext for requests</li> <li>ConcurrentSessionFilter: Updates SessionRegistry and checks for expired sessions</li> <li>HeaderWriterFilter: Adds security headers to response</li> <li>CsrfFilter: Protects against CSRF attacks</li> <li>LogoutFilter: Processes logout requests</li> <li>UsernamePasswordAuthenticationFilter: Processes form-based authentication</li> <li>BasicAuthenticationFilter: Processes HTTP Basic authentication</li> <li>RequestCacheAwareFilter: Handles saved requests after authentication</li> <li>SecurityContextHolderAwareRequestFilter: Integrates with Servlet API</li> <li>AnonymousAuthenticationFilter: Creates anonymous users when no authentication exists</li> <li>SessionManagementFilter: Handles session fixation, session timeout, etc.</li> <li>ExceptionTranslationFilter: Catches security exceptions and redirects to appropriate handlers</li> <li>FilterSecurityInterceptor: Makes access control decisions based on configuration</li> </ol> <p>This filter chain is dynamically configured based on your security requirements.</p>"},{"location":"spring-boot/spring-boot-security/#securitycontextholder","title":"SecurityContextHolder","text":"<p>The SecurityContextHolder is where Spring Security stores details of the present security context, including:</p> <ul> <li>Current user's identity</li> <li>Authentication details</li> <li>Granted authorities</li> </ul> <p>By default, it uses a ThreadLocal strategy to store this information, making it available throughout a single request thread.</p> <pre><code>// How to access current authentication in code\nAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\nif (authentication != null &amp;&amp; authentication.isAuthenticated()) {\n    String username = authentication.getName();\n    Object principal = authentication.getPrincipal();\n    Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();\n    // Use authentication details\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#authentication-manager","title":"Authentication Manager","text":"<p>The AuthenticationManager is the core interface for authentication in Spring Security. Its primary method is:</p> <pre><code>Authentication authenticate(Authentication authentication) throws AuthenticationException;\n</code></pre> <p>This method: 1. Returns a fully populated Authentication object (including granted authorities) if successful 2. Throws an AuthenticationException if authentication fails 3. Returns null if it cannot decide</p> <p>The most common implementation is <code>ProviderManager</code>, which delegates to a chain of AuthenticationProvider instances.</p>"},{"location":"spring-boot/spring-boot-security/#authentication-providers","title":"Authentication Providers","text":"<p>Authentication providers perform specific types of authentication:</p> <ul> <li><code>DaoAuthenticationProvider</code>: Username/password authentication using a UserDetailsService</li> <li><code>JwtAuthenticationProvider</code>: Authenticates JWT tokens</li> <li><code>RememberMeAuthenticationProvider</code>: Handles remember-me authentication</li> <li><code>OAuthAuthenticationProvider</code>: Authenticates OAuth tokens</li> <li><code>LdapAuthenticationProvider</code>: LDAP authentication</li> </ul> <p>These can be chained together to support multiple authentication mechanisms.</p>"},{"location":"spring-boot/spring-boot-security/#userdetailsservice","title":"UserDetailsService","text":"<p>The UserDetailsService is a key interface that:</p> <ol> <li>Loads user details by username</li> <li>Returns a UserDetails object with username, password, authorities, and account status flags</li> </ol> <pre><code>public interface UserDetailsService {\n    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;\n}\n</code></pre> <p>Custom implementations typically connect to user stores like databases, LDAP, or external identity providers.</p>"},{"location":"spring-boot/spring-boot-security/#access-decision-manager","title":"Access Decision Manager","text":"<p>The AccessDecisionManager makes decisions about whether access is granted to a secured resource. It uses:</p> <ul> <li>Authentication object (current user)</li> <li>Secured object being accessed</li> <li>List of security configuration attributes for the object</li> </ul> <p>Spring Security offers several voting-based implementations, like: - <code>AffirmativeBased</code>: Grants access if any voter approves - <code>ConsensusBased</code>: Takes majority vote - <code>UnanimousBased</code>: Requires all voters to approve</p>"},{"location":"spring-boot/spring-boot-security/#security-context-management","title":"Security Context Management","text":"<p>Spring Security manages the security context across requests through:</p> <ol> <li>SecurityContextPersistenceFilter: Loads and saves SecurityContext between requests</li> <li>SecurityContextRepository: Interface for storing contexts (default: HttpSessionSecurityContextRepository)</li> <li>SecurityContextHolderStrategy: Strategy for storing context (default: ThreadLocalSecurityContextHolderStrategy)</li> </ol>"},{"location":"spring-boot/spring-boot-security/#websecurityconfigureradapter-legacy-pre-spring-security-57","title":"WebSecurityConfigurerAdapter (Legacy, pre-Spring Security 5.7)","text":"<p>In versions before 5.7, this adapter class was used to customize web security:</p> <pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                .antMatchers(\"/public/**\").permitAll()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .loginPage(\"/login\")\n                .permitAll();\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth\n            .inMemoryAuthentication()\n                .withUser(\"user\")\n                .password(\"{noop}password\")\n                .roles(\"USER\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#component-based-security-configuration-spring-security-57","title":"Component-Based Security Configuration (Spring Security 5.7+)","text":"<p>In modern Spring Security, the recommended approach uses component-based configuration:</p> <pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authorize -&gt; authorize\n                .requestMatchers(\"/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .formLogin(form -&gt; form\n                .loginPage(\"/login\")\n                .permitAll()\n            );\n        return http.build();\n    }\n\n    @Bean\n    public UserDetailsService userDetailsService() {\n        UserDetails user = User.withDefaultPasswordEncoder()\n            .username(\"user\")\n            .password(\"password\")\n            .roles(\"USER\")\n            .build();\n        return new InMemoryUserDetailsManager(user);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#requestmatcher","title":"RequestMatcher","text":"<p>Spring Security uses RequestMatcher to determine which security rules apply to which requests:</p> <ul> <li><code>AntPathRequestMatcher</code>: Ant-style path patterns</li> <li><code>MvcRequestMatcher</code>: Spring MVC pattern matching</li> <li><code>RegexRequestMatcher</code>: Regular expression-based matching</li> </ul>"},{"location":"spring-boot/spring-boot-security/#filter-security-interceptor","title":"Filter Security Interceptor","text":"<p>FilterSecurityInterceptor makes the final access control decision. It:</p> <ol> <li>Uses SecurityMetadataSource to get attributes for a request</li> <li>Retrieves the Authentication from SecurityContext</li> <li>Delegates to AccessDecisionManager to make the authorization decision</li> </ol>"},{"location":"spring-boot/spring-boot-security/#authentication-mechanisms","title":"Authentication Mechanisms","text":"<p>Spring Security supports multiple authentication mechanisms that can be configured based on your application's requirements.</p>"},{"location":"spring-boot/spring-boot-security/#form-based-authentication","title":"Form-Based Authentication","text":"<p>The most common web authentication method using HTML forms:</p> <pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests(authorize -&gt; authorize\n            .anyRequest().authenticated()\n        )\n        .formLogin(form -&gt; form\n            .loginPage(\"/login\")               // Custom login page URL\n            .loginProcessingUrl(\"/perform-login\") // URL to submit the credentials\n            .defaultSuccessUrl(\"/home\")        // Redirect after successful login\n            .failureUrl(\"/login?error=true\")   // Redirect after failed login\n            .usernameParameter(\"username\")     // Username parameter name in form\n            .passwordParameter(\"password\")     // Password parameter name in form\n            .permitAll()                       // Allow access to login page\n        );\n    return http.build();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<p>Simple authentication scheme built into the HTTP protocol:</p> <pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests(authorize -&gt; authorize\n            .anyRequest().authenticated()\n        )\n        .httpBasic(Customizer.withDefaults());\n    return http.build();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#remember-me-authentication","title":"Remember-Me Authentication","text":"<p>Allows returning users to be remembered:</p> <pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests(authorize -&gt; authorize\n            .anyRequest().authenticated()\n        )\n        .formLogin(Customizer.withDefaults())\n        .rememberMe(remember -&gt; remember\n            .key(\"uniqueAndSecretKey\")\n            .tokenValiditySeconds(86400) // 1 day\n        );\n    return http.build();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#custom-authentication-providers","title":"Custom Authentication Providers","text":"<p>For custom authentication logic, implement the AuthenticationProvider interface:</p> <pre><code>@Component\npublic class CustomAuthenticationProvider implements AuthenticationProvider {\n\n    @Override\n    public Authentication authenticate(Authentication authentication) \n      throws AuthenticationException {\n        String username = authentication.getName();\n        String password = authentication.getCredentials().toString();\n\n        // Custom authentication logic\n        if (shouldAuthenticateUser(username, password)) {\n            List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n            authorities.add(new SimpleGrantedAuthority(\"ROLE_USER\"));\n            return new UsernamePasswordAuthenticationToken(username, password, authorities);\n        } else {\n            throw new BadCredentialsException(\"Authentication failed\");\n        }\n    }\n\n    @Override\n    public boolean supports(Class&lt;?&gt; authentication) {\n        return authentication.equals(UsernamePasswordAuthenticationToken.class);\n    }\n\n    private boolean shouldAuthenticateUser(String username, String password) {\n        // Implement custom validation logic\n        return true; // Placeholder\n    }\n}\n</code></pre> <p>Then register it:</p> <pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests(authorize -&gt; authorize\n            .anyRequest().authenticated()\n        )\n        .formLogin(Customizer.withDefaults());\n    return http.build();\n}\n\n@Bean\npublic AuthenticationManager authenticationManager(\n        AuthenticationConfiguration authConfig) throws Exception {\n    return authConfig.getAuthenticationManager();\n}\n\n@Autowired\npublic void configureGlobal(AuthenticationManagerBuilder auth,\n                           CustomAuthenticationProvider customAuthProvider) {\n    auth.authenticationProvider(customAuthProvider);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#ldap-authentication","title":"LDAP Authentication","text":"<p>For organizations using LDAP directories:</p> <pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests(authorize -&gt; authorize\n            .anyRequest().authenticated()\n        )\n        .formLogin(Customizer.withDefaults());\n    return http.build();\n}\n\n@Bean\npublic EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() {\n    EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean =\n        EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer();\n    contextSourceFactoryBean.setPort(0);\n    return contextSourceFactoryBean;\n}\n\n@Bean\npublic LdapAuthenticationProvider ldapAuthenticationProvider(\n        BaseLdapPathContextSource contextSource) {\n    BindAuthenticator authenticator = new BindAuthenticator(contextSource);\n    authenticator.setUserDnPatterns(new String[] { \"uid={0},ou=people\" });\n\n    LdapAuthoritiesPopulator authoritiesPopulator = new DefaultLdapAuthoritiesPopulator(\n            contextSource, \"ou=groups\");\n    authoritiesPopulator.setGroupRoleAttribute(\"cn\");\n\n    return new LdapAuthenticationProvider(authenticator, authoritiesPopulator);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#database-authentication","title":"Database Authentication","text":"<p>Using a database to store user credentials:</p> <p><pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests(authorize -&gt; authorize\n            .anyRequest().authenticated()\n        )\n        .formLogin(Customizer.withDefaults());\n    return http.build();\n}\n\n@Bean\npublic UserDetailsService userDetailsService(DataSource dataSource) {\n    JdbcUserDetailsManager userDetailsManager = new JdbcUserDetailsManager(dataSource);\n    // Optional: customize queries\n    userDetailsManager.setUsersByUsernameQuery(\n            \"SELECT username, password, enabled FROM users WHERE username = ?\");\n    userDetailsManager.setAuthoritiesByUsernameQuery(\n            \"SELECT username, authority FROM authorities WHERE username = ?\");\n    return userDetailsManager;\n}\n\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n}\n\n## JWT-Based Authentication\n\nJSON Web Tokens (JWT) provide a stateless way to authenticate users, which is especially useful for APIs and microservice architectures.\n\n### Understanding JWT Structure\n\nA JWT consists of three parts separated by dots:\n1. **Header**: Identifies the algorithm used for signing\n2. **Payload**: Contains claims about the entity (user) and metadata\n3. **Signature**: Ensures the token hasn't been altered\n\nExample JWT:\n</code></pre> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c <pre><code>### JWT Authentication Flow\n\n1. User logs in with credentials\n2. Server validates credentials and generates a JWT\n3. Server returns the JWT to the client\n4. Client stores the JWT (usually in localStorage or a cookie)\n5. Client sends the JWT in the Authorization header for subsequent requests\n6. Server validates the JWT signature and extracts user information\n7. Server grants access based on the user's authorities\n\n### Implementing JWT Authentication in Spring Boot\n\n#### Dependencies\n\n```xml\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;\n    &lt;version&gt;0.11.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;\n    &lt;version&gt;0.11.5&lt;/version&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;\n    &lt;version&gt;0.11.5&lt;/version&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre></p>"},{"location":"spring-boot/spring-boot-security/#jwt-utility-class","title":"JWT Utility Class","text":"<pre><code>@Component\npublic class JwtTokenUtil {\n\n    @Value(\"${jwt.secret}\")\n    private String secret;\n\n    @Value(\"${jwt.expiration}\")\n    private long expiration;\n\n    private Key key;\n\n    @PostConstruct\n    public void init() {\n        this.key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secret));\n    }\n\n    public String generateToken(UserDetails userDetails) {\n        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();\n        Collection&lt;? extends GrantedAuthority&gt; authorities = userDetails.getAuthorities();\n        if (!authorities.isEmpty()) {\n            claims.put(\"authorities\", authorities.stream()\n                    .map(GrantedAuthority::getAuthority)\n                    .collect(Collectors.toList()));\n        }\n\n        return Jwts.builder()\n                .setClaims(claims)\n                .setSubject(userDetails.getUsername())\n                .setIssuedAt(new Date(System.currentTimeMillis()))\n                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))\n                .signWith(key, SignatureAlgorithm.HS512)\n                .compact();\n    }\n\n    public String getUsernameFromToken(String token) {\n        return Jwts.parserBuilder()\n                .setSigningKey(key)\n                .build()\n                .parseClaimsJws(token)\n                .getBody()\n                .getSubject();\n    }\n\n    public boolean validateToken(String token, UserDetails userDetails) {\n        final String username = getUsernameFromToken(token);\n        return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));\n    }\n\n    private boolean isTokenExpired(String token) {\n        final Date expiration = getExpirationDateFromToken(token);\n        return expiration.before(new Date());\n    }\n\n    private Date getExpirationDateFromToken(String token) {\n        return Jwts.parserBuilder()\n                .setSigningKey(key)\n                .build()\n                .parseClaimsJws(token)\n                .getBody()\n                .getExpiration();\n    }\n\n    public List&lt;SimpleGrantedAuthority&gt; getAuthoritiesFromToken(String token) {\n        Claims claims = Jwts.parserBuilder()\n                .setSigningKey(key)\n                .build()\n                .parseClaimsJws(token)\n                .getBody();\n\n        List&lt;String&gt; authorities = claims.get(\"authorities\", List.class);\n        if (authorities == null) {\n            return Collections.emptyList();\n        }\n\n        return authorities.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#jwt-request-filter","title":"JWT Request Filter","text":"<pre><code>@Component\npublic class JwtRequestFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, \n                                   FilterChain chain) throws ServletException, IOException {\n\n        final String requestTokenHeader = request.getHeader(\"Authorization\");\n\n        String username = null;\n        String jwtToken = null;\n\n        // JWT Token is in the form \"Bearer token\". Remove Bearer word and get only the Token\n        if (requestTokenHeader != null &amp;&amp; requestTokenHeader.startsWith(\"Bearer \")) {\n            jwtToken = requestTokenHeader.substring(7);\n            try {\n                username = jwtTokenUtil.getUsernameFromToken(jwtToken);\n            } catch (IllegalArgumentException e) {\n                logger.error(\"Unable to get JWT Token\");\n            } catch (ExpiredJwtException e) {\n                logger.error(\"JWT Token has expired\");\n            }\n        } else {\n            logger.warn(\"JWT Token does not begin with Bearer String\");\n        }\n\n        // Once we get the token validate it.\n        if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {\n\n            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n\n            // If token is valid configure Spring Security to manually set authentication\n            if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {\n                List&lt;SimpleGrantedAuthority&gt; authorities = jwtTokenUtil.getAuthoritiesFromToken(jwtToken);\n\n                UsernamePasswordAuthenticationToken authentication =\n                        new UsernamePasswordAuthenticationToken(\n                                userDetails, null, authorities);\n\n                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n                // Set authentication in context\n                SecurityContextHolder.getContext().setAuthentication(authentication);\n            }\n        }\n        chain.doFilter(request, response);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#authentication-controller","title":"Authentication Controller","text":"<pre><code>@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @PostMapping(\"/login\")\n    public ResponseEntity&lt;?&gt; createAuthenticationToken(@RequestBody LoginRequest authenticationRequest) {\n\n        try {\n            authenticationManager.authenticate(\n                    new UsernamePasswordAuthenticationToken(\n                            authenticationRequest.getUsername(), \n                            authenticationRequest.getPassword())\n            );\n        } catch (BadCredentialsException e) {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                    .body(new MessageResponse(\"Invalid credentials\"));\n        }\n\n        final UserDetails userDetails = userDetailsService\n                .loadUserByUsername(authenticationRequest.getUsername());\n\n        final String token = jwtTokenUtil.generateToken(userDetails);\n\n        return ResponseEntity.ok(new JwtResponse(token));\n    }\n\n    // Login request class\n    public static class LoginRequest {\n        private String username;\n        private String password;\n\n        // Getters and setters\n    }\n\n    // JWT response class\n    public static class JwtResponse {\n        private String token;\n\n        public JwtResponse(String token) {\n            this.token = token;\n        }\n\n        // Getter\n    }\n\n    // Message response class\n    public static class MessageResponse {\n        private String message;\n\n        public MessageResponse(String message) {\n            this.message = message;\n        }\n\n        // Getter\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#security-configuration","title":"Security Configuration","text":"<pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtRequestFilter jwtRequestFilter;\n\n    @Autowired\n    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf(csrf -&gt; csrf.disable())\n            .authorizeHttpRequests(authorize -&gt; authorize\n                .requestMatchers(\"/api/auth/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .exceptionHandling(exception -&gt; exception\n                .authenticationEntryPoint(jwtAuthenticationEntryPoint)\n            )\n            .sessionManagement(session -&gt; session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            );\n\n        // Add JWT filter\n        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager(\n            AuthenticationConfiguration authConfig) throws Exception {\n        return authConfig.getAuthenticationManager();\n    }\n}\n\n@Component\nclass JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response,\n                        AuthenticationException authException) throws IOException {\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#jwt-security-best-practices","title":"JWT Security Best Practices","text":"<ol> <li>Use HTTPS: Always transmit JWTs over HTTPS to prevent token theft</li> <li>Set Proper Expiration: Short-lived tokens reduce risk if stolen</li> <li>Secure Token Storage: Don't store in localStorage (vulnerable to XSS); consider HttpOnly cookies</li> <li>Include Only Necessary Claims: Minimize sensitive data in tokens</li> <li>Use Strong Secret Keys: Long, random keys for HMAC algorithms</li> <li>Consider Using Asymmetric Algorithms: RSA or ECDSA for better security</li> <li>Implement Token Revocation: Blacklist or use refresh token pattern</li> <li>Validate All Inputs: Especially in token payloads</li> <li>Add Fingerprint Claims: Include IP or device info to prevent token reuse</li> <li>Monitor and Audit: Log authentication attempts and token usage</li> </ol>"},{"location":"spring-boot/spring-boot-security/#keycloak-integration","title":"Keycloak Integration","text":"<p>Keycloak is an open-source Identity and Access Management solution that provides features like Single Sign-On (SSO), Identity Brokering, and Social Login.</p>"},{"location":"spring-boot/spring-boot-security/#keycloak-architecture","title":"Keycloak Architecture","text":"<p>Keycloak functions as an identity provider that manages: - User registration, authentication, and authorization - Client application registration - Identity brokering with external providers - User federation with existing LDAP or Active Directory servers - Social login</p>"},{"location":"spring-boot/spring-boot-security/#setting-up-keycloak-for-spring-boot","title":"Setting Up Keycloak for Spring Boot","text":""},{"location":"spring-boot/spring-boot-security/#add-dependencies","title":"Add Dependencies","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#configure-keycloak-properties","title":"Configure Keycloak Properties","text":"<pre><code># application.properties\nspring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8080/realms/your-realm\nspring.security.oauth2.resourceserver.jwt.jwk-set-uri=http://localhost:8080/realms/your-realm/protocol/openid-connect/certs\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#configure-security","title":"Configure Security","text":"<pre><code>@Configuration\n@EnableWebSecurity\npublic class KeycloakSecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf(csrf -&gt; csrf.disable())\n            .authorizeHttpRequests(authorize -&gt; authorize\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/api/user/**\").hasRole(\"USER\")\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -&gt; oauth2\n                .jwt(jwt -&gt; jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))\n            );\n\n        return http.build();\n    }\n\n    private Converter&lt;Jwt, AbstractAuthenticationToken&gt; jwtAuthenticationConverter() {\n        JwtAuthenticationConverter jwtConverter = new JwtAuthenticationConverter();\n        jwtConverter.setJwtGrantedAuthoritiesConverter(new KeycloakRoleConverter());\n        return jwtConverter;\n    }\n\n    public class KeycloakRoleConverter implements Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt; {\n        @Override\n        public Collection&lt;GrantedAuthority&gt; convert(Jwt jwt) {\n            final Map&lt;String, Object&gt; realmAccess = \n                    (Map&lt;String, Object&gt;) jwt.getClaims().get(\"realm_access\");\n\n            if (realmAccess == null) {\n                return new ArrayList&lt;&gt;();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            List&lt;String&gt; roles = (List&lt;String&gt;) realmAccess.get(\"roles\");\n\n            return roles.stream()\n                    .map(roleName -&gt; \"ROLE_\" + roleName.toUpperCase())\n                    .map(SimpleGrantedAuthority::new)\n                    .collect(Collectors.toList());\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#jwt-with-keycloak","title":"JWT with Keycloak","text":"<p>Keycloak issues JWTs that Spring Security can validate. The key difference from custom JWT implementation is that Keycloak manages:</p> <ol> <li>Token issuance</li> <li>User management</li> <li>Token validation</li> <li>Role mappings</li> </ol>"},{"location":"spring-boot/spring-boot-security/#keycloak-as-an-oauth2-authorization-server","title":"Keycloak as an OAuth2 Authorization Server","text":"<p>Keycloak can act as an OAuth2 Authorization Server, supporting these grant types:</p> <ol> <li>Authorization Code: For web applications</li> <li>Implicit: For SPA applications (deprecated in favor of PKCE)</li> <li>Resource Owner Password Credentials: For trusted applications</li> <li>Client Credentials: For service-to-service communication</li> <li>Refresh Token: For obtaining new access tokens</li> </ol>"},{"location":"spring-boot/spring-boot-security/#client-registration-in-keycloak","title":"Client Registration in Keycloak","text":"<p>To use Keycloak, you need to register your application as a client:</p> <ol> <li>Create a new client in Keycloak admin console</li> <li>Set the client protocol to <code>openid-connect</code></li> <li>Configure Valid Redirect URIs</li> <li>Choose the appropriate Access Type (public, confidential, or bearer-only)</li> <li>Configure client scopes</li> <li>Set up client roles if needed</li> </ol>"},{"location":"spring-boot/spring-boot-security/#full-oauth2-login-with-keycloak","title":"Full OAuth2 Login with Keycloak","text":"<p>For a complete login flow where users are redirected to Keycloak:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code># application.properties\nspring.security.oauth2.client.registration.keycloak.client-id=your-client-id\nspring.security.oauth2.client.registration.keycloak.client-secret=your-client-secret\nspring.security.oauth2.client.registration.keycloak.scope=openid,profile,email,roles\nspring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code\nspring.security.oauth2.client.registration.keycloak.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}\n\nspring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8080/realms/your-realm\nspring.security.oauth2.client.provider.keycloak.user-name-attribute=preferred_username\n</code></pre> <pre><code>@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authorize -&gt; authorize\n                .requestMatchers(\"/\", \"/error\", \"/webjars/**\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(oauth2 -&gt; oauth2\n                .userInfoEndpoint(userInfo -&gt; userInfo\n                    .userAuthoritiesMapper(this.userAuthoritiesMapper())\n                )\n            );\n\n        return http.build();\n    }\n\n    private GrantedAuthoritiesMapper userAuthoritiesMapper() {\n        return (authorities) -&gt; {\n            Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();\n\n            authorities.forEach(authority -&gt; {\n                if (authority instanceof OidcUserAuthority) {\n                    OidcUserAuthority oidcUserAuthority = (OidcUserAuthority) authority;\n                    OidcIdToken idToken = oidcUserAuthority.getIdToken();\n\n                    Map&lt;String, Object&gt; claims = idToken.getClaims();\n                    Map&lt;String, Object&gt; realmAccess = (Map&lt;String, Object&gt;) claims.get(\"realm_access\");\n\n                    if (realmAccess != null) {\n                        @SuppressWarnings(\"unchecked\")\n                        List&lt;String&gt; roles = (List&lt;String&gt;) realmAccess.get(\"roles\");\n\n                        roles.forEach(role -&gt; \n                            mappedAuthorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.toUpperCase()))\n                        );\n                    }\n                }\n\n                // Add the original authority\n                mappedAuthorities.add(authority);\n            });\n\n            return mappedAuthorities;\n        };\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#obtaining-tokens-programmatically","title":"Obtaining Tokens Programmatically","text":"<p>For service-to-service authentication or testing:</p> <pre><code>@Service\npublic class KeycloakService {\n\n    @Value(\"${keycloak.auth-server-url}\")\n    private String authServerUrl;\n\n    @Value(\"${keycloak.realm}\")\n    private String realm;\n\n    @Value(\"${keycloak.resource}\")\n    private String clientId;\n\n    @Value(\"${keycloak.credentials.secret}\")\n    private String clientSecret;\n\n    public String getToken(String username, String password) {\n        String tokenUrl = authServerUrl + \"/realms/\" + realm + \"/protocol/openid-connect/token\";\n\n        MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();\n        map.add(\"grant_type\", \"password\");\n        map.add(\"client_id\", clientId);\n        map.add(\"client_secret\", clientSecret);\n        map.add(\"username\", username);\n        map.add(\"password\", password);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\n        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);\n\n        RestTemplate restTemplate = new RestTemplate();\n\n        ResponseEntity&lt;Map&gt; response = restTemplate.postForEntity(\n                tokenUrl, request, Map.class);\n\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return (String) response.getBody().get(\"access_token\");\n        }\n\n        throw new RuntimeException(\"Could not get token\");\n    }\n\n    public String getClientToken() {\n        String tokenUrl = authServerUrl + \"/realms/\" + realm + \"/protocol/openid-connect/token\";\n\n        MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();\n        map.add(\"grant_type\", \"client_credentials\");\n        map.add(\"client_id\", clientId);\n        map.add(\"client_secret\", clientSecret);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\n        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);\n\n        RestTemplate restTemplate = new RestTemplate();\n\n        ResponseEntity&lt;Map&gt; response = restTemplate.postForEntity(\n                tokenUrl, request, Map.class);\n\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return (String) response.getBody().get(\"access_token\");\n        }\n\n        throw new RuntimeException(\"Could not get token\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#user-management-with-keycloak","title":"User Management with Keycloak","text":"<p>For managing users through the Keycloak Admin REST API:</p> <pre><code>@Service\npublic class KeycloakAdminService {\n\n    @Value(\"${keycloak.auth-server-url}\")\n    private String authServerUrl;\n\n    @Value(\"${keycloak.realm}\")\n    private String realm;\n\n    @Autowired\n    private KeycloakService keycloakService;\n\n    public void createUser(String username, String email, String firstName, String lastName, String password) {\n        String adminToken = keycloakService.getClientToken();\n\n        String userUrl = authServerUrl + \"/admin/realms/\" + realm + \"/users\";\n\n        Map&lt;String, Object&gt; user = new HashMap&lt;&gt;();\n        user.put(\"username\", username);\n        user.put(\"email\", email);\n        user.put(\"firstName\", firstName);\n        user.put(\"lastName\", lastName);\n        user.put(\"enabled\", true);\n\n        Map&lt;String, Object&gt; credentials = new HashMap&lt;&gt;();\n        credentials.put(\"type\", \"password\");\n        credentials.put(\"value\", password);\n        credentials.put(\"temporary\", false);\n\n        user.put(\"credentials\", List.of(credentials));\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        headers.setBearerAuth(adminToken);\n\n        HttpEntity&lt;Map&lt;String, Object&gt;&gt; request = new HttpEntity&lt;&gt;(user, headers);\n\n        RestTemplate restTemplate = new RestTemplate();\n\n        ResponseEntity&lt;Void&gt; response = restTemplate.exchange(\n                userUrl, HttpMethod.POST, request, Void.class);\n\n        if (response.getStatusCode() != HttpStatus.CREATED) {\n            throw new RuntimeException(\"Could not create user: \" + response.getStatusCode());\n        }\n    }\n\n    // More user management methods can be added here\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-security/#keycloak-best-practices","title":"Keycloak Best Practices","text":"<ol> <li>Use HTTPS: Secure all communications with Keycloak</li> <li>Proper Client Configuration: Use confidential clients with client secrets for backend applications</li> <li>Implement Proper Scopes: Only request necessary scopes</li> <li>Use Authorization Code Flow with PKCE: For web and mobile applications</li> <li>Keep Keycloak Updated: Regularly apply security updates</li> <li>Configure Session Timeouts: Set appropriate token lifetimes</li> <li>Use Proper SSL Certificates: Avoid certificate validation issues</li> <li>Implement User Consent: For sensitive operations</li> <li>Enable Brute Force Protection: Protect against login attacks</li> <li>Audit Regularly: Review authentication logs periodically </li> </ol>"},{"location":"spring-boot/spring-boot-starter/","title":"Spring Boot: Getting Started","text":""},{"location":"spring-boot/spring-boot-starter/#overview","title":"Overview","text":"<p>Spring Boot is a powerful framework within the Spring ecosystem that simplifies Java application development by providing a convention-over-configuration approach. It eliminates much of the boilerplate code and configuration required in traditional Spring applications, allowing developers to focus on business logic. Spring Boot combines the extensive functionality of the Spring Framework with opinionated defaults, embedded servers, and auto-configuration to create standalone, production-grade applications with minimal effort.</p>"},{"location":"spring-boot/spring-boot-starter/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic Java programming knowledge</li> <li>Understanding of object-oriented programming concepts</li> <li>Familiarity with build tools (Maven/Gradle)</li> <li>Basic knowledge of web application concepts</li> <li>Understanding of dependency injection and inversion of control principles</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the core features and benefits of Spring Boot</li> <li>Set up a Spring Boot development environment</li> <li>Create and run a simple Spring Boot application</li> <li>Explore Spring Boot project structure and conventions</li> <li>Configure Spring Boot applications using properties and YAML</li> <li>Understand Spring Boot starters and auto-configuration</li> <li>Implement basic RESTful APIs using Spring Boot</li> <li>Use Spring Boot DevTools for development productivity</li> <li>Package Spring Boot applications for deployment</li> <li>Troubleshoot common Spring Boot issues</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Spring Boot</li> <li>Setting Up Development Environment</li> <li>Creating Your First Spring Boot Application</li> <li>Spring Boot Project Structure</li> <li>Spring Boot Starters</li> <li>Auto-Configuration</li> <li>Configuration Properties</li> <li>Building a Simple REST API</li> <li>Spring Boot DevTools</li> <li>Packaging and Running Spring Boot Applications</li> <li>Common Issues and Troubleshooting</li> <li>Next Steps</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#introduction-to-spring-boot","title":"Introduction to Spring Boot","text":""},{"location":"spring-boot/spring-boot-starter/#what-is-spring-boot","title":"What is Spring Boot?","text":"<p>Spring Boot is a project within the Spring ecosystem designed to simplify the development process of Spring applications. It takes an opinionated view of the Spring platform and third-party libraries, allowing developers to get started with minimal configuration.</p>"},{"location":"spring-boot/spring-boot-starter/#key-features-and-benefits","title":"Key Features and Benefits","text":""},{"location":"spring-boot/spring-boot-starter/#1-opinionated-defaults","title":"1. Opinionated Defaults","text":"<p>Spring Boot provides sensible defaults for application configuration, eliminating the need for extensive XML configuration or boilerplate code.</p> <pre><code>// Traditional Spring configuration required XML files or Java config classes\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.example\")\npublic class AppConfig {\n    // Various bean definitions and configurations\n}\n\n// With Spring Boot, minimal or no explicit configuration is needed\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#2-standalone-applications","title":"2. Standalone Applications","text":"<p>Spring Boot applications can be run as standalone JAR files with an embedded server, eliminating the need for external application servers.</p>"},{"location":"spring-boot/spring-boot-starter/#3-auto-configuration","title":"3. Auto-Configuration","text":"<p>Spring Boot automatically configures your application based on the dependencies on the classpath, reducing boilerplate configuration.</p>"},{"location":"spring-boot/spring-boot-starter/#4-spring-boot-starters","title":"4. Spring Boot Starters","text":"<p>Curated sets of dependencies that simplify the build configuration and provide specific functionality.</p>"},{"location":"spring-boot/spring-boot-starter/#5-production-ready-features","title":"5. Production-Ready Features","text":"<p>Built-in metrics, health checks, and externalized configuration for production environments.</p>"},{"location":"spring-boot/spring-boot-starter/#spring-boot-vs-traditional-spring-framework","title":"Spring Boot vs. Traditional Spring Framework","text":"Feature Traditional Spring Spring Boot Configuration Extensive XML or Java configuration Minimal, auto-configured Dependencies Manual dependency management Starter dependencies with compatible versions Deployment WAR files deployed to app servers Standalone JAR with embedded server Boilerplate Significant setup code required Minimized with sensible defaults Server External application server required Embedded server (Tomcat, Jetty, Undertow) Production Manual configuration of monitoring Built-in actuator with metrics, health checks"},{"location":"spring-boot/spring-boot-starter/#spring-boot-version-history","title":"Spring Boot Version History","text":"<p>Spring Boot follows semantic versioning (MAJOR.MINOR.PATCH):</p> <ul> <li>Spring Boot 1.0 (2014): Initial release</li> <li>Spring Boot 1.5: Improved DevTools, Actuator enhancements</li> <li>Spring Boot 2.0 (2018): Upgraded to Spring Framework 5, Java 8 baseline</li> <li>Spring Boot 2.3: Improved Docker support, graceful shutdown</li> <li>Spring Boot 2.4: Configuration data refactoring</li> <li>Spring Boot 2.7: Current maintenance release</li> <li>Spring Boot 3.0 (2022): Java 17 baseline, Spring Framework 6, Jakarta EE</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<p>A proper development environment is essential for efficient Spring Boot development.</p>"},{"location":"spring-boot/spring-boot-starter/#required-software","title":"Required Software","text":"<ol> <li>Java Development Kit (JDK)</li> <li>Spring Boot 3.x requires Java 17 or higher</li> <li> <p>Spring Boot 2.x requires Java 8 or higher</p> </li> <li> <p>Build Tool</p> </li> <li> <p>Maven (3.6+) or Gradle (7.0+)</p> </li> <li> <p>Integrated Development Environment (IDE)</p> </li> <li>Spring Tool Suite (Eclipse-based, tailored for Spring)</li> <li>IntelliJ IDEA</li> <li> <p>Visual Studio Code with Spring Boot extensions</p> </li> <li> <p>Other Optional Tools</p> </li> <li>Postman/Insomnia for API testing</li> <li>Git for version control</li> <li>Docker for containerization</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#installation-steps","title":"Installation Steps","text":""},{"location":"spring-boot/spring-boot-starter/#installing-jdk","title":"Installing JDK","text":"<ol> <li>Download JDK from Oracle or use OpenJDK</li> <li>Set JAVA_HOME environment variable:</li> </ol> <pre><code># Linux/macOS\nexport JAVA_HOME=/path/to/jdk\nexport PATH=$JAVA_HOME/bin:$PATH\n\n# Windows\nset JAVA_HOME=C:\\path\\to\\jdk\nset PATH=%JAVA_HOME%\\bin;%PATH%\n</code></pre> <ol> <li>Verify installation:</li> </ol> <pre><code>java -version\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#installing-maven","title":"Installing Maven","text":"<ol> <li>Download Maven from Apache Maven website</li> <li>Extract to a directory</li> <li>Set environment variables:</li> </ol> <pre><code># Linux/macOS\nexport M2_HOME=/path/to/maven\nexport PATH=$M2_HOME/bin:$PATH\n\n# Windows\nset M2_HOME=C:\\path\\to\\maven\nset PATH=%M2_HOME%\\bin;%PATH%\n</code></pre> <ol> <li>Verify installation:</li> </ol> <pre><code>mvn -version\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#installing-gradle","title":"Installing Gradle","text":"<ol> <li>Download from Gradle website</li> <li>Extract to a directory</li> <li>Set environment variables:</li> </ol> <pre><code># Linux/macOS\nexport GRADLE_HOME=/path/to/gradle\nexport PATH=$GRADLE_HOME/bin:$PATH\n\n# Windows\nset GRADLE_HOME=C:\\path\\to\\gradle\nset PATH=%GRADLE_HOME%\\bin;%PATH%\n</code></pre> <ol> <li>Verify installation:</li> </ol> <pre><code>gradle -version\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#ide-setup","title":"IDE Setup","text":""},{"location":"spring-boot/spring-boot-starter/#spring-tool-suite-sts","title":"Spring Tool Suite (STS)","text":"<ol> <li>Download from Spring website</li> <li>Install by extracting the archive</li> <li>Run the executable</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#intellij-idea","title":"IntelliJ IDEA","text":"<ol> <li>Download from JetBrains website</li> <li>Install and run</li> <li>Install Spring plugins:</li> <li>Go to Preferences/Settings \u2192 Plugins</li> <li>Search and install \"Spring Boot\" and \"Spring Initializr\"</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li>Install VS Code from official website</li> <li>Install extensions:</li> <li>Spring Boot Extension Pack</li> <li>Java Extension Pack</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#creating-your-first-spring-boot-application","title":"Creating Your First Spring Boot Application","text":"<p>Let's create a simple \"Hello World\" Spring Boot application using different methods.</p>"},{"location":"spring-boot/spring-boot-starter/#using-spring-initializr-web-interface","title":"Using Spring Initializr Web Interface","text":"<ol> <li>Navigate to start.spring.io</li> <li>Configure your project:</li> <li>Project: Maven/Gradle</li> <li>Language: Java</li> <li>Spring Boot version: Select latest stable</li> <li>Group: com.example</li> <li>Artifact: demo</li> <li>Dependencies: Spring Web</li> <li>Click \"Generate\" to download the project zip</li> <li>Extract and import into your IDE</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#using-spring-boot-cli","title":"Using Spring Boot CLI","text":"<ol> <li>Install Spring Boot CLI:</li> </ol> <pre><code># Using SDKMAN\nsdk install springboot\n\n# Using Homebrew (macOS)\nbrew tap spring-io/tap\nbrew install spring-boot\n</code></pre> <ol> <li>Create an application:</li> </ol> <pre><code>spring init --dependencies=web,jpa my-project\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#using-ide","title":"Using IDE","text":""},{"location":"spring-boot/spring-boot-starter/#spring-tool-suite","title":"Spring Tool Suite","text":"<ol> <li>File \u2192 New \u2192 Spring Starter Project</li> <li>Configure project details</li> <li>Select dependencies</li> <li>Click Finish</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#intellij-idea_1","title":"IntelliJ IDEA","text":"<ol> <li>File \u2192 New \u2192 Project</li> <li>Select Spring Initializr</li> <li>Configure project details</li> <li>Select dependencies</li> <li>Click Next/Finish</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#project-structure-overview","title":"Project Structure Overview","text":"<p>After generating the project, you'll see a structure like:</p> <pre><code>my-project/\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 com/\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 example/\n\u2502   \u2502   \u2502           \u2514\u2500\u2500 demo/\n\u2502   \u2502   \u2502               \u2514\u2500\u2500 DemoApplication.java\n\u2502   \u2502   \u2514\u2500\u2500 resources/\n\u2502   \u2502       \u251c\u2500\u2500 application.properties\n\u2502   \u2502       \u251c\u2500\u2500 static/\n\u2502   \u2502       \u2514\u2500\u2500 templates/\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 test/\n\u2502       \u2514\u2500\u2500 java/\n\u2502           \u2514\u2500\u2500 com/\n\u2502               \u2514\u2500\u2500 example/\n\u2502                   \u2514\u2500\u2500 demo/\n\u2502                       \u2514\u2500\u2500 DemoApplicationTests.java\n\u2502\n\u251c\u2500\u2500 pom.xml (or build.gradle)\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#writing-a-hello-world-controller","title":"Writing a Hello World Controller","text":"<p>Add a simple REST controller:</p> <pre><code>package com.example.demo;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello, Spring Boot!\";\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#running-the-application","title":"Running the Application","text":""},{"location":"spring-boot/spring-boot-starter/#from-ide","title":"From IDE","text":"<ol> <li>Find the main application class with <code>@SpringBootApplication</code> annotation</li> <li>Right-click and select \"Run\"</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#from-command-line","title":"From Command Line","text":"<p>Using Maven: <pre><code>./mvnw spring-boot:run\n</code></pre></p> <p>Using Gradle: <pre><code>./gradlew bootRun\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#testing-the-application","title":"Testing the Application","text":"<p>Open a web browser or use curl: <pre><code>curl http://localhost:8080/hello\n</code></pre></p> <p>You should see the output: <code>Hello, Spring Boot!</code></p>"},{"location":"spring-boot/spring-boot-starter/#understanding-the-main-application-class","title":"Understanding the Main Application Class","text":"<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}\n</code></pre> <p>The <code>@SpringBootApplication</code> annotation combines: - <code>@Configuration</code>: Tags the class as a source of bean definitions - <code>@EnableAutoConfiguration</code>: Tells Spring Boot to start adding beans based on classpath - <code>@ComponentScan</code>: Tells Spring to scan for components in the current package and subpackages </p>"},{"location":"spring-boot/spring-boot-starter/#spring-boot-project-structure","title":"Spring Boot Project Structure","text":"<p>Understanding the standard Spring Boot project structure helps developers navigate and organize their applications efficiently.</p>"},{"location":"spring-boot/spring-boot-starter/#default-directory-structure","title":"Default Directory Structure","text":"<pre><code>my-project/\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 java/         # Java source code\n\u2502   \u2502   \u251c\u2500\u2500 resources/    # Configuration files and resources\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 static/   # Static web resources (CSS, JS, images)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 templates/  # Template files (Thymeleaf, FreeMarker, etc.)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 application.properties/yml  # Application configuration\n\u2502   \u2502   \u2514\u2500\u2500 webapp/       # Traditional web application resources (rarely used in Boot)\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 test/\n\u2502       \u251c\u2500\u2500 java/         # Test code\n\u2502       \u2514\u2500\u2500 resources/    # Test configuration and resources\n\u2502\n\u251c\u2500\u2500 target/ or build/     # Compiled output (auto-generated)\n\u251c\u2500\u2500 pom.xml or build.gradle  # Build configuration\n\u2514\u2500\u2500 README.md, .gitignore, etc.\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#key-directories-and-files","title":"Key Directories and Files","text":""},{"location":"spring-boot/spring-boot-starter/#source-code","title":"Source Code","text":"<ul> <li>src/main/java: Contains application code organized by package</li> <li>src/test/java: Contains test code mirroring the main package structure</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#resources","title":"Resources","text":"<ul> <li>src/main/resources/application.properties: Configuration properties</li> <li>src/main/resources/application.yml: YAML alternative to properties</li> <li>src/main/resources/static: Static web assets served from root path</li> <li>src/main/resources/templates: Template files for view rendering</li> <li>src/main/resources/META-INF: Custom metadata like additional spring.factories</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#build-files","title":"Build Files","text":"<ul> <li>pom.xml: Maven project configuration</li> <li>build.gradle: Gradle project configuration</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#best-practices-for-project-organization","title":"Best Practices for Project Organization","text":""},{"location":"spring-boot/spring-boot-starter/#package-structure","title":"Package Structure","text":"<p>Several popular conventions exist:</p> <ol> <li> <p>Package by Layer <pre><code>com.example.demo/\n\u251c\u2500\u2500 controller/\n\u251c\u2500\u2500 service/\n\u251c\u2500\u2500 repository/\n\u251c\u2500\u2500 model/ or domain/\n\u2514\u2500\u2500 config/\n</code></pre></p> </li> <li> <p>Package by Feature <pre><code>com.example.demo/\n\u251c\u2500\u2500 user/\n\u2502   \u251c\u2500\u2500 UserController.java\n\u2502   \u251c\u2500\u2500 UserService.java\n\u2502   \u251c\u2500\u2500 User.java\n\u2502   \u2514\u2500\u2500 UserRepository.java\n\u251c\u2500\u2500 product/\n\u2502   \u251c\u2500\u2500 ProductController.java\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 common/\n</code></pre></p> </li> <li> <p>Hexagonal Architecture <pre><code>com.example.demo/\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 model/\n\u2502   \u2514\u2500\u2500 service/\n\u251c\u2500\u2500 application/\n\u2502   \u2514\u2500\u2500 service/\n\u2514\u2500\u2500 infrastructure/\n    \u251c\u2500\u2500 repository/\n    \u251c\u2500\u2500 controller/\n    \u2514\u2500\u2500 config/\n</code></pre></p> </li> </ol>"},{"location":"spring-boot/spring-boot-starter/#configuration-classes","title":"Configuration Classes","text":"<p>Best practice is to organize configuration classes in a clear manner:</p> <pre><code>// Web MVC configuration\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n    // Web-specific configuration\n}\n\n// Security configuration\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    // Security-specific configuration\n}\n\n// Database configuration\n@Configuration\n@EnableJpaRepositories\npublic class DatabaseConfig {\n    // Database-specific beans and properties\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#multi-module-projects","title":"Multi-Module Projects","text":"<p>For larger applications, consider a multi-module structure:</p> <pre><code>my-application/\n\u251c\u2500\u2500 my-application-core/       # Domain model and business logic\n\u251c\u2500\u2500 my-application-api/        # API controllers and DTOs\n\u251c\u2500\u2500 my-application-service/    # Service implementations\n\u251c\u2500\u2500 my-application-repository/ # Data access layer\n\u2514\u2500\u2500 my-application-web/        # Web UI if applicable\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#spring-boot-starters","title":"Spring Boot Starters","text":"<p>Spring Boot Starters are dependency descriptors designed to simplify dependency management by bundling related dependencies into single artifacts.</p>"},{"location":"spring-boot/spring-boot-starter/#what-are-starters","title":"What Are Starters?","text":"<p>Starters are carefully curated collections of dependencies that: - Simplify build configuration - Ensure compatible dependency versions - Provide auto-configuration - Follow a consistent naming convention: <code>spring-boot-starter-*</code></p>"},{"location":"spring-boot/spring-boot-starter/#common-starters","title":"Common Starters","text":""},{"location":"spring-boot/spring-boot-starter/#web-applications","title":"Web Applications","text":"<ul> <li> <p>spring-boot-starter-web: For building web applications including RESTful applications using Spring MVC   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> <li> <p>spring-boot-starter-webflux: For building reactive web applications   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> </ul>"},{"location":"spring-boot/spring-boot-starter/#data-access","title":"Data Access","text":"<ul> <li> <p>spring-boot-starter-data-jpa: For using Spring Data JPA with Hibernate   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> <li> <p>spring-boot-starter-data-mongodb: For working with MongoDB   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> </ul>"},{"location":"spring-boot/spring-boot-starter/#security","title":"Security","text":"<ul> <li>spring-boot-starter-security: For adding Spring Security   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></li> </ul>"},{"location":"spring-boot/spring-boot-starter/#testing","title":"Testing","text":"<ul> <li>spring-boot-starter-test: For testing Spring Boot applications   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre></li> </ul>"},{"location":"spring-boot/spring-boot-starter/#templating-engines","title":"Templating Engines","text":"<ul> <li>spring-boot-starter-thymeleaf: For using Thymeleaf template engine   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></li> </ul>"},{"location":"spring-boot/spring-boot-starter/#monitoring","title":"Monitoring","text":"<ul> <li>spring-boot-starter-actuator: For adding production-ready features   <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></li> </ul>"},{"location":"spring-boot/spring-boot-starter/#creating-custom-starters","title":"Creating Custom Starters","text":"<p>You can create custom starters for your organization to standardize dependency management and configurations.</p>"},{"location":"spring-boot/spring-boot-starter/#naming-convention","title":"Naming Convention","text":"<p>Custom starters should follow the naming convention: - <code>acme-spring-boot-starter</code>: For a starter owned by Acme company - Avoid using <code>spring-boot</code> as your starter prefix, as it's reserved for official starters</p>"},{"location":"spring-boot/spring-boot-starter/#structure-of-a-custom-starter","title":"Structure of a Custom Starter","text":"<p>A typical custom starter consists of two modules: 1. The autoconfigure module containing the auto-configuration code 2. The starter module that provides a dependency to the autoconfigure module and additional dependencies</p> <pre><code>acme-spring-boot/\n\u251c\u2500\u2500 acme-spring-boot-autoconfigure/  # Auto-configuration code\n\u2514\u2500\u2500 acme-spring-boot-starter/        # Starter POM with dependencies\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#example-creating-a-simple-custom-starter","title":"Example: Creating a Simple Custom Starter","text":"<ol> <li>Create autoconfigure module:</li> </ol> <pre><code>@Configuration\n@ConditionalOnClass(AcmeService.class)\n@EnableConfigurationProperties(AcmeProperties.class)\npublic class AcmeAutoConfiguration {\n\n    @Bean\n    @ConditionalOnMissingBean\n    public AcmeService acmeService(AcmeProperties properties) {\n        return new AcmeService(properties.getPrefix(), properties.getSuffix());\n    }\n}\n</code></pre> <ol> <li>Create a properties class:</li> </ol> <pre><code>@ConfigurationProperties(\"acme\")\npublic class AcmeProperties {\n\n    private String prefix = \"Hello\";\n    private String suffix = \"World\";\n\n    // Getters and setters\n}\n</code></pre> <ol> <li>Register the auto-configuration in META-INF/spring.factories:</li> </ol> <pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.example.acme.autoconfigure.AcmeAutoConfiguration\n</code></pre> <ol> <li>Create starter POM:</li> </ol> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.example.acme&lt;/groupId&gt;\n        &lt;artifactId&gt;acme-spring-boot-autoconfigure&lt;/artifactId&gt;\n        &lt;version&gt;${project.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Other dependencies the starter provides --&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#auto-configuration","title":"Auto-Configuration","text":"<p>Auto-configuration is a key feature of Spring Boot that automatically configures your application based on the dependencies you have added to your project.</p>"},{"location":"spring-boot/spring-boot-starter/#how-auto-configuration-works","title":"How Auto-Configuration Works","text":"<ol> <li>Spring Boot looks for auto-configuration classes in your classpath</li> <li>Each auto-configuration class has conditions that determine if it should be applied</li> <li>If conditions are met, the auto-configuration is applied, providing predefined beans and settings</li> </ol> <p>The mechanism uses the following key components:</p> <ul> <li>@EnableAutoConfiguration: Usually part of @SpringBootApplication, enables the auto-configuration mechanism</li> <li>spring.factories: Files in META-INF containing lists of auto-configuration classes</li> <li>@Conditional annotations: Control when auto-configurations are applied</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#conditional-annotations","title":"Conditional Annotations","text":"<p>Spring Boot uses various conditions to determine when to apply auto-configurations:</p> <ul> <li> <p>@ConditionalOnClass: Applies when specific classes are present   <pre><code>@ConditionalOnClass(DataSource.class)\n</code></pre></p> </li> <li> <p>@ConditionalOnMissingClass: Applies when specific classes are not present   <pre><code>@ConditionalOnMissingClass(\"org.springframework.data.mongodb.MongoDbFactory\")\n</code></pre></p> </li> <li> <p>@ConditionalOnBean: Applies when specific beans exist   <pre><code>@ConditionalOnBean(name = \"dataSource\")\n</code></pre></p> </li> <li> <p>@ConditionalOnMissingBean: Applies when specific beans don't exist   <pre><code>@ConditionalOnMissingBean(JpaTransactionManager.class)\n</code></pre></p> </li> <li> <p>@ConditionalOnProperty: Applies based on a configuration property   <pre><code>@ConditionalOnProperty(prefix=\"spring.h2\", name=\"console.enabled\", havingValue=\"true\")\n</code></pre></p> </li> <li> <p>@ConditionalOnResource: Applies when specific resources are available   <pre><code>@ConditionalOnResource(resources = \"classpath:schema.sql\")\n</code></pre></p> </li> </ul>"},{"location":"spring-boot/spring-boot-starter/#auto-configuration-example","title":"Auto-Configuration Example","text":"<p>Let's look at how H2 console auto-configuration works:</p> <pre><code>@Configuration\n@ConditionalOnClass(WebServlet.class)\n@ConditionalOnProperty(prefix = \"spring.h2.console\", name = \"enabled\", havingValue = \"true\")\n@ConditionalOnWebApplication(type = Type.SERVLET)\npublic class H2ConsoleAutoConfiguration {\n\n    @Bean\n    public ServletRegistrationBean&lt;WebServlet&gt; h2Console() {\n        ServletRegistrationBean&lt;WebServlet&gt; registration = new ServletRegistrationBean&lt;&gt;(\n                new WebServlet(), \"/h2-console/*\");\n        registration.addInitParameter(\"webAllowOthers\", \"true\");\n        return registration;\n    }\n}\n</code></pre> <p>This auto-configuration: 1. Only applies if the WebServlet class is on the classpath 2. Only applies if <code>spring.h2.console.enabled=true</code> is set 3. Only applies to servlet web applications 4. Registers the H2 console servlet at the <code>/h2-console</code> path</p>"},{"location":"spring-boot/spring-boot-starter/#viewing-auto-configuration-report","title":"Viewing Auto-Configuration Report","text":"<p>To understand which auto-configurations are being applied or not:</p> <ol> <li>Enable debug logging:</li> </ol> <pre><code># In application.properties\ndebug=true\n</code></pre> <ol> <li>Examine the startup log:</li> </ol> <pre><code>=========================\nAUTO-CONFIGURATION REPORT\n=========================\n\nPositive matches:\n-----------------\n   DataSourceAutoConfiguration matched:\n      - @ConditionalOnClass found required class 'javax.sql.DataSource' (OnClassCondition)\n\nNegative matches:\n-----------------\n   MongoAutoConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required class 'com.mongodb.MongoClient' (OnClassCondition)\n</code></pre> <ol> <li>Use Spring Boot Actuator:</li> </ol> <pre><code>GET /actuator/conditions\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#customizing-auto-configuration","title":"Customizing Auto-Configuration","text":"<p>There are several ways to customize auto-configuration behavior:</p> <ol> <li> <p>Property Customization: <pre><code># Set server port\nserver.port=8081\n\n# Customize database connection\nspring.datasource.url=jdbc:mysql://localhost/mydb\nspring.datasource.username=user\nspring.datasource.password=secret\n</code></pre></p> </li> <li> <p>Bean Overriding: <pre><code>@Bean\npublic DataSource dataSource() {\n    // Custom implementation that will be used instead of auto-configured one\n    return new MyCustomDataSource();\n}\n</code></pre></p> </li> <li> <p>Exclude Auto-Configurations: <pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\npublic class Application {\n    // ...\n}\n</code></pre></p> </li> <li> <p>Profile-Specific Auto-Configuration: <pre><code>@Profile(\"development\")\n@Configuration\npublic class DevDataSourceConfig {\n    // Development-specific beans\n}\n\n@Profile(\"production\")\n@Configuration\npublic class ProdDataSourceConfig {\n    // Production-specific beans\n}\n</code></pre></p> </li> </ol>"},{"location":"spring-boot/spring-boot-starter/#auto-configuration-order","title":"Auto-Configuration Order","text":"<p>Auto-configurations have an implicit ordering based on their dependencies. You can also explicitly control ordering using:</p> <ul> <li> <p>@AutoConfigureBefore: Apply before specific auto-configurations   <pre><code>@AutoConfigureBefore(JpaRepositoriesAutoConfiguration.class)\n</code></pre></p> </li> <li> <p>@AutoConfigureAfter: Apply after specific auto-configurations   <pre><code>@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n</code></pre></p> </li> <li> <p>@AutoConfigureOrder: Set an absolute ordering   <pre><code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n</code></pre></p> </li> </ul>"},{"location":"spring-boot/spring-boot-starter/#configuration-properties","title":"Configuration Properties","text":"<p>Spring Boot provides a powerful mechanism to externalize configuration, allowing you to work with the same application code in different environments.</p>"},{"location":"spring-boot/spring-boot-starter/#property-sources","title":"Property Sources","text":"<p>Spring Boot loads properties from multiple sources in the following order of precedence (highest to lowest):</p> <ol> <li>Command-line arguments</li> <li>JNDI attributes from <code>java:comp/env</code></li> <li>Java System properties (<code>System.getProperties()</code>)</li> <li>OS environment variables</li> <li>Profile-specific properties (<code>application-{profile}.properties</code>)</li> <li>Application properties (<code>application.properties</code> or <code>application.yml</code>)</li> <li><code>@PropertySource</code> annotations on your <code>@Configuration</code> classes</li> <li>Default properties (<code>SpringApplication.setDefaultProperties</code>)</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#property-file-locations","title":"Property File Locations","text":"<p>Spring Boot searches for <code>application.properties</code> or <code>application.yml</code> files in the following locations (decreasing priority):</p> <ol> <li>A <code>/config</code> subdirectory of the current directory</li> <li>The current directory</li> <li>A classpath <code>/config</code> package</li> <li>The classpath root</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#using-properties-files","title":"Using Properties Files","text":"<p>The most common way to configure a Spring Boot application is through properties files.</p>"},{"location":"spring-boot/spring-boot-starter/#applicationproperties","title":"application.properties","text":"<pre><code># Server configuration\nserver.port=8080\nserver.servlet.context-path=/api\n\n# Database configuration\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=password\n\n# Logging configuration\nlogging.level.root=INFO\nlogging.level.org.springframework.web=DEBUG\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#applicationyml","title":"application.yml","text":"<p>YAML offers a more structured, human-readable alternative: <pre><code>server:\n  port: 8080\n  servlet:\n    context-path: /api\n\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    username: sa\n    password: password\n\nlogging:\n  level:\n    root: INFO\n    org.springframework.web: DEBUG\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#accessing-properties","title":"Accessing Properties","text":"<p>There are several ways to access configuration properties in your code:</p>"},{"location":"spring-boot/spring-boot-starter/#1-using-value-annotation","title":"1. Using @Value annotation","text":"<pre><code>@RestController\npublic class GreetingController {\n\n    @Value(\"${greeting.message}\")\n    private String greetingMessage;\n\n    @GetMapping(\"/greeting\")\n    public String getGreeting() {\n        return greetingMessage;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#2-using-environment-object","title":"2. Using Environment object","text":"<pre><code>@RestController\npublic class GreetingController {\n\n    @Autowired\n    private Environment environment;\n\n    @GetMapping(\"/greeting\")\n    public String getGreeting() {\n        return environment.getProperty(\"greeting.message\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#3-using-configurationproperties","title":"3. Using @ConfigurationProperties","text":"<p>This approach is especially useful for binding a group of related properties:</p> <pre><code>@Component\n@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n\n    private String name;\n    private String description;\n    private Map&lt;String, String&gt; settings = new HashMap&lt;&gt;();\n\n    // Getters and setters...\n}\n</code></pre> <pre><code># In application.properties\napp.name=My Application\napp.description=A Spring Boot application\napp.settings.timeout=30s\napp.settings.maxConnections=100\n</code></pre> <p>Usage: <pre><code>@RestController\npublic class AppController {\n\n    @Autowired\n    private AppProperties appProperties;\n\n    @GetMapping(\"/app-info\")\n    public AppProperties getAppInfo() {\n        return appProperties;\n    }\n}\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#profiles","title":"Profiles","text":"<p>Profiles allow you to define environment-specific configurations:</p>"},{"location":"spring-boot/spring-boot-starter/#defining-profile-specific-properties","title":"Defining Profile-Specific Properties","text":"<p>Create property files named <code>application-{profile}.properties</code> or <code>application-{profile}.yml</code>:</p> <pre><code>application-dev.properties\napplication-prod.properties\napplication-test.properties\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#activating-profiles","title":"Activating Profiles","text":"<ol> <li> <p>In application.properties: <pre><code>spring.profiles.active=dev\n</code></pre></p> </li> <li> <p>Command line: <pre><code>java -jar app.jar --spring.profiles.active=prod\n</code></pre></p> </li> <li> <p>Environment variable: <pre><code>export SPRING_PROFILES_ACTIVE=prod\n</code></pre></p> </li> <li> <p>Programmatically: <pre><code>SpringApplication app = new SpringApplication(MyApp.class);\napp.setAdditionalProfiles(\"prod\");\napp.run(args);\n</code></pre></p> </li> </ol>"},{"location":"spring-boot/spring-boot-starter/#profile-specific-beans","title":"Profile-Specific Beans","text":"<pre><code>@Configuration\npublic class AppConfig {\n\n    @Profile(\"dev\")\n    @Bean\n    public DataSource devDataSource() {\n        // Development datasource configuration\n    }\n\n    @Profile(\"prod\")\n    @Bean\n    public DataSource prodDataSource() {\n        // Production datasource configuration\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#type-safe-configuration-properties","title":"Type-Safe Configuration Properties","text":"<p>Spring Boot provides a powerful type-safe configuration mechanism using <code>@ConfigurationProperties</code>:</p>"},{"location":"spring-boot/spring-boot-starter/#define-a-configuration-class","title":"Define a configuration class:","text":"<pre><code>@ConfigurationProperties(prefix = \"mail\")\n@Validated\npublic class MailProperties {\n\n    @NotNull\n    private String host;\n\n    @Min(1025)\n    @Max(65536)\n    private int port = 25;\n\n    @NotEmpty\n    private String from;\n\n    private String username;\n    private String password;\n    private Map&lt;String, String&gt; additionalHeaders = new HashMap&lt;&gt;();\n\n    // Getters and setters...\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#enable-configuration-properties","title":"Enable configuration properties:","text":"<pre><code>@SpringBootApplication\n@EnableConfigurationProperties(MailProperties.class)\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#properties-file","title":"Properties file:","text":"<pre><code>mail.host=smtp.example.com\nmail.port=587\nmail.from=no-reply@example.com\nmail.username=admin\nmail.password=secret\nmail.additional-headers.redelivery=true\nmail.additional-headers.secure=true\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#use-the-properties","title":"Use the properties:","text":"<pre><code>@Service\npublic class EmailService {\n\n    private final MailProperties mailProperties;\n\n    public EmailService(MailProperties mailProperties) {\n        this.mailProperties = mailProperties;\n    }\n\n    public void sendEmail(String to, String subject, String content) {\n        // Use mailProperties to configure email sending\n        System.out.println(\"Sending email via \" + mailProperties.getHost() + \":\" + mailProperties.getPort());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#property-encryption","title":"Property Encryption","text":"<p>For sensitive configuration values, consider using encrypted properties:</p> <ol> <li>Using jasypt-spring-boot:</li> </ol> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;\n    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;3.0.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <ol> <li>Configure in properties:</li> </ol> <pre><code>jasypt.encryptor.password=your-secret-key\n\n# Encrypted property (ENC() format)\nspring.datasource.password=ENC(encrypted-password-here)\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#building-a-simple-rest-api","title":"Building a Simple REST API","text":"<p>Let's build a simple REST API for managing a collection of books.</p>"},{"location":"spring-boot/spring-boot-starter/#project-setup","title":"Project Setup","text":"<p>First, create a Spring Boot project with the necessary dependencies:</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#domain-model","title":"Domain Model","text":"<p>Create a Book class:</p> <pre><code>package com.example.bookapi.model;\n\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.PastOrPresent;\nimport jakarta.validation.constraints.Size;\n\nimport java.time.LocalDate;\nimport java.util.Objects;\n\npublic class Book {\n\n    private Long id;\n\n    @NotBlank\n    @Size(min = 1, max = 100)\n    private String title;\n\n    @NotBlank\n    @Size(min = 1, max = 100)\n    private String author;\n\n    @NotNull\n    @PastOrPresent\n    private LocalDate publishedDate;\n\n    private String isbn;\n\n    // Constructors\n\n    public Book() {\n    }\n\n    public Book(Long id, String title, String author, LocalDate publishedDate, String isbn) {\n        this.id = id;\n        this.title = title;\n        this.author = author;\n        this.publishedDate = publishedDate;\n        this.isbn = isbn;\n    }\n\n    // Getters and setters\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public void setAuthor(String author) {\n        this.author = author;\n    }\n\n    public LocalDate getPublishedDate() {\n        return publishedDate;\n    }\n\n    public void setPublishedDate(LocalDate publishedDate) {\n        this.publishedDate = publishedDate;\n    }\n\n    public String getIsbn() {\n        return isbn;\n    }\n\n    public void setIsbn(String isbn) {\n        this.isbn = isbn;\n    }\n\n    // equals and hashCode\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Book book = (Book) o;\n        return Objects.equals(id, book.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#service-layer","title":"Service Layer","text":"<p>Create a service to manage the books:</p> <pre><code>package com.example.bookapi.service;\n\nimport com.example.bookapi.model.Book;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicLong;\n\n@Service\npublic class BookService {\n\n    private final Map&lt;Long, Book&gt; books = new HashMap&lt;&gt;();\n    private final AtomicLong idGenerator = new AtomicLong(1);\n\n    public List&lt;Book&gt; findAll() {\n        return new ArrayList&lt;&gt;(books.values());\n    }\n\n    public Book findById(Long id) {\n        return books.get(id);\n    }\n\n    public Book create(Book book) {\n        Long id = idGenerator.getAndIncrement();\n        book.setId(id);\n        books.put(id, book);\n        return book;\n    }\n\n    public Book update(Long id, Book book) {\n        if (!books.containsKey(id)) {\n            return null;\n        }\n        book.setId(id);\n        books.put(id, book);\n        return book;\n    }\n\n    public boolean delete(Long id) {\n        return books.remove(id) != null;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#controller-layer","title":"Controller Layer","text":"<p>Create a REST controller:</p> <pre><code>package com.example.bookapi.controller;\n\nimport com.example.bookapi.model.Book;\nimport com.example.bookapi.service.BookService;\nimport jakarta.validation.Valid;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n\n    private final BookService bookService;\n\n    public BookController(BookService bookService) {\n        this.bookService = bookService;\n    }\n\n    @GetMapping\n    public List&lt;Book&gt; getAllBooks() {\n        return bookService.findAll();\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Book&gt; getBookById(@PathVariable Long id) {\n        Book book = bookService.findById(id);\n        if (book == null) {\n            return ResponseEntity.notFound().build();\n        }\n        return ResponseEntity.ok(book);\n    }\n\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public Book createBook(@Valid @RequestBody Book book) {\n        return bookService.create(book);\n    }\n\n    @PutMapping(\"/{id}\")\n    public ResponseEntity&lt;Book&gt; updateBook(@PathVariable Long id, @Valid @RequestBody Book book) {\n        Book updatedBook = bookService.update(id, book);\n        if (updatedBook == null) {\n            return ResponseEntity.notFound().build();\n        }\n        return ResponseEntity.ok(updatedBook);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteBook(@PathVariable Long id) {\n        boolean deleted = bookService.delete(id);\n        if (!deleted) {\n            return ResponseEntity.notFound().build();\n        }\n        return ResponseEntity.noContent().build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#error-handling","title":"Error Handling","text":"<p>Add a global exception handler:</p> <pre><code>package com.example.bookapi.exception;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.FieldError;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(\n            MethodArgumentNotValidException ex) {\n        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();\n        ex.getBindingResult().getAllErrors().forEach((error) -&gt; {\n            String fieldName = ((FieldError) error).getField();\n            String errorMessage = error.getDefaultMessage();\n            errors.put(fieldName, errorMessage);\n        });\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#testing-the-api","title":"Testing the API","text":"<p>Now you can test your API with tools like Postman or curl:</p> <pre><code># Get all books\ncurl http://localhost:8080/api/books\n\n# Create a book\ncurl -X POST http://localhost:8080/api/books \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\":\"Spring Boot in Action\",\"author\":\"Craig Walls\",\"publishedDate\":\"2016-01-30\",\"isbn\":\"1617292540\"}'\n\n# Get a specific book\ncurl http://localhost:8080/api/books/1\n\n# Update a book\ncurl -X PUT http://localhost:8080/api/books/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\":\"Spring Boot in Action (2nd Edition)\",\"author\":\"Craig Walls\",\"publishedDate\":\"2018-10-15\",\"isbn\":\"1617292540\"}'\n\n# Delete a book\ncurl -X DELETE http://localhost:8080/api/books/1\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#openapi-documentation","title":"OpenAPI Documentation","text":"<p>You can add OpenAPI documentation to your API:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n    &lt;version&gt;2.0.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure OpenAPI:</p> <pre><code>@Configuration\npublic class OpenApiConfig {\n\n    @Bean\n    public OpenAPI customOpenAPI() {\n        return new OpenAPI()\n                .info(new Info()\n                        .title(\"Book API\")\n                        .version(\"1.0\")\n                        .description(\"A simple Book API\")\n                        .termsOfService(\"http://swagger.io/terms/\")\n                        .license(new License().name(\"Apache 2.0\").url(\"http://springdoc.org\")));\n    }\n}\n</code></pre> <p>Access the documentation at: http://localhost:8080/swagger-ui.html</p>"},{"location":"spring-boot/spring-boot-starter/#spring-boot-devtools","title":"Spring Boot DevTools","text":"<p>Spring Boot Developer Tools (DevTools) provides development-time features to enhance the developer experience.</p>"},{"location":"spring-boot/spring-boot-starter/#devtools-features","title":"DevTools Features","text":"<ol> <li>Automatic restart</li> <li>Restarts the application when classpath changes</li> <li> <p>Uses two classloaders to improve restart time:</p> <ul> <li>Base classloader for libraries that don't change</li> <li>Restart classloader for your code that changes frequently</li> </ul> </li> <li> <p>LiveReload integration</p> </li> <li>Triggers browser refresh when resources change</li> <li> <p>Works with various resource types (HTML, CSS, JS)</p> </li> <li> <p>Property defaults</p> </li> <li>Disables template caching during development</li> <li> <p>Enables debug logging for web applications</p> </li> <li> <p>Developer tools remote applications</p> </li> <li>Remote debug capabilities</li> <li>Remote update capabilities</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#adding-devtools","title":"Adding DevTools","text":"<p>Include the DevTools dependency in your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#automatic-restart","title":"Automatic Restart","text":"<p>DevTools monitors the classpath for changes and automatically restarts your application when they occur.</p>"},{"location":"spring-boot/spring-boot-starter/#excluding-resources","title":"Excluding Resources","text":"<p>Configure resources that shouldn't trigger restart:</p> <pre><code>spring.devtools.restart.exclude=static/**,public/**\n</code></pre> <p>Or add additional paths to exclude:</p> <pre><code>spring.devtools.restart.additional-exclude=static/**,public/**\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#watching-additional-paths","title":"Watching Additional Paths","text":"<p>Add resources from locations not on the classpath:</p> <pre><code>spring.devtools.restart.additional-paths=scripts/,data/\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#disabling-restart","title":"Disabling Restart","text":"<p>Disable restart completely:</p> <pre><code>spring.devtools.restart.enabled=false\n</code></pre> <p>Or programmatically:</p> <pre><code>public static void main(String[] args) {\n    System.setProperty(\"spring.devtools.restart.enabled\", \"false\");\n    SpringApplication.run(MyApp.class, args);\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#livereload","title":"LiveReload","text":"<p>DevTools includes a LiveReload server that triggers a browser refresh when resources change.</p>"},{"location":"spring-boot/spring-boot-starter/#enablingdisabling-livereload","title":"Enabling/Disabling LiveReload","text":"<pre><code>spring.devtools.livereload.enabled=true\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#livereload-browser-extension","title":"LiveReload Browser Extension","text":"<p>Install the LiveReload browser extension for your browser: - Chrome: LiveReload - Firefox: LiveReload</p>"},{"location":"spring-boot/spring-boot-starter/#global-settings","title":"Global Settings","text":"<p>Configure global DevTools settings by creating a file at: <code>~/.spring-boot-devtools.properties</code></p> <p>For example: <pre><code>spring.devtools.restart.quiet-period=1000\nspring.devtools.restart.poll-interval=2000\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#remote-development","title":"Remote Development","text":"<p>DevTools supports remote application development:</p> <ol> <li>Configure the remote application:</li> </ol> <pre><code>spring.devtools.remote.secret=mysecret\n</code></pre> <ol> <li>Build with DevTools:</li> </ol> <pre><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;configuration&gt;\n                &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <ol> <li>Connect from your local machine:</li> </ol> <pre><code>$ java -jar spring-boot-devtools.jar -Dspring.devtools.remote.secret=mysecret https://myapp.example.com\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#best-practices-for-using-devtools","title":"Best Practices for Using DevTools","text":"<ol> <li>Keep it for development only:</li> <li>Set <code>&lt;optional&gt;true&gt;</code> in Maven dependency</li> <li> <p>DevTools automatically disables itself in production</p> </li> <li> <p>Use with IDE integration:</p> </li> <li>IntelliJ IDEA: Enable \"Build project automatically\" and \"compiler.automake.allow.when.app.running\"</li> <li> <p>Eclipse: Automatic building is enabled by default</p> </li> <li> <p>Customize restart behavior:</p> </li> <li>Exclude static assets to avoid unnecessary restarts</li> <li> <p>Configure proper poll intervals for your development environment</p> </li> <li> <p>Integrate with browser tools:</p> </li> <li>Use LiveReload with browser extensions</li> <li>Integrate with browser developer tools for better debugging </li> </ol>"},{"location":"spring-boot/spring-boot-starter/#packaging-and-running-spring-boot-applications","title":"Packaging and Running Spring Boot Applications","text":"<p>Spring Boot provides multiple ways to package and run your applications, making it easy to deploy in various environments.</p>"},{"location":"spring-boot/spring-boot-starter/#jar-vs-war-packaging","title":"JAR vs WAR Packaging","text":"<p>Spring Boot applications can be packaged as executable JAR files or traditional WAR files:</p>"},{"location":"spring-boot/spring-boot-starter/#executable-jar-recommended","title":"Executable JAR (recommended)","text":"<p>Pros: - Self-contained (embedded server) - Easy to deploy and run - Simplified dependency management - Better for microservices and cloud deployments</p> <pre><code>&lt;packaging&gt;jar&lt;/packaging&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#war-packaging","title":"WAR packaging","text":"<p>Pros: - Compatible with external application servers - Easier migration path for existing web applications - Multiple applications can share server resources</p> <pre><code>&lt;packaging&gt;war&lt;/packaging&gt;\n</code></pre> <p>For WAR deployment, extend <code>SpringBootServletInitializer</code>:</p> <pre><code>@SpringBootApplication\npublic class Application extends SpringBootServletInitializer {\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#building-with-maven","title":"Building with Maven","text":"<p>Build a Spring Boot application with Maven:</p> <pre><code># Build JAR\nmvn clean package\n\n# Skip tests\nmvn clean package -DskipTests\n\n# Build and run\nmvn spring-boot:run\n</code></pre> <p>Spring Boot Maven Plugin configuration:</p> <pre><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;configuration&gt;\n                &lt;excludes&gt;\n                    &lt;exclude&gt;\n                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n                    &lt;/exclude&gt;\n                &lt;/excludes&gt;\n                &lt;layers&gt;\n                    &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;/layers&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#building-with-gradle","title":"Building with Gradle","text":"<p>Build a Spring Boot application with Gradle:</p> <pre><code># Build JAR\n./gradlew build\n\n# Skip tests\n./gradlew build -x test\n\n# Build and run\n./gradlew bootRun\n</code></pre> <p>Spring Boot Gradle Plugin configuration:</p> <pre><code>plugins {\n    id 'org.springframework.boot' version '3.0.0'\n    id 'io.spring.dependency-management' version '1.1.0'\n    id 'java'\n}\n\nbootJar {\n    layered {\n        enabled = true\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#running-spring-boot-applications","title":"Running Spring Boot Applications","text":"<p>Multiple ways to run a Spring Boot application:</p>"},{"location":"spring-boot/spring-boot-starter/#from-ide_1","title":"From IDE","text":"<p>Click \"Run\" on the main application class with <code>@SpringBootApplication</code> annotation.</p>"},{"location":"spring-boot/spring-boot-starter/#from-maven","title":"From Maven","text":"<pre><code>mvn spring-boot:run\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#from-gradle","title":"From Gradle","text":"<pre><code>./gradlew bootRun\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#from-jar","title":"From JAR","text":"<pre><code>java -jar target/myapplication-0.0.1-SNAPSHOT.jar\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#with-specific-profile","title":"With specific profile","text":"<pre><code>java -jar myapplication.jar --spring.profiles.active=prod\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#with-custom-properties","title":"With custom properties","text":"<pre><code>java -jar myapplication.jar --server.port=8081\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#docker-containerization","title":"Docker Containerization","text":"<p>Spring Boot applications work well in containers:</p>"},{"location":"spring-boot/spring-boot-starter/#basic-dockerfile","title":"Basic Dockerfile","text":"<pre><code>FROM eclipse-temurin:17-jdk\nVOLUME /tmp\nCOPY target/*.jar app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#optimized-dockerfile-using-layers","title":"Optimized Dockerfile using layers","text":"<pre><code>FROM eclipse-temurin:17-jdk as builder\nWORKDIR /app\nCOPY mvnw .\nCOPY .mvn .mvn\nCOPY pom.xml .\nCOPY src src\nRUN ./mvnw package -DskipTests\n\nFROM eclipse-temurin:17-jre\nVOLUME /tmp\nCOPY --from=builder /app/target/*.jar app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#building-and-running-docker-container","title":"Building and running Docker container","text":"<pre><code># Build the image\ndocker build -t myapp .\n\n# Run the container\ndocker run -p 8080:8080 myapp\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#using-spring-boots-built-in-layering","title":"Using Spring Boot's built-in layering","text":"<p>Spring Boot 2.3+ supports efficient Docker layers:</p> <pre><code># Extract the layers\njava -Djarmode=layertools -jar target/myapplication.jar extract\n\n# Create a layered Dockerfile\nFROM eclipse-temurin:17-jre as builder\nWORKDIR application\nARG JAR_FILE=target/*.jar\nCOPY ${JAR_FILE} application.jar\nRUN java -Djarmode=layertools -jar application.jar extract\n\nFROM eclipse-temurin:17-jre\nWORKDIR application\nCOPY --from=builder application/dependencies/ ./\nCOPY --from=builder application/spring-boot-loader/ ./\nCOPY --from=builder application/snapshot-dependencies/ ./\nCOPY --from=builder application/application/ ./\nENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"]\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#cloud-deployment","title":"Cloud Deployment","text":"<p>Spring Boot applications can be easily deployed to cloud platforms:</p>"},{"location":"spring-boot/spring-boot-starter/#heroku","title":"Heroku","text":"<p>Create a <code>Procfile</code>: <pre><code>web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar\n</code></pre></p> <p>Deploy to Heroku: <pre><code>heroku create\ngit push heroku main\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#aws-elastic-beanstalk","title":"AWS Elastic Beanstalk","text":"<p>Package as a JAR and upload through the Elastic Beanstalk console or CLI: <pre><code>eb init\neb create\neb deploy\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#kubernetes","title":"Kubernetes","text":"<p>Create a Kubernetes deployment file: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: spring-boot-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: spring-boot-app\n  template:\n    metadata:\n      labels:\n        app: spring-boot-app\n    spec:\n      containers:\n      - name: spring-boot-app\n        image: myapp:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: SPRING_PROFILES_ACTIVE\n          value: \"prod\"\n</code></pre></p> <p>Deploy to Kubernetes: <pre><code>kubectl apply -f deployment.yaml\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#executable-jar-structure","title":"Executable JAR Structure","text":"<p>Spring Boot's executable JAR is structured as:</p> <pre><code>my-application.jar\n\u251c\u2500\u2500 META-INF\n\u2502   \u251c\u2500\u2500 MANIFEST.MF\n\u2502   \u2514\u2500\u2500 maven/...\n\u251c\u2500\u2500 BOOT-INF\n\u2502   \u251c\u2500\u2500 classes/          # Application classes\n\u2502   \u2502   \u2514\u2500\u2500 com/example/...\n\u2502   \u2514\u2500\u2500 lib/              # Dependencies\n\u2502       \u2514\u2500\u2500 *.jar\n\u2514\u2500\u2500 org/springframework/boot/loader/  # JAR loader classes\n</code></pre> <p>The <code>MANIFEST.MF</code> includes a <code>Main-Class</code> attribute pointing to Spring Boot's launcher: <pre><code>Main-Class: org.springframework.boot.loader.JarLauncher\nStart-Class: com.example.MyApplication\n</code></pre></p>"},{"location":"spring-boot/spring-boot-starter/#common-issues-and-troubleshooting","title":"Common Issues and Troubleshooting","text":"<p>When working with Spring Boot, you may encounter common issues. Here's how to troubleshoot them.</p>"},{"location":"spring-boot/spring-boot-starter/#application-startup-issues","title":"Application Startup Issues","text":""},{"location":"spring-boot/spring-boot-starter/#port-already-in-use","title":"Port Already in Use","text":"<pre><code>Web server failed to start. Port 8080 was already in use.\n</code></pre> <p>Solutions: - Kill the process using the port: <code>lsof -i :8080</code>, then <code>kill -9 &lt;PID&gt;</code> - Change the port in <code>application.properties</code>: <code>server.port=8081</code> - Use a random port: <code>server.port=0</code></p>"},{"location":"spring-boot/spring-boot-starter/#bean-creation-exception","title":"Bean Creation Exception","text":"<pre><code>Error creating bean with name 'entityManagerFactory'\n</code></pre> <p>Solutions: - Check database configuration properties - Ensure the database is running and accessible - Verify entity mappings are correct</p>"},{"location":"spring-boot/spring-boot-starter/#bean-definition-overriding","title":"Bean Definition Overriding","text":"<pre><code>The bean 'dataSource', defined in class path resource [...] could not be registered.\n</code></pre> <p>Solutions: - Enable bean overriding: <code>spring.main.allow-bean-definition-overriding=true</code> - Remove duplicate bean definitions - Use different bean names</p>"},{"location":"spring-boot/spring-boot-starter/#database-connectivity-issues","title":"Database Connectivity Issues","text":""},{"location":"spring-boot/spring-boot-starter/#connection-issues","title":"Connection Issues","text":"<pre><code>Failed to obtain JDBC Connection; nested exception is...\n</code></pre> <p>Solutions: - Verify database server is running - Check connection URL, username, and password - Test connection using a database client - Ensure database driver is on classpath</p>"},{"location":"spring-boot/spring-boot-starter/#hibernate-schema-issues","title":"Hibernate Schema Issues","text":"<pre><code>Schema-validation: wrong column type encountered...\n</code></pre> <p>Solutions: - Use <code>spring.jpa.hibernate.ddl-auto=update</code> during development - Create database migration scripts with Flyway or Liquibase - Validate entity mappings against database schema</p>"},{"location":"spring-boot/spring-boot-starter/#configuration-problems","title":"Configuration Problems","text":""},{"location":"spring-boot/spring-boot-starter/#property-binding-issues","title":"Property Binding Issues","text":"<pre><code>Binding to target org.springframework.boot.autoconfigure.web.ServerProperties failed\n</code></pre> <p>Solutions: - Check property types and formats - Use appropriate conversion if needed - Verify property names match the expected format</p>"},{"location":"spring-boot/spring-boot-starter/#yaml-format-issues","title":"YAML Format Issues","text":"<pre><code>while parsing a block mapping ... expected &lt;block end&gt;, but found ...\n</code></pre> <p>Solutions: - Validate YAML syntax (proper indentation) - Use a YAML linter - Try switching to properties format</p>"},{"location":"spring-boot/spring-boot-starter/#memory-and-performance-issues","title":"Memory and Performance Issues","text":""},{"location":"spring-boot/spring-boot-starter/#outofmemoryerror","title":"OutOfMemoryError","text":"<pre><code>java.lang.OutOfMemoryError: Java heap space\n</code></pre> <p>Solutions: - Increase heap size: <code>java -Xmx512m -jar app.jar</code> - Optimize memory usage in application - Add profiling to identify memory leaks</p>"},{"location":"spring-boot/spring-boot-starter/#slow-startup","title":"Slow Startup","text":"<p>Solutions: - Use Spring Boot 2.3+ for improved startup time - Consider lazy initialization: <code>spring.main.lazy-initialization=true</code> - Use Spring Native for compilation to native code - Profile the startup to identify bottlenecks</p>"},{"location":"spring-boot/spring-boot-starter/#testing-issues","title":"Testing Issues","text":""},{"location":"spring-boot/spring-boot-starter/#context-loading-issues","title":"Context Loading Issues","text":"<pre><code>Failed to load ApplicationContext for test class\n</code></pre> <p>Solutions: - Check test configuration - Ensure all required beans can be created in test context - Use <code>@MockBean</code> or <code>@SpyBean</code> for external dependencies - Simplify test context with <code>@WebMvcTest</code> or <code>@DataJpaTest</code></p>"},{"location":"spring-boot/spring-boot-starter/#transaction-rollback-issues","title":"Transaction Rollback Issues","text":"<pre><code>Transaction silently rolled back because it has been marked as rollback-only\n</code></pre> <p>Solutions: - Check transaction boundaries - Ensure transaction managers are properly configured - Use <code>@Transactional</code> appropriately in tests</p>"},{"location":"spring-boot/spring-boot-starter/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"spring-boot/spring-boot-starter/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code># In application.properties\ndebug=true\nlogging.level.org.springframework=DEBUG\nlogging.level.com.mycompany=TRACE\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#use-actuator-endpoints","title":"Use Actuator Endpoints","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Access endpoints: - <code>/actuator/health</code> - Application health - <code>/actuator/beans</code> - All beans in the application - <code>/actuator/conditions</code> - Auto-configuration report - <code>/actuator/env</code> - Configuration properties</p>"},{"location":"spring-boot/spring-boot-starter/#remote-debugging","title":"Remote Debugging","text":"<pre><code>java -jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 app.jar\n</code></pre> <p>Connect your IDE to port 8000.</p>"},{"location":"spring-boot/spring-boot-starter/#analyzing-application-events","title":"Analyzing Application Events","text":"<pre><code>@Component\npublic class ApplicationEventLogger {\n\n    private static final Logger logger = LoggerFactory.getLogger(ApplicationEventLogger.class);\n\n    @EventListener\n    public void handleContextRefresh(ContextRefreshedEvent event) {\n        logger.info(\"Context refreshed event received\");\n    }\n\n    @EventListener\n    public void handleContextStart(ContextStartedEvent event) {\n        logger.info(\"Context started event received\");\n    }\n\n    @EventListener\n    public void handleContextStop(ContextStoppedEvent event) {\n        logger.info(\"Context stopped event received\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-starter/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"spring-boot/spring-boot-starter/#circular-dependencies","title":"Circular Dependencies","text":"<pre><code>The dependencies of some of the beans in the application context form a cycle\n</code></pre> <p>Solutions: - Refactor to eliminate the circular dependency - Use <code>@Lazy</code> annotation on one of the beans - Inject <code>ApplicationContext</code> and get beans manually (last resort)</p>"},{"location":"spring-boot/spring-boot-starter/#missing-bean-errors","title":"Missing Bean Errors","text":"<pre><code>No qualifying bean of type [com.example.MyService] found for dependency\n</code></pre> <p>Solutions: - Ensure component scanning includes the package - Add missing <code>@Component</code>, <code>@Service</code>, etc. annotations - Check if the bean is imported correctly - Verify configuration classes have necessary annotations</p>"},{"location":"spring-boot/spring-boot-starter/#application-context-not-starting","title":"Application Context Not Starting","text":"<pre><code>Application run failed ... Failed to start bean 'documentationPluginsBootstrapper'\n</code></pre> <p>Solutions: - Check if all required dependencies are available - Look for exceptions during bean initialization - Remove or fix conflicting dependencies - Check for incompatible library versions</p>"},{"location":"spring-boot/spring-boot-starter/#next-steps","title":"Next Steps","text":"<p>After mastering the basics of Spring Boot, here are some next steps to enhance your skills:</p>"},{"location":"spring-boot/spring-boot-starter/#advanced-spring-boot-topics","title":"Advanced Spring Boot Topics","text":"<ol> <li>Spring Boot Actuator</li> <li>Learn how to monitor and manage your application</li> <li>Customize health checks and metrics</li> <li>Create custom actuator endpoints</li> <li> <p>Integrate with monitoring systems</p> </li> <li> <p>Spring Boot Security</p> </li> <li>Implement authentication and authorization</li> <li>Configure HTTPS and CSRF protection</li> <li>Integrate with OAuth2 and JWT</li> <li> <p>Implement method-level security</p> </li> <li> <p>Data Access with Spring Boot</p> </li> <li>Work with different databases (SQL and NoSQL)</li> <li>Implement caching strategies</li> <li>Use Spring Data repositories</li> <li> <p>Create database migrations with Flyway or Liquibase</p> </li> <li> <p>Testing Spring Boot Applications</p> </li> <li>Write unit and integration tests</li> <li>Use testing slices (@WebMvcTest, @DataJpaTest)</li> <li>Implement test configurations</li> <li> <p>Test security and REST APIs</p> </li> <li> <p>Microservices with Spring Boot</p> </li> <li>Build microservice architectures</li> <li>Implement service discovery</li> <li>Use Spring Cloud for distributed systems</li> <li>Implement circuit breakers and resilience patterns</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#recommended-project-ideas","title":"Recommended Project Ideas","text":"<ol> <li>RESTful API Service</li> <li>Build a complete REST API</li> <li>Implement HATEOAS</li> <li>Add API documentation with OpenAPI</li> <li> <p>Implement pagination and filtering</p> </li> <li> <p>Web Application</p> </li> <li>Create a Spring MVC application</li> <li>Use Thymeleaf or another template engine</li> <li>Implement form validation</li> <li> <p>Add user authentication</p> </li> <li> <p>Real-time Application</p> </li> <li>Use WebSockets or Server-Sent Events</li> <li>Build a chat application</li> <li>Create a real-time dashboard</li> <li> <p>Implement notification systems</p> </li> <li> <p>Batch Processing Application</p> </li> <li>Use Spring Batch for large data processing</li> <li>Implement job monitoring</li> <li>Schedule batch jobs</li> <li> <p>Handle error scenarios</p> </li> <li> <p>Event-Driven Application</p> </li> <li>Use Spring Integration or Spring Cloud Stream</li> <li>Integrate with message brokers (RabbitMQ, Kafka)</li> <li>Implement event sourcing</li> <li>Create asynchronous processing flows</li> </ol>"},{"location":"spring-boot/spring-boot-starter/#learning-resources","title":"Learning Resources","text":""},{"location":"spring-boot/spring-boot-starter/#books","title":"Books","text":"<ul> <li>\"Spring Boot in Action\" by Craig Walls</li> <li>\"Learning Spring Boot 2.0\" by Greg L. Turnquist</li> <li>\"Cloud Native Java\" by Josh Long and Kenny Bastani</li> <li>\"Spring Microservices in Action\" by John Carnell</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#online-courses","title":"Online Courses","text":"<ul> <li>Spring Framework 5: Beginner to Guru</li> <li>Spring &amp; Hibernate for Beginners</li> <li>Building Microservices with Spring Boot</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#websites-and-documentation","title":"Websites and Documentation","text":"<ul> <li>Spring Boot Official Documentation</li> <li>Spring Guides</li> <li>Baeldung Spring Boot Tutorials</li> <li>Spring Boot GitHub Repository</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#community-and-support","title":"Community and Support","text":"<ul> <li>Spring Community Forums</li> <li>Stack Overflow Spring Boot questions</li> <li>Spring Boot Gitter</li> </ul>"},{"location":"spring-boot/spring-boot-starter/#practice-exercises","title":"Practice Exercises","text":"<ol> <li>Create a Book Management API</li> <li>Implement CRUD operations</li> <li>Add validation</li> <li>Implement pagination and sorting</li> <li> <p>Add search functionality</p> </li> <li> <p>Build a Weather Application</p> </li> <li>Integrate with external weather API</li> <li>Cache results</li> <li>Schedule updates</li> <li> <p>Implement error handling</p> </li> <li> <p>Develop a Task Management System</p> </li> <li>Create user registration and login</li> <li>Implement task creation and assignment</li> <li>Add deadline notifications</li> <li> <p>Create task dashboards</p> </li> <li> <p>Create a File Upload Service</p> </li> <li>Handle file uploads and downloads</li> <li>Implement file validation</li> <li>Store file metadata</li> <li> <p>Integrate with cloud storage</p> </li> <li> <p>Build a RESTful Blog Service</p> </li> <li>Implement post CRUD operations</li> <li>Add comment functionality</li> <li>Implement user authentication</li> <li>Create API documentation </li> </ol>"},{"location":"spring-boot/spring-boot-testing/","title":"Spring Boot Testing","text":""},{"location":"spring-boot/spring-boot-testing/#overview","title":"Overview","text":"<p>This guide provides a comprehensive approach to testing Spring Boot applications. It covers unit testing, integration testing, test slices, mocking strategies, and more. By the end of this guide, you'll understand how to implement effective testing strategies for Spring Boot applications, ensuring their reliability and robustness.</p>"},{"location":"spring-boot/spring-boot-testing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Java and Spring Boot</li> <li>Understanding of software testing concepts</li> <li>Familiarity with dependency injection and inversion of control</li> <li>Development environment with Spring Boot set up</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the Spring Boot testing framework</li> <li>Implement unit tests for Spring components</li> <li>Write integration tests for Spring Boot applications</li> <li>Use Spring Boot test slices for focused testing</li> <li>Apply mocking strategies with Mockito</li> <li>Test web controllers with MockMvc</li> <li>Implement data access layer tests</li> <li>Test security configurations</li> <li>Execute performance and load tests</li> <li>Apply test-driven development practices</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Testing Fundamentals in Spring Boot</li> <li>Unit Testing Spring Components</li> <li>Integration Testing</li> <li>Test Slices</li> <li>MockMvc for Web Layer Testing</li> <li>Data Access Layer Testing</li> <li>Mocking with Mockito</li> <li>Testing Security</li> <li>Testing Configurations</li> <li>Test Containers</li> <li>Performance and Load Testing</li> <li>Test-Driven Development</li> <li>Testing Best Practices</li> </ol>"},{"location":"spring-boot/spring-boot-testing/#testing-fundamentals-in-spring-boot","title":"Testing Fundamentals in Spring Boot","text":"<p>Spring Boot provides extensive support for testing through the spring-boot-starter-test dependency, which includes:</p> <ul> <li>JUnit 5: The core testing framework</li> <li>Spring Test &amp; Spring Boot Test: Utilities and annotations for testing Spring Boot applications</li> <li>AssertJ: Fluent assertion library</li> <li>Hamcrest: Matchers for test expressions</li> <li>Mockito: Mocking framework</li> <li>JSONassert: JSON assertion library</li> <li>JsonPath: XPath for JSON</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#setting-up-test-dependencies","title":"Setting Up Test Dependencies","text":"<p>To start testing a Spring Boot application, add the following dependency to your build file:</p> <pre><code>&lt;!-- Maven --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Or for Gradle:</p> <pre><code>// Gradle\ntestImplementation 'org.springframework.boot:spring-boot-starter-test'\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#test-structure-and-configuration","title":"Test Structure and Configuration","text":"<p>A typical Spring Boot test class structure includes:</p> <ul> <li>Annotations for test configuration</li> <li>Setup methods for test initialization</li> <li>Test methods that validate specific functionality</li> <li>Teardown methods for cleaning up resources</li> </ul> <p>Example of a basic test class:</p> <pre><code>@SpringBootTest\nclass ApplicationTests {\n\n    @Autowired\n    private SomeService someService;\n\n    @BeforeEach\n    void setUp() {\n        // Setup code executed before each test\n    }\n\n    @Test\n    void contextLoads() {\n        // Verify application context loads successfully\n        assertThat(someService).isNotNull();\n    }\n\n    @Test\n    void testServiceOperation() {\n        // Test specific functionality\n        String result = someService.performOperation(\"input\");\n        assertThat(result).isEqualTo(\"expected output\");\n    }\n\n    @AfterEach\n    void tearDown() {\n        // Cleanup code executed after each test\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#spring-boot-test-annotations","title":"Spring Boot Test Annotations","text":"<p>Spring Boot provides several annotations to simplify testing:</p> <ul> <li><code>@SpringBootTest</code>: Loads the full application context. Use when you need the complete Spring context.</li> <li><code>@WebMvcTest</code>: Focuses on testing the web layer, including controllers.</li> <li><code>@DataJpaTest</code>: Focuses on the JPA components.</li> <li><code>@RestClientTest</code>: Tests REST clients.</li> <li><code>@JsonTest</code>: Tests JSON serialization/deserialization.</li> <li><code>@AutoConfigureMockMvc</code>: Configures MockMvc for testing web controllers.</li> <li><code>@MockBean</code>: Creates and injects a Mockito mock.</li> <li><code>@SpyBean</code>: Creates and injects a Mockito spy.</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#testing-profiles","title":"Testing Profiles","text":"<p>It's common to use different configuration profiles for testing:</p> <pre><code># application-test.properties\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.jpa.hibernate.ddl-auto=create-drop\n</code></pre> <p>Activate the profile in your test:</p> <pre><code>@SpringBootTest\n@ActiveProfiles(\"test\")\nclass ApplicationTests {\n    // Test methods\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-lifecycle","title":"Testing Lifecycle","text":"<p>JUnit 5 provides annotations for controlling the test lifecycle:</p> <ul> <li><code>@BeforeAll</code>: Executed once, before all test methods.</li> <li><code>@AfterAll</code>: Executed once, after all test methods.</li> <li><code>@BeforeEach</code>: Executed before each test method.</li> <li><code>@AfterEach</code>: Executed after each test method.</li> <li><code>@Test</code>: Marks a method as a test case.</li> <li><code>@Disabled</code>: Temporarily disables a test.</li> <li><code>@DisplayName</code>: Provides a custom name for the test.</li> <li><code>@Tag</code>: Tags tests for selective execution.</li> <li><code>@Timeout</code>: Fails the test if it exceeds the given timeout.</li> <li><code>@RepeatedTest</code>: Repeats a test a specified number of times.</li> <li><code>@ParameterizedTest</code>: Runs a test multiple times with different arguments.</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#unit-testing-spring-components","title":"Unit Testing Spring Components","text":"<p>Unit tests focus on testing individual components in isolation. In Spring Boot, this often means testing a service or component without loading the entire Spring context.</p>"},{"location":"spring-boot/spring-boot-testing/#testing-services","title":"Testing Services","text":"<p>A service is typically tested by mocking its dependencies:</p> <pre><code>import static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.when;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTests {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserServiceImpl userService;\n\n    private User testUser;\n\n    @BeforeEach\n    void setUp() {\n        testUser = new User();\n        testUser.setId(1L);\n        testUser.setUsername(\"testuser\");\n        testUser.setEmail(\"test@example.com\");\n    }\n\n    @Test\n    void findByIdShouldReturnUser() {\n        // Arrange\n        when(userRepository.findById(1L)).thenReturn(Optional.of(testUser));\n\n        // Act\n        Optional&lt;User&gt; foundUser = userService.findById(1L);\n\n        // Assert\n        assertThat(foundUser).isPresent();\n        assertThat(foundUser.get().getUsername()).isEqualTo(\"testuser\");\n    }\n\n    @Test\n    void findByIdShouldReturnEmptyWhenUserNotFound() {\n        // Arrange\n        when(userRepository.findById(999L)).thenReturn(Optional.empty());\n\n        // Act\n        Optional&lt;User&gt; foundUser = userService.findById(999L);\n\n        // Assert\n        assertThat(foundUser).isEmpty();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-utilities-and-helper-classes","title":"Testing Utilities and Helper Classes","text":"<p>For utility classes and helpers, pure unit tests are appropriate:</p> <pre><code>import static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nclass StringUtilsTests {\n\n    @Test\n    void nullOrEmptyShouldReturnTrueForNullString() {\n        assertThat(StringUtils.isNullOrEmpty(null)).isTrue();\n    }\n\n    @Test\n    void nullOrEmptyShouldReturnTrueForEmptyString() {\n        assertThat(StringUtils.isNullOrEmpty(\"\")).isTrue();\n    }\n\n    @Test\n    void nullOrEmptyShouldReturnFalseForNonEmptyString() {\n        assertThat(StringUtils.isNullOrEmpty(\"text\")).isFalse();\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"test, TEST\",\n        \"Spring, SPRING\",\n        \"java, JAVA\"\n    })\n    void toUpperCaseShouldConvertStringToUpperCase(String input, String expected) {\n        assertThat(StringUtils.toUpperCase(input)).isEqualTo(expected);\n    }\n\n    @Test\n    void toUpperCaseShouldThrowExceptionForNullInput() {\n        assertThrows(NullPointerException.class, () -&gt; StringUtils.toUpperCase(null));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#using-testng-instead-of-junit","title":"Using TestNG Instead of JUnit","text":"<p>If you prefer TestNG over JUnit, configure it in your build:</p> <pre><code>&lt;!-- Maven --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.testng&lt;/groupId&gt;\n    &lt;artifactId&gt;testng&lt;/artifactId&gt;\n    &lt;version&gt;7.7.1&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>TestNG test example:</p> <pre><code>import static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.when;\n\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\npublic class UserServiceTestNG {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserServiceImpl userService;\n\n    private User testUser;\n\n    @BeforeMethod\n    public void setUp() {\n        MockitoAnnotations.openMocks(this);\n        testUser = new User();\n        testUser.setId(1L);\n        testUser.setUsername(\"testuser\");\n    }\n\n    @Test\n    public void findByIdShouldReturnUser() {\n        when(userRepository.findById(1L)).thenReturn(Optional.of(testUser));\n\n        Optional&lt;User&gt; foundUser = userService.findById(1L);\n\n        assertThat(foundUser).isPresent();\n        assertThat(foundUser.get().getUsername()).isEqualTo(\"testuser\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#integration-testing","title":"Integration Testing","text":"<p>Integration tests verify that different components work together correctly. In Spring Boot, this typically involves loading a subset of the application context.</p>"},{"location":"spring-boot/spring-boot-testing/#springboottest","title":"@SpringBootTest","text":"<p>The <code>@SpringBootTest</code> annotation creates the application context used in tests:</p> <pre><code>@SpringBootTest\nclass IntegrationTests {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @BeforeEach\n    void setUp() {\n        userRepository.deleteAll();\n    }\n\n    @Test\n    void createUserShouldStoreInDatabase() {\n        // Create a new user\n        User user = new User();\n        user.setUsername(\"integrationtest\");\n        user.setEmail(\"integration@example.com\");\n\n        // Save using the service\n        User savedUser = userService.save(user);\n\n        // Verify it's in the database\n        Optional&lt;User&gt; foundUser = userRepository.findById(savedUser.getId());\n        assertThat(foundUser).isPresent();\n        assertThat(foundUser.get().getUsername()).isEqualTo(\"integrationtest\");\n    }\n}\n</code></pre> <p>For web applications, you can specify if a real or mock web environment should be used:</p> <pre><code>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\nclass WebIntegrationTests {\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    void getUserShouldReturnUserDetails() {\n        ResponseEntity&lt;User&gt; response = restTemplate.getForEntity(\"/api/users/1\", User.class);\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody()).isNotNull();\n        assertThat(response.getBody().getId()).isEqualTo(1L);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-with-testresttemplate","title":"Testing with TestRestTemplate","text":"<p><code>TestRestTemplate</code> is ideal for integration tests that need to make HTTP requests:</p> <pre><code>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\nclass UserControllerIntegrationTests {\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @BeforeEach\n    void setUp() {\n        userRepository.deleteAll();\n\n        User user = new User();\n        user.setUsername(\"testuser\");\n        user.setEmail(\"test@example.com\");\n        userRepository.save(user);\n    }\n\n    @Test\n    void getAllUsersShouldReturnUsers() {\n        ResponseEntity&lt;User[]&gt; response = restTemplate.getForEntity(\"/api/users\", User[].class);\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody()).isNotNull();\n        assertThat(response.getBody()).hasSize(1);\n        assertThat(response.getBody()[0].getUsername()).isEqualTo(\"testuser\");\n    }\n\n    @Test\n    void createUserShouldReturnNewUser() {\n        User newUser = new User();\n        newUser.setUsername(\"newuser\");\n        newUser.setEmail(\"new@example.com\");\n\n        ResponseEntity&lt;User&gt; response = restTemplate.postForEntity(\"/api/users\", newUser, User.class);\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);\n        assertThat(response.getBody()).isNotNull();\n        assertThat(response.getBody().getUsername()).isEqualTo(\"newuser\");\n        assertThat(response.getBody().getId()).isNotNull();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#custom-configuration-for-tests","title":"Custom Configuration for Tests","text":"<p>You can customize the configuration for tests using <code>@TestConfiguration</code>:</p> <pre><code>@SpringBootTest\nclass CustomConfigIntegrationTests {\n\n    @TestConfiguration\n    static class TestConfig {\n        @Bean\n        public SomeService someServiceMock() {\n            return Mockito.mock(SomeService.class);\n        }\n    }\n\n    @Autowired\n    private SomeService someService;\n\n    @Test\n    void testWithCustomConfiguration() {\n        // The someService is the mock from TestConfig\n        Mockito.when(someService.performOperation(any())).thenReturn(\"mocked result\");\n\n        String result = someService.performOperation(\"test\");\n        assertThat(result).isEqualTo(\"mocked result\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#using-dirtiescontext","title":"Using @DirtiesContext","text":"<p>When a test modifies the application context, mark it with <code>@DirtiesContext</code> to reset the context for subsequent tests:</p> <pre><code>@SpringBootTest\nclass ContextModifyingTests {\n\n    @Autowired\n    private ApplicationContext context;\n\n    @Test\n    @DirtiesContext\n    void testThatModifiesContext() {\n        // Test that changes the application context\n    }\n\n    @Test\n    void subsequentTest() {\n        // This test will get a fresh application context\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#test-slices","title":"Test Slices","text":"<p>Spring Boot provides test slice annotations that load only a portion of the application context, making tests faster and more focused.</p>"},{"location":"spring-boot/spring-boot-testing/#webmvctest","title":"@WebMvcTest","text":"<p>For testing Spring MVC controllers without starting the full application:</p> <pre><code>@WebMvcTest(UserController.class)\nclass UserControllerTests {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private UserService userService;\n\n    @Test\n    void getUserByIdShouldReturnUser() throws Exception {\n        User user = new User();\n        user.setId(1L);\n        user.setUsername(\"testuser\");\n\n        when(userService.findById(1L)).thenReturn(Optional.of(user));\n\n        mockMvc.perform(get(\"/api/users/1\"))\n               .andExpect(status().isOk())\n               .andExpect(jsonPath(\"$.id\").value(1))\n               .andExpect(jsonPath(\"$.username\").value(\"testuser\"));\n    }\n\n    @Test\n    void getUserByIdShouldReturn404WhenNotFound() throws Exception {\n        when(userService.findById(999L)).thenReturn(Optional.empty());\n\n        mockMvc.perform(get(\"/api/users/999\"))\n               .andExpect(status().isNotFound());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#datajpatest","title":"@DataJpaTest","text":"<p>For testing JPA repositories:</p> <pre><code>@DataJpaTest\nclass UserRepositoryTests {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private TestEntityManager entityManager;\n\n    @Test\n    void findByUsernameShouldReturnUser() {\n        // Create and persist a test user\n        User user = new User();\n        user.setUsername(\"jpatest\");\n        user.setEmail(\"jpa@example.com\");\n        entityManager.persist(user);\n        entityManager.flush();\n\n        // Test the query method\n        User found = userRepository.findByUsername(\"jpatest\");\n\n        assertThat(found).isNotNull();\n        assertThat(found.getEmail()).isEqualTo(\"jpa@example.com\");\n    }\n\n    @Test\n    void findByUsernameShouldReturnNullWhenUsernameNotFound() {\n        User found = userRepository.findByUsername(\"nonexistent\");\n\n        assertThat(found).isNull();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#jsontest","title":"@JsonTest","text":"<p>For testing JSON serialization and deserialization:</p> <pre><code>@JsonTest\nclass UserJsonTests {\n\n    @Autowired\n    private JacksonTester&lt;User&gt; json;\n\n    @Test\n    void serializeUserToJson() throws Exception {\n        User user = new User();\n        user.setId(1L);\n        user.setUsername(\"jsontest\");\n        user.setEmail(\"json@example.com\");\n\n        JsonContent&lt;User&gt; jsonContent = json.write(user);\n\n        assertThat(jsonContent).extractingJsonPathNumberValue(\"$.id\").isEqualTo(1);\n        assertThat(jsonContent).extractingJsonPathStringValue(\"$.username\").isEqualTo(\"jsontest\");\n        assertThat(jsonContent).extractingJsonPathStringValue(\"$.email\").isEqualTo(\"json@example.com\");\n    }\n\n    @Test\n    void deserializeUserFromJson() throws Exception {\n        String jsonContent = \"{\\\"id\\\":1,\\\"username\\\":\\\"jsontest\\\",\\\"email\\\":\\\"json@example.com\\\"}\";\n\n        User user = json.parse(jsonContent).getObject();\n\n        assertThat(user.getId()).isEqualTo(1L);\n        assertThat(user.getUsername()).isEqualTo(\"jsontest\");\n        assertThat(user.getEmail()).isEqualTo(\"json@example.com\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#restclienttest","title":"@RestClientTest","text":"<p>For testing REST clients:</p> <pre><code>@RestClientTest(RemoteUserService.class)\nclass RemoteUserServiceTests {\n\n    @Autowired\n    private RemoteUserService remoteUserService;\n\n    @Autowired\n    private MockRestServiceServer server;\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @Test\n    void getRemoteUserShouldReturnUser() throws Exception {\n        User user = new User();\n        user.setId(1L);\n        user.setUsername(\"remoteuser\");\n\n        server.expect(requestTo(\"/api/remote/users/1\"))\n              .andRespond(withSuccess(objectMapper.writeValueAsString(user), MediaType.APPLICATION_JSON));\n\n        User result = remoteUserService.getUser(1L);\n\n        assertThat(result).isNotNull();\n        assertThat(result.getUsername()).isEqualTo(\"remoteuser\");\n    }\n\n    @Test\n    void getRemoteUserShouldHandleError() throws Exception {\n        server.expect(requestTo(\"/api/remote/users/999\"))\n              .andRespond(withStatus(HttpStatus.NOT_FOUND));\n\n        assertThatExceptionOfType(UserNotFoundException.class)\n            .isThrownBy(() -&gt; remoteUserService.getUser(999L));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#datamongotest","title":"@DataMongoTest","text":"<p>For testing MongoDB repositories:</p> <pre><code>@DataMongoTest\nclass ProductRepositoryTests {\n\n    @Autowired\n    private ProductRepository productRepository;\n\n    @BeforeEach\n    void setUp() {\n        productRepository.deleteAll();\n    }\n\n    @Test\n    void saveShouldPersistProduct() {\n        Product product = new Product();\n        product.setName(\"Test Product\");\n        product.setPrice(BigDecimal.valueOf(19.99));\n\n        Product savedProduct = productRepository.save(product);\n\n        assertThat(savedProduct.getId()).isNotNull();\n\n        Optional&lt;Product&gt; foundProduct = productRepository.findById(savedProduct.getId());\n        assertThat(foundProduct).isPresent();\n        assertThat(foundProduct.get().getName()).isEqualTo(\"Test Product\");\n    }\n\n    @Test\n    void findByNameShouldReturnProducts() {\n        // Create and save two products\n        Product product1 = new Product();\n        product1.setName(\"Search Product\");\n        product1.setPrice(BigDecimal.valueOf(29.99));\n        productRepository.save(product1);\n\n        Product product2 = new Product();\n        product2.setName(\"Another Product\");\n        product2.setPrice(BigDecimal.valueOf(39.99));\n        productRepository.save(product2);\n\n        // Test the query\n        List&lt;Product&gt; foundProducts = productRepository.findByNameContaining(\"Search\");\n\n        assertThat(foundProducts).hasSize(1);\n        assertThat(foundProducts.get(0).getName()).isEqualTo(\"Search Product\");\n    }\n} \n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#mocking-with-mockito","title":"Mocking with Mockito","text":"<p>Mockito is a popular mocking framework bundled with Spring Boot's testing starter. It allows you to create mock objects, specify their behavior, and verify their interactions.</p>"},{"location":"spring-boot/spring-boot-testing/#basic-mocking","title":"Basic Mocking","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass NotificationServiceTests {\n\n    @Mock\n    private EmailSender emailSender;\n\n    @Mock\n    private SMSGateway smsGateway;\n\n    @InjectMocks\n    private NotificationServiceImpl notificationService;\n\n    @Test\n    void notifyUserShouldSendEmailAndSMS() {\n        // Arrange\n        User user = new User(\"user@example.com\", \"1234567890\");\n        String message = \"Test notification\";\n\n        // No need to define behavior for void methods like these\n        // unless you want them to throw exceptions\n\n        // Act\n        notificationService.notifyUser(user, message);\n\n        // Assert - verify the mock interactions\n        verify(emailSender).sendEmail(user.getEmail(), message);\n        verify(smsGateway).sendSMS(user.getPhoneNumber(), message);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#stubbing-method-calls","title":"Stubbing Method Calls","text":"<pre><code>@Test\nvoid getUserFullNameShouldCombineFirstAndLastName() {\n    // Arrange\n    UserRepository userRepository = mock(UserRepository.class);\n    User user = new User();\n    user.setFirstName(\"John\");\n    user.setLastName(\"Doe\");\n\n    when(userRepository.findById(1L)).thenReturn(Optional.of(user));\n\n    UserService userService = new UserServiceImpl(userRepository);\n\n    // Act\n    String fullName = userService.getUserFullName(1L);\n\n    // Assert\n    assertThat(fullName).isEqualTo(\"John Doe\");\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#advanced-mocking-techniques","title":"Advanced Mocking Techniques","text":""},{"location":"spring-boot/spring-boot-testing/#argument-matchers","title":"Argument Matchers","text":"<pre><code>// Using any() to match any argument\nwhen(userRepository.findByUsername(any())).thenReturn(user);\n\n// Using specific argument matchers\nwhen(userRepository.findByUsernameAndActive(eq(\"admin\"), anyBoolean())).thenReturn(user);\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#argument-captor","title":"Argument Captor","text":"<pre><code>@Test\nvoid processOrderShouldSendConfirmationEmail() {\n    // Arrange\n    ArgumentCaptor&lt;String&gt; emailCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor&lt;String&gt; subjectCaptor = ArgumentCaptor.forClass(String.class);\n\n    Order order = new Order();\n    order.setId(\"ORD-12345\");\n    order.setCustomerEmail(\"customer@example.com\");\n\n    // Act\n    orderService.processOrder(order);\n\n    // Assert - Capture and verify the arguments\n    verify(emailService).sendEmail(emailCaptor.capture(), subjectCaptor.capture(), any());\n\n    assertThat(emailCaptor.getValue()).isEqualTo(\"customer@example.com\");\n    assertThat(subjectCaptor.getValue()).contains(\"ORD-12345\");\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#spy-on-real-objects","title":"Spy on Real Objects","text":"<pre><code>@Test\nvoid calculateTotalWithSpy() {\n    // Create a spy on a real object\n    List&lt;String&gt; list = new ArrayList&lt;&gt;();\n    List&lt;String&gt; spyList = spy(list);\n\n    // Use the spy\n    spyList.add(\"one\");\n    spyList.add(\"two\");\n\n    // Real method calls work normally\n    assertThat(spyList.size()).isEqualTo(2);\n\n    // But we can also stub specific methods\n    when(spyList.size()).thenReturn(100);\n    assertThat(spyList.size()).isEqualTo(100);\n\n    // Other methods still work with real behavior\n    assertThat(spyList.get(0)).isEqualTo(\"one\");\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#mocking-static-methods-mockito-340","title":"Mocking Static Methods (Mockito 3.4.0+)","text":"<pre><code>@Test\nvoid testStaticMethod() {\n    try (MockedStatic&lt;UtilityClass&gt; mockedStatic = mockStatic(UtilityClass.class)) {\n        // Stub the static method\n        mockedStatic.when(() -&gt; UtilityClass.getCurrentDate())\n                   .thenReturn(LocalDate.of(2023, 1, 1));\n\n        // Test code that uses the static method\n        LocalDate result = myService.processWithDate();\n\n        // Assert\n        assertThat(result).isEqualTo(LocalDate.of(2023, 1, 1));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-security","title":"Testing Security","text":"<p>Spring Security is a critical component in most applications. Testing security configurations and behavior ensures your application remains protected.</p>"},{"location":"spring-boot/spring-boot-testing/#basic-security-test-setup","title":"Basic Security Test Setup","text":"<pre><code>@SpringBootTest\n@AutoConfigureMockMvc\nclass SecurityConfigTests {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    void publicEndpointShouldBeAccessible() throws Exception {\n        mockMvc.perform(get(\"/api/public\"))\n               .andExpect(status().isOk());\n    }\n\n    @Test\n    void privateEndpointShouldRequireAuthentication() throws Exception {\n        mockMvc.perform(get(\"/api/private\"))\n               .andExpect(status().isUnauthorized());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-with-authentication","title":"Testing with Authentication","text":"<pre><code>@SpringBootTest\n@AutoConfigureMockMvc\nclass AuthenticatedEndpointsTests {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    @WithMockUser(username = \"user\", roles = {\"USER\"})\n    void userCanAccessUserEndpoint() throws Exception {\n        mockMvc.perform(get(\"/api/user\"))\n               .andExpect(status().isOk());\n    }\n\n    @Test\n    @WithMockUser(username = \"user\", roles = {\"USER\"})\n    void userCannotAccessAdminEndpoint() throws Exception {\n        mockMvc.perform(get(\"/api/admin\"))\n               .andExpect(status().isForbidden());\n    }\n\n    @Test\n    @WithMockUser(username = \"admin\", roles = {\"ADMIN\"})\n    void adminCanAccessAdminEndpoint() throws Exception {\n        mockMvc.perform(get(\"/api/admin\"))\n               .andExpect(status().isOk());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#custom-security-context","title":"Custom Security Context","text":"<pre><code>@Test\nvoid customSecurityContext() throws Exception {\n    List&lt;GrantedAuthority&gt; authorities = List.of(new SimpleGrantedAuthority(\"ROLE_CUSTOM\"));\n\n    SecurityContext securityContext = SecurityContextHolder.createEmptyContext();\n    securityContext.setAuthentication(\n        new UsernamePasswordAuthenticationToken(\"customUser\", \"password\", authorities)\n    );\n    SecurityContextHolder.setContext(securityContext);\n\n    mockMvc.perform(get(\"/api/custom\").with(SecurityMockMvcRequestPostProcessors.csrf()))\n           .andExpect(status().isOk());\n\n    // Always clean up after test\n    SecurityContextHolder.clearContext();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-jwt-authentication","title":"Testing JWT Authentication","text":"<pre><code>@SpringBootTest\n@AutoConfigureMockMvc\nclass JwtAuthenticationTests {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Autowired\n    private JwtTokenProvider jwtTokenProvider;\n\n    @Test\n    void endpointShouldBeAccessibleWithValidJwt() throws Exception {\n        String token = jwtTokenProvider.createToken(\"user\", List.of(\"ROLE_USER\"));\n\n        mockMvc.perform(get(\"/api/secured\")\n               .header(\"Authorization\", \"Bearer \" + token))\n               .andExpect(status().isOk());\n    }\n\n    @Test\n    void endpointShouldRejectInvalidJwt() throws Exception {\n        mockMvc.perform(get(\"/api/secured\")\n               .header(\"Authorization\", \"Bearer invalidToken\"))\n               .andExpect(status().isUnauthorized());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#oauth2-testing","title":"OAuth2 Testing","text":"<pre><code>@SpringBootTest\n@AutoConfigureMockMvc\nclass OAuth2Tests {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    @WithMockUser(username = \"oauth_user\")\n    void oauthEndpointWithMockUser() throws Exception {\n        mockMvc.perform(get(\"/api/oauth\"))\n               .andExpect(status().isOk());\n    }\n\n    @Test\n    void oauthEndpointWithOAuth2Login() throws Exception {\n        mockMvc.perform(get(\"/api/oauth\")\n               .with(SecurityMockMvcRequestPostProcessors.oauth2Login()))\n               .andExpect(status().isOk());\n    }\n\n    @Test\n    void oauthEndpointWithCustomOAuth2Login() throws Exception {\n        mockMvc.perform(get(\"/api/oauth\")\n               .with(SecurityMockMvcRequestPostProcessors.oauth2Login()\n                    .attributes(attrs -&gt; {\n                        attrs.put(\"sub\", \"1234567890\");\n                        attrs.put(\"name\", \"Test User\");\n                        attrs.put(\"email\", \"testuser@example.com\");\n                    })))\n               .andExpect(status().isOk());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-configurations","title":"Testing Configurations","text":"<p>Testing application configurations ensures that your application behaves correctly with different property settings.</p>"},{"location":"spring-boot/spring-boot-testing/#testing-properties-configuration","title":"Testing Properties Configuration","text":"<pre><code>@SpringBootTest(properties = {\"app.feature.enabled=true\", \"app.max-items=10\"})\nclass ConfigurationTests {\n\n    @Autowired\n    private ApplicationProperties appProperties;\n\n    @Test\n    void propertiesShouldBeLoaded() {\n        assertThat(appProperties.getFeature().isEnabled()).isTrue();\n        assertThat(appProperties.getMaxItems()).isEqualTo(10);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-profile-specific-configuration","title":"Testing Profile-Specific Configuration","text":"<pre><code>@SpringBootTest\n@ActiveProfiles(\"test\")\nclass ProfileConfigTests {\n\n    @Autowired\n    private Environment environment;\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Test\n    void testProfileShouldBeActive() {\n        assertThat(environment.getActiveProfiles()).contains(\"test\");\n    }\n\n    @Test\n    void databaseShouldBeH2InTestProfile() {\n        try (Connection conn = dataSource.getConnection()) {\n            String dbProduct = conn.getMetaData().getDatabaseProductName();\n            assertThat(dbProduct.toLowerCase()).contains(\"h2\");\n        } catch (SQLException e) {\n            fail(\"Failed to connect to database\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-configuration-properties-classes","title":"Testing Configuration Properties Classes","text":"<pre><code>@ConfigurationPropertiesTest\nclass EmailConfigPropertiesTests {\n\n    @Test\n    void validateConfigProperties(\n            @ConfigurationProperty(prefix = \"app.email\") Map&lt;String, Object&gt; properties) {\n\n        assertThat(properties).containsEntry(\"host\", \"smtp.example.com\");\n        assertThat(properties).containsEntry(\"port\", 587);\n        assertThat(properties).containsEntry(\"username\", \"test@example.com\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-with-external-configuration","title":"Testing with External Configuration","text":"<pre><code>@SpringBootTest\n@TestPropertySource(locations = \"classpath:test-application.properties\")\nclass ExternalConfigTests {\n\n    @Autowired\n    private ApplicationProperties appProperties;\n\n    @Test\n    void propertiesFromExternalFileShouldBeLoaded() {\n        assertThat(appProperties.getApi().getBaseUrl()).isEqualTo(\"https://test-api.example.com\");\n        assertThat(appProperties.getApi().getTimeout()).isEqualTo(Duration.ofSeconds(30));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#test-containers","title":"Test Containers","text":"<p>Testcontainers is a Java library that provides lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container. It's particularly useful for integration testing.</p>"},{"location":"spring-boot/spring-boot-testing/#getting-started-with-testcontainers","title":"Getting Started with Testcontainers","text":"<p>First, add the dependencies:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;testcontainers&lt;/artifactId&gt;\n    &lt;version&gt;1.17.6&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n    &lt;version&gt;1.17.6&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n    &lt;version&gt;1.17.6&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#testing-with-a-postgresql-container","title":"Testing with a PostgreSQL Container","text":"<pre><code>@SpringBootTest\n@Testcontainers\nclass PostgresIntegrationTests {\n\n    @Container\n    static PostgreSQLContainer&lt;?&gt; postgres = new PostgreSQLContainer&lt;&gt;(\"postgres:14.5\")\n            .withDatabaseName(\"testdb\")\n            .withUsername(\"test\")\n            .withPassword(\"test\");\n\n    @DynamicPropertySource\n    static void postgresProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n    }\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    void shouldSaveAndRetrieveUser() {\n        // Given\n        User user = new User();\n        user.setUsername(\"testcontainer\");\n        user.setEmail(\"test@container.com\");\n\n        // When\n        userRepository.save(user);\n\n        // Then\n        Optional&lt;User&gt; found = userRepository.findByUsername(\"testcontainer\");\n        assertThat(found).isPresent();\n        assertThat(found.get().getEmail()).isEqualTo(\"test@container.com\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#multiple-containers-and-container-networks","title":"Multiple Containers and Container Networks","text":"<pre><code>@SpringBootTest\n@Testcontainers\nclass MultiContainerTests {\n\n    static Network network = Network.newNetwork();\n\n    @Container\n    static PostgreSQLContainer&lt;?&gt; postgres = new PostgreSQLContainer&lt;&gt;(\"postgres:14.5\")\n            .withNetwork(network)\n            .withNetworkAliases(\"postgres\")\n            .withDatabaseName(\"testdb\")\n            .withUsername(\"test\")\n            .withPassword(\"test\");\n\n    @Container\n    static GenericContainer&lt;?&gt; redis = new GenericContainer&lt;&gt;(\"redis:6.2\")\n            .withNetwork(network)\n            .withNetworkAliases(\"redis\")\n            .withExposedPorts(6379);\n\n    @DynamicPropertySource\n    static void configureProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n        registry.add(\"spring.redis.host\", redis::getHost);\n        registry.add(\"spring.redis.port\", redis::getFirstMappedPort);\n    }\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private RedisTemplate&lt;String, String&gt; redisTemplate;\n\n    @Test\n    void shouldInteractWithMultipleContainers() {\n        // Test PostgreSQL\n        User user = new User();\n        user.setUsername(\"multicontainer\");\n        userRepository.save(user);\n\n        assertThat(userRepository.findByUsername(\"multicontainer\")).isPresent();\n\n        // Test Redis\n        redisTemplate.opsForValue().set(\"testkey\", \"testvalue\");\n        String value = redisTemplate.opsForValue().get(\"testkey\");\n\n        assertThat(value).isEqualTo(\"testvalue\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#custom-container-classes","title":"Custom Container Classes","text":"<pre><code>public class CustomPostgreSQLContainer extends PostgreSQLContainer&lt;CustomPostgreSQLContainer&gt; {\n\n    private static final String IMAGE_VERSION = \"postgres:14.5\";\n    private static CustomPostgreSQLContainer container;\n\n    private CustomPostgreSQLContainer() {\n        super(IMAGE_VERSION);\n    }\n\n    public static CustomPostgreSQLContainer getInstance() {\n        if (container == null) {\n            container = new CustomPostgreSQLContainer()\n                    .withDatabaseName(\"testdb\")\n                    .withUsername(\"test\")\n                    .withPassword(\"test\")\n                    .withInitScript(\"init.sql\");\n        }\n        return container;\n    }\n\n    @Override\n    public void start() {\n        super.start();\n        System.setProperty(\"DB_URL\", container.getJdbcUrl());\n        System.setProperty(\"DB_USERNAME\", container.getUsername());\n        System.setProperty(\"DB_PASSWORD\", container.getPassword());\n    }\n\n    @Override\n    public void stop() {\n        // do nothing, JVM handles shutdown\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#performance-and-load-testing","title":"Performance and Load Testing","text":"<p>Performance testing ensures your application meets its performance criteria under various conditions.</p>"},{"location":"spring-boot/spring-boot-testing/#jmeter-integration","title":"JMeter Integration","text":"<p>JMeter is a popular tool for load testing. You can integrate it with Spring Boot:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.jmeter&lt;/groupId&gt;\n    &lt;artifactId&gt;ApacheJMeter_core&lt;/artifactId&gt;\n    &lt;version&gt;5.5&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.jmeter&lt;/groupId&gt;\n    &lt;artifactId&gt;ApacheJMeter_http&lt;/artifactId&gt;\n    &lt;version&gt;5.5&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#basic-performance-testing","title":"Basic Performance Testing","text":"<pre><code>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nclass PerformanceTests {\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    void endpointResponseTimeShouldBeLessThan500ms() {\n        // Warm up\n        for (int i = 0; i &lt; 5; i++) {\n            restTemplate.getForEntity(\"/api/products\", String.class);\n        }\n\n        // Test\n        long startTime = System.currentTimeMillis();\n        ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(\"/api/products\", String.class);\n        long endTime = System.currentTimeMillis();\n        long duration = endTime - startTime;\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(duration).isLessThan(500);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#load-testing-with-concurrent-requests","title":"Load Testing with Concurrent Requests","text":"<pre><code>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nclass LoadTests {\n\n    @LocalServerPort\n    private int port;\n\n    @Test\n    void shouldHandleConcurrentRequests() throws Exception {\n        String url = \"http://localhost:\" + port + \"/api/products\";\n        int numThreads = 10;\n        int requestsPerThread = 100;\n\n        ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n        CountDownLatch latch = new CountDownLatch(numThreads);\n        AtomicInteger successCounter = new AtomicInteger(0);\n        AtomicInteger failCounter = new AtomicInteger(0);\n\n        for (int i = 0; i &lt; numThreads; i++) {\n            executor.submit(() -&gt; {\n                try {\n                    for (int j = 0; j &lt; requestsPerThread; j++) {\n                        try {\n                            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n                            connection.setRequestMethod(\"GET\");\n                            int responseCode = connection.getResponseCode();\n\n                            if (responseCode == 200) {\n                                successCounter.incrementAndGet();\n                            } else {\n                                failCounter.incrementAndGet();\n                            }\n\n                            connection.disconnect();\n                        } catch (Exception e) {\n                            failCounter.incrementAndGet();\n                        }\n                    }\n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n\n        // Wait for all threads to finish\n        boolean completed = latch.await(2, TimeUnit.MINUTES);\n\n        assertThat(completed).isTrue();\n        assertThat(successCounter.get()).isEqualTo(numThreads * requestsPerThread);\n        assertThat(failCounter.get()).isZero();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#gatling-for-load-testing","title":"Gatling for Load Testing","text":"<p>Gatling is a more sophisticated load testing tool:</p> <pre><code>class ProductsSimulation extends Simulation {\n\n  val httpProtocol = http\n    .baseUrl(\"http://localhost:8080\")\n    .acceptHeader(\"application/json\")\n    .userAgentHeader(\"Gatling Load Test\")\n\n  val scn = scenario(\"Products Load Test\")\n    .exec(http(\"Get All Products\")\n      .get(\"/api/products\")\n      .check(status.is(200)))\n    .pause(1)\n    .exec(http(\"Get Single Product\")\n      .get(\"/api/products/1\")\n      .check(status.is(200)))\n    .pause(1)\n    .exec(http(\"Search Products\")\n      .get(\"/api/products/search?query=phone\")\n      .check(status.is(200)))\n\n  setUp(\n    scn.inject(\n      rampUsers(100).during(10.seconds),\n      constantUsersPerSec(10).during(1.minute)\n    )\n  ).protocols(httpProtocol)\n    .assertions(\n      global.responseTime.max.lt(500),\n      global.successfulRequests.percent.gt(95)\n    )\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#test-driven-development","title":"Test-Driven Development","text":"<p>Test-Driven Development (TDD) is a software development approach where tests are written before the actual implementation code.</p>"},{"location":"spring-boot/spring-boot-testing/#the-tdd-cycle","title":"The TDD Cycle","text":"<ol> <li>Red: Write a failing test.</li> <li>Green: Implement the minimum code needed to pass the test.</li> <li>Refactor: Improve the code while keeping the tests passing.</li> </ol>"},{"location":"spring-boot/spring-boot-testing/#example-tdd-workflow","title":"Example TDD Workflow","text":"<p>Let's implement a calculator service using TDD:</p> <ol> <li>Red Phase - Write a failing test:</li> </ol> <pre><code>@Test\nvoid addShouldReturnSumOfTwoNumbers() {\n    // Arrange\n    CalculatorService calculator = new CalculatorServiceImpl();\n\n    // Act\n    int result = calculator.add(3, 4);\n\n    // Assert\n    assertThat(result).isEqualTo(7);\n}\n</code></pre> <ol> <li>Green Phase - Implement the minimal code to pass:</li> </ol> <pre><code>public class CalculatorServiceImpl implements CalculatorService {\n\n    @Override\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    // Other methods not implemented yet\n}\n</code></pre> <ol> <li>Refactor Phase - Improve code quality:</li> </ol> <pre><code>public class CalculatorServiceImpl implements CalculatorService {\n\n    @Override\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    // Maybe refactor common validation or logging here\n}\n</code></pre> <ol> <li>Continue the Cycle - Add more tests for new functionality:</li> </ol> <pre><code>@Test\nvoid subtractShouldReturnDifferenceOfTwoNumbers() {\n    // Arrange\n    CalculatorService calculator = new CalculatorServiceImpl();\n\n    // Act\n    int result = calculator.subtract(7, 3);\n\n    // Assert\n    assertThat(result).isEqualTo(4);\n}\n</code></pre> <ol> <li>Red-Green-Refactor again:</li> </ol> <pre><code>public class CalculatorServiceImpl implements CalculatorService {\n\n    @Override\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    @Override\n    public int subtract(int a, int b) {\n        return a - b;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#benefits-of-tdd","title":"Benefits of TDD","text":"<ul> <li>Focused Development: You only write code that's needed to pass tests.</li> <li>High Test Coverage: Tests are guaranteed for all features.</li> <li>Better Design: TDD encourages modular, loosely coupled code.</li> <li>Documentation: Tests serve as documentation for how code should behave.</li> <li>Confidence: Changing code is safer with a test suite to catch regressions.</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"spring-boot/spring-boot-testing/#structure-tests-according-to-aaa-pattern","title":"Structure Tests According to AAA Pattern","text":"<ul> <li>Arrange: Set up test prerequisites.</li> <li>Act: Perform the action being tested.</li> <li>Assert: Verify the expected outcome.</li> </ul> <pre><code>@Test\nvoid userRegistrationShouldCreateNewUser() {\n    // Arrange\n    UserRegistrationRequest request = new UserRegistrationRequest();\n    request.setUsername(\"newuser\");\n    request.setEmail(\"newuser@example.com\");\n    request.setPassword(\"password123\");\n\n    // Act\n    UserResponse response = userService.registerUser(request);\n\n    // Assert\n    assertThat(response).isNotNull();\n    assertThat(response.getUsername()).isEqualTo(\"newuser\");\n    assertThat(userRepository.findByUsername(\"newuser\")).isPresent();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#use-meaningful-test-names","title":"Use Meaningful Test Names","text":"<p>Test names should clearly describe what's being tested and expected behavior:</p> <pre><code>@Test\nvoid shouldReturnNotFoundWhenUserDoesNotExist() { ... }\n\n@Test\nvoid shouldThrowExceptionWhenEmailIsInvalid() { ... }\n\n@Test\nvoid shouldSendConfirmationEmailWhenOrderIsPlaced() { ... }\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#avoid-test-interdependencies","title":"Avoid Test Interdependencies","text":"<p>Each test should be independent and not rely on other tests:</p> <pre><code>// BAD - Tests depend on each other\n@Test\nvoid test1_createUser() { ... } // Creates a user for test2\n\n@Test\nvoid test2_updateUser() { ... } // Uses the user from test1\n\n// GOOD - Each test is independent\n@Test\nvoid shouldCreateUser() {\n    // Arrange all prerequisites here\n    // Act\n    // Assert\n}\n\n@Test\nvoid shouldUpdateUser() {\n    // Arrange all prerequisites here, including creating a user\n    // Act\n    // Assert\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#use-appropriate-assertion-libraries","title":"Use Appropriate Assertion Libraries","text":"<pre><code>// JUnit assertions\nassertEquals(expected, actual);\nassertTrue(condition);\n\n// AssertJ fluent assertions (preferred)\nassertThat(actual).isEqualTo(expected);\nassertThat(collection).hasSize(3).contains(\"item1\", \"item2\");\nassertThat(exception).isInstanceOf(IllegalArgumentException.class)\n                    .hasMessageContaining(\"Invalid input\");\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#test-edge-cases-and-error-paths","title":"Test Edge Cases and Error Paths","text":"<pre><code>@Test\nvoid shouldHandleEmptyInput() { ... }\n\n@Test\nvoid shouldHandleMaximumSizeInput() { ... }\n\n@Test\nvoid shouldThrowExceptionForInvalidData() { ... }\n\n@Test\nvoid shouldHandleNetworkTimeouts() { ... }\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#clean-up-after-tests","title":"Clean Up After Tests","text":"<pre><code>@AfterEach\nvoid tearDown() {\n    // Clean up database\n    userRepository.deleteAll();\n\n    // Reset any static data\n    TestData.reset();\n\n    // Clear security context\n    SecurityContextHolder.clearContext();\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#use-test-fixtures-and-factories","title":"Use Test Fixtures and Factories","text":"<pre><code>public class UserTestFactory {\n    public static User createValidUser() {\n        User user = new User();\n        user.setId(UUID.randomUUID());\n        user.setUsername(\"testuser\");\n        user.setEmail(\"test@example.com\");\n        user.setCreatedAt(LocalDateTime.now());\n        user.setActive(true);\n        return user;\n    }\n\n    public static User createAdminUser() {\n        User user = createValidUser();\n        user.setUsername(\"adminuser\");\n        user.setEmail(\"admin@example.com\");\n        user.setRole(Role.ADMIN);\n        return user;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#use-test-tags-for-categorization","title":"Use Test Tags for Categorization","text":"<pre><code>@Tag(\"unit\")\nclass UserServiceTests { ... }\n\n@Tag(\"integration\")\nclass UserRepositoryTests { ... }\n\n@Tag(\"slow\")\n@Tag(\"database\")\nclass LargeDatasetTests { ... }\n</code></pre>"},{"location":"spring-boot/spring-boot-testing/#maintain-test-quality","title":"Maintain Test Quality","text":"<ul> <li>Keep Tests Fast: Slow tests discourage frequent testing.</li> <li>Keep Tests Simple: Complex test logic is prone to bugs.</li> <li>Review Test Code: Test code should meet the same quality standards as production code.</li> <li>Refactor Tests: Continuously improve test code to avoid test maintenance burden.</li> <li>Prioritize Test Reliability: Flaky tests erode confidence in the test suite.</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#continuous-integration","title":"Continuous Integration","text":"<ul> <li>Run tests automatically on every push.</li> <li>Include test coverage reports.</li> <li>Fail builds when tests fail.</li> <li>Monitor test performance over time.</li> </ul>"},{"location":"spring-boot/spring-boot-testing/#summary","title":"Summary","text":"<p>Testing is a critical part of Spring Boot application development. With Spring Boot's comprehensive testing support, you can:</p> <ul> <li>Write effective unit tests for isolated components.</li> <li>Create integration tests to verify component interactions.</li> <li>Test specific layers using test slices.</li> <li>Mock dependencies for controlled testing.</li> <li>Verify security constraints.</li> <li>Test with realistic environments using test containers.</li> <li>Measure and optimize performance.</li> <li>Apply test-driven development principles.</li> </ul> <p>Following best practices ensures your tests remain valuable, maintainable, and effective at catching bugs before they reach production.</p>"},{"location":"spring-boot/spring-boot-testing/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Testing Documentation</li> <li>JUnit 5 User Guide</li> <li>Mockito Documentation</li> <li>Testcontainers Documentation</li> <li>AssertJ Documentation</li> </ul>"},{"location":"spring-boot/spring-data-jpa/","title":"Macro Syntax Error","text":"<p>File: <code>spring-boot/spring-data-jpa.md</code></p> <p>Line 806 in Markdown file: Missing end of comment tag <pre><code>    @Query(\"SELECT p FROM #{#entityName} p WHERE p.inStock = :inStock\")\n</code></pre></p>"},{"location":"spring-boot/spring-data-mongo/","title":"Spring Data MongoDB","text":""},{"location":"spring-boot/spring-data-mongo/#overview","title":"Overview","text":"<p>This guide explores Spring Data MongoDB, a part of the Spring Data family that makes it easy to implement MongoDB-based repositories. Spring Data MongoDB simplifies data access by reducing boilerplate code and providing powerful abstractions for MongoDB operations. It helps developers create repository implementations automatically, write sophisticated queries with minimal code, and focus on business logic rather than data access infrastructure.</p>"},{"location":"spring-boot/spring-data-mongo/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Java and Spring Boot</li> <li>Understanding of NoSQL databases and MongoDB concepts</li> <li>Familiarity with MongoDB query operations</li> <li>Development environment with Spring Boot set up</li> </ul>"},{"location":"spring-boot/spring-data-mongo/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the core concepts and benefits of Spring Data MongoDB</li> <li>Configure Spring Data MongoDB in Spring Boot applications</li> <li>Create and use MongoDB repositories</li> <li>Define domain models with document annotations</li> <li>Implement basic and advanced MongoDB queries</li> <li>Work with MongoDB aggregation framework</li> <li>Manage relationships in MongoDB</li> <li>Implement geospatial queries</li> <li>Optimize MongoDB operations for performance</li> </ul>"},{"location":"spring-boot/spring-data-mongo/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Spring Data MongoDB</li> <li>Setting Up Spring Data MongoDB</li> <li>Document Mapping</li> <li>MongoDB Repositories</li> <li>Query Methods</li> <li>Custom Queries</li> <li>MongoDB Template</li> <li>Aggregation Framework</li> <li>Indexing</li> <li>Geospatial Queries</li> <li>GridFS for Large Files</li> <li>Change Streams</li> <li>Transactions</li> <li>Testing Spring Data MongoDB</li> </ol>"},{"location":"spring-boot/spring-data-mongo/#introduction-to-spring-data-mongodb","title":"Introduction to Spring Data MongoDB","text":"<p>Spring Data MongoDB is a library that simplifies the development of MongoDB-based data access layers. It removes most of the boilerplate code required when working with MongoDB.</p>"},{"location":"spring-boot/spring-data-mongo/#what-is-spring-data-mongodb","title":"What is Spring Data MongoDB?","text":"<p>Spring Data MongoDB is part of the larger Spring Data family, which aims to provide a familiar and consistent Spring-based programming model for data access while retaining the special traits of the underlying data store.</p> <p>Spring Data MongoDB specifically focuses on adding enhanced support for MongoDB-based data access layers. It makes it easier to build Spring-powered applications that use MongoDB by:</p> <ul> <li>Reducing boilerplate code for repository implementations</li> <li>Providing powerful repository and custom object-mapping abstractions</li> <li>Dynamically generating queries from method names</li> <li>Supporting integration with custom repositories</li> <li>Simplifying MongoDB-specific operations</li> </ul>"},{"location":"spring-boot/spring-data-mongo/#key-benefits-of-spring-data-mongodb","title":"Key Benefits of Spring Data MongoDB","text":"<ol> <li>Reduced Boilerplate: Implement repositories with minimal code</li> <li>Consistent API: Standard CRUD operations across repositories</li> <li>Method Name Queries: Create queries by defining method names</li> <li>MongoDB Template: Easy access to MongoDB-specific operations</li> <li>Automatic Object Mapping: Conversion between Java objects and BSON documents</li> <li>Custom Queries: Simple integration of MongoDB Query Language</li> <li>Aggregation Framework Support: Fluent API for MongoDB aggregations</li> <li>Geospatial Queries: Support for location-based queries</li> <li>GridFS Support: Store and retrieve large files</li> <li>Reactive Support: Reactive programming model for MongoDB operations</li> </ol>"},{"location":"spring-boot/spring-data-mongo/#setting-up-spring-data-mongodb","title":"Setting Up Spring Data MongoDB","text":""},{"location":"spring-boot/spring-data-mongo/#maven-dependencies","title":"Maven Dependencies","text":"<p>To use Spring Data MongoDB in a Spring Boot application, add the following dependencies:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For reactive MongoDB support:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#basic-configuration","title":"Basic Configuration","text":"<p>Spring Boot provides auto-configuration for Spring Data MongoDB. Configure it in <code>application.properties</code> or <code>application.yml</code>:</p> <p>application.properties: <pre><code># MongoDB Configuration\nspring.data.mongodb.host=localhost\nspring.data.mongodb.port=27017\nspring.data.mongodb.database=mydb\n# Optional authentication\nspring.data.mongodb.username=user\nspring.data.mongodb.password=password\n</code></pre></p> <p>application.yml: <pre><code>spring:\n  data:\n    mongodb:\n      host: localhost\n      port: 27017\n      database: mydb\n      # Optional authentication\n      username: user\n      password: password\n</code></pre></p>"},{"location":"spring-boot/spring-data-mongo/#mongodb-uri-configuration","title":"MongoDB URI Configuration","text":"<p>Alternatively, use a MongoDB connection string:</p> <pre><code>spring.data.mongodb.uri=mongodb://user:password@localhost:27017/mydb\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#custom-mongodb-configuration","title":"Custom MongoDB Configuration","text":"<p>For more control, define a custom MongoDB configuration:</p> <pre><code>@Configuration\npublic class MongoConfig extends AbstractMongoClientConfiguration {\n\n    @Override\n    protected String getDatabaseName() {\n        return \"mydb\";\n    }\n\n    @Override\n    public MongoClient mongoClient() {\n        return MongoClients.create(\"mongodb://localhost:27017\");\n    }\n\n    @Override\n    protected void configureClientSettings(MongoClientSettings.Builder builder) {\n        builder.applyToClusterSettings(settings -&gt; {\n            settings.hosts(List.of(new ServerAddress(\"localhost\", 27017)));\n        })\n        .applyToConnectionPoolSettings(settings -&gt; {\n            settings.maxConnectionIdleTime(10000, TimeUnit.MILLISECONDS);\n            settings.maxSize(100);\n        });\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#document-mapping","title":"Document Mapping","text":"<p>In Spring Data MongoDB, Java classes are mapped to MongoDB documents using annotations.</p>"},{"location":"spring-boot/spring-data-mongo/#basic-document-class","title":"Basic Document Class","text":"<pre><code>@Document(collection = \"products\")\npublic class Product {\n\n    @Id\n    private String id;\n\n    private String name;\n\n    private String description;\n\n    @Field(\"price_amount\")\n    private BigDecimal price;\n\n    private boolean inStock;\n\n    @CreatedDate\n    private Date createdAt;\n\n    @LastModifiedDate\n    private Date lastModified;\n\n    // Constructors, getters, setters, etc.\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#document-annotations","title":"Document Annotations","text":"<ul> <li><code>@Document</code>: Marks the class as a domain object to be persisted to MongoDB</li> <li><code>@Id</code>: Designates the identifier field</li> <li><code>@Field</code>: Customizes the field name in the document</li> <li><code>@Indexed</code>: Creates an index on the field</li> <li><code>@CompoundIndex</code>: Creates a compound index</li> <li><code>@DBRef</code>: References another document</li> <li><code>@Transient</code>: Marks a field to be ignored</li> <li><code>@CreatedDate</code>, <code>@LastModifiedDate</code>: For auditing</li> </ul>"},{"location":"spring-boot/spring-data-mongo/#embedded-documents","title":"Embedded Documents","text":"<pre><code>@Document(collection = \"customers\")\npublic class Customer {\n\n    @Id\n    private String id;\n\n    private String name;\n\n    private String email;\n\n    @Field(\"shipping_address\")\n    private Address shippingAddress;\n\n    @Field(\"billing_address\")\n    private Address billingAddress;\n\n    // Getters, setters, etc.\n}\n\npublic class Address {\n    private String street;\n    private String city;\n    private String state;\n    private String zipCode;\n\n    // Getters, setters, etc.\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#document-references","title":"Document References","text":"<pre><code>@Document(collection = \"orders\")\npublic class Order {\n\n    @Id\n    private String id;\n\n    private String orderNumber;\n\n    @DBRef\n    private Customer customer;\n\n    private List&lt;OrderItem&gt; items = new ArrayList&lt;&gt;();\n\n    private OrderStatus status;\n\n    private Date orderDate;\n\n    // Getters, setters, etc.\n}\n\npublic class OrderItem {\n    private String productId;\n    private String productName;\n    private int quantity;\n    private BigDecimal price;\n\n    // Getters, setters, etc.\n}\n\npublic enum OrderStatus {\n    PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#customizing-mapping","title":"Customizing Mapping","text":"<p>For more control over document mapping:</p> <pre><code>@Configuration\npublic class MongoCustomConversions extends AbstractMongoClientConfiguration {\n\n    @Override\n    protected String getDatabaseName() {\n        return \"mydb\";\n    }\n\n    @Bean\n    public MongoCustomConversions mongoCustomConversions() {\n        List&lt;Converter&lt;?, ?&gt;&gt; converters = new ArrayList&lt;&gt;();\n        converters.add(new DateToZonedDateTimeConverter());\n        converters.add(new ZonedDateTimeToDateConverter());\n        return new MongoCustomConversions(converters);\n    }\n\n    class DateToZonedDateTimeConverter implements Converter&lt;Date, ZonedDateTime&gt; {\n        @Override\n        public ZonedDateTime convert(Date source) {\n            return source == null ? null : ZonedDateTime.ofInstant(source.toInstant(), ZoneId.systemDefault());\n        }\n    }\n\n    class ZonedDateTimeToDateConverter implements Converter&lt;ZonedDateTime, Date&gt; {\n        @Override\n        public Date convert(ZonedDateTime source) {\n            return source == null ? null : Date.from(source.toInstant());\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#mongodb-repositories","title":"MongoDB Repositories","text":"<p>Spring Data MongoDB provides repositories that offer methods for common MongoDB operations.</p>"},{"location":"spring-boot/spring-data-mongo/#basic-repository","title":"Basic Repository","text":"<pre><code>public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {\n    // That's it! You get CRUD operations for free\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#using-the-repository","title":"Using the Repository","text":"<pre><code>@Service\npublic class ProductService {\n\n    private final ProductRepository productRepository;\n\n    public ProductService(ProductRepository productRepository) {\n        this.productRepository = productRepository;\n    }\n\n    public List&lt;Product&gt; findAllProducts() {\n        return productRepository.findAll();\n    }\n\n    public Optional&lt;Product&gt; findProductById(String id) {\n        return productRepository.findById(id);\n    }\n\n    public Product saveProduct(Product product) {\n        return productRepository.save(product);\n    }\n\n    public void deleteProduct(String id) {\n        productRepository.deleteById(id);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#query-methods","title":"Query Methods","text":"<p>Spring Data MongoDB can automatically generate query implementations based on method names.</p>"},{"location":"spring-boot/spring-data-mongo/#method-name-syntax","title":"Method Name Syntax","text":"<pre><code>public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {\n    // Simple property conditions\n    List&lt;Product&gt; findByName(String name);\n    List&lt;Product&gt; findByNameAndPrice(String name, BigDecimal price);\n    List&lt;Product&gt; findByNameOrDescription(String name, String description);\n\n    // Comparisons\n    List&lt;Product&gt; findByPriceGreaterThan(BigDecimal price);\n    List&lt;Product&gt; findByPriceLessThanEqual(BigDecimal price);\n    List&lt;Product&gt; findByPriceBetween(BigDecimal min, BigDecimal max);\n\n    // String operations\n    List&lt;Product&gt; findByNameContaining(String namePart);\n    List&lt;Product&gt; findByNameStartingWith(String prefix);\n    List&lt;Product&gt; findByNameEndingWith(String suffix);\n    List&lt;Product&gt; findByNameIgnoreCase(String name);\n\n    // Collection operations\n    List&lt;Product&gt; findByTagsIn(List&lt;String&gt; tags);\n\n    // Null handling\n    List&lt;Product&gt; findByDescriptionIsNull();\n    List&lt;Product&gt; findByDescriptionIsNotNull();\n\n    // Limiting results\n    Product findFirstByOrderByCreatedAtDesc();\n    List&lt;Product&gt; findTop5ByOrderByPriceDesc();\n\n    // Nested properties\n    List&lt;Product&gt; findByShippingAddressCity(String city);\n\n    // Boolean checks\n    List&lt;Product&gt; findByInStockTrue();\n    List&lt;Product&gt; findByInStockFalse();\n\n    // Existence queries\n    boolean existsByName(String name);\n\n    // Count queries\n    long countByCategoryId(String categoryId);\n\n    // Delete queries\n    void deleteByName(String name);\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#custom-queries","title":"Custom Queries","text":"<p>For more complex queries, use the <code>@Query</code> annotation with MongoDB Query Language.</p>"},{"location":"spring-boot/spring-data-mongo/#basic-mongodb-queries","title":"Basic MongoDB Queries","text":"<pre><code>public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {\n\n    @Query(\"{ 'price': { $gt: ?0 }, 'category.name': ?1 }\")\n    List&lt;Product&gt; findExpensiveProductsByCategory(BigDecimal price, String categoryName);\n\n    @Query(\"{ 'name': { $regex: ?0, $options: 'i' } }\")\n    List&lt;Product&gt; searchByName(String keyword);\n\n    @Query(\"{ 'tags': { $in: [ ?0 ] } }\")\n    List&lt;Product&gt; findByTagName(String tagName);\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#using-field-projection","title":"Using Field Projection","text":"<p>Return only specific fields:</p> <pre><code>public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {\n\n    @Query(value = \"{ 'category.id': ?0 }\", fields = \"{ 'name': 1, 'price': 1 }\")\n    List&lt;Product&gt; findProductSummaryByCategory(String categoryId);\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#using-sort-and-limit","title":"Using Sort and Limit","text":"<pre><code>public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {\n\n    @Query(value = \"{ 'inStock': true }\", sort = \"{ 'price': -1 }\")\n    List&lt;Product&gt; findInStockProductsSortedByPriceDesc();\n\n    @Query(value = \"{ 'price': { $gt: ?0 } }\", sort = \"{ 'createdAt': -1 }\")\n    List&lt;Product&gt; findExpensiveProductsOrderByCreatedDesc(BigDecimal minPrice, Pageable pageable);\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#mongodb-template","title":"MongoDB Template","text":"<p>MongoTemplate provides direct access to MongoDB operations for cases where repositories are not sufficient.</p>"},{"location":"spring-boot/spring-data-mongo/#basic-mongotemplate-usage","title":"Basic MongoTemplate Usage","text":"<pre><code>@Service\npublic class ProductService {\n\n    private final MongoTemplate mongoTemplate;\n\n    public ProductService(MongoTemplate mongoTemplate) {\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    public Product findById(String id) {\n        return mongoTemplate.findById(id, Product.class);\n    }\n\n    public List&lt;Product&gt; findAll() {\n        return mongoTemplate.findAll(Product.class);\n    }\n\n    public Product save(Product product) {\n        return mongoTemplate.save(product);\n    }\n\n    public void delete(Product product) {\n        mongoTemplate.remove(product);\n    }\n\n    public List&lt;Product&gt; findByNameStartsWith(String prefix) {\n        Query query = new Query(Criteria.where(\"name\").regex(\"^\" + prefix));\n        return mongoTemplate.find(query, Product.class);\n    }\n\n    public List&lt;Product&gt; findExpensiveProducts(BigDecimal minPrice) {\n        Query query = new Query(Criteria.where(\"price\").gt(minPrice))\n                .with(Sort.by(Sort.Direction.DESC, \"price\"));\n        return mongoTemplate.find(query, Product.class);\n    }\n\n    public void updateProductStock(String id, boolean inStock) {\n        Query query = new Query(Criteria.where(\"id\").is(id));\n        Update update = new Update().set(\"inStock\", inStock);\n        mongoTemplate.updateFirst(query, update, Product.class);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#complex-queries-with-criteria","title":"Complex Queries with Criteria","text":"<pre><code>@Service\npublic class ProductSearchService {\n\n    private final MongoTemplate mongoTemplate;\n\n    public ProductSearchService(MongoTemplate mongoTemplate) {\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    public List&lt;Product&gt; searchProducts(\n            String nameKeyword, \n            List&lt;String&gt; categories,\n            BigDecimal minPrice,\n            BigDecimal maxPrice,\n            Boolean inStock) {\n\n        Criteria criteria = new Criteria();\n\n        // Add conditions based on provided parameters\n        if (nameKeyword != null &amp;&amp; !nameKeyword.isEmpty()) {\n            criteria.and(\"name\").regex(nameKeyword, \"i\");\n        }\n\n        if (categories != null &amp;&amp; !categories.isEmpty()) {\n            criteria.and(\"category.id\").in(categories);\n        }\n\n        if (minPrice != null) {\n            criteria.and(\"price\").gte(minPrice);\n        }\n\n        if (maxPrice != null) {\n            criteria.and(\"price\").lte(maxPrice);\n        }\n\n        if (inStock != null) {\n            criteria.and(\"inStock\").is(inStock);\n        }\n\n        Query query = new Query(criteria);\n\n        // Add sorting\n        query.with(Sort.by(Sort.Direction.ASC, \"name\"));\n\n        return mongoTemplate.find(query, Product.class);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#aggregation-framework","title":"Aggregation Framework","text":"<p>Spring Data MongoDB provides a fluent API for MongoDB's powerful aggregation framework.</p>"},{"location":"spring-boot/spring-data-mongo/#basic-aggregation","title":"Basic Aggregation","text":"<pre><code>@Service\npublic class SalesAnalyticsService {\n\n    private final MongoTemplate mongoTemplate;\n\n    public SalesAnalyticsService(MongoTemplate mongoTemplate) {\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    public List&lt;CategorySales&gt; getCategorySales() {\n        TypedAggregation&lt;Order&gt; aggregation = Aggregation.newAggregation(\n                Order.class,\n                Aggregation.unwind(\"items\"),\n                Aggregation.group(\"items.category\")\n                        .sum(\"items.quantity\").as(\"totalQuantity\")\n                        .sum(Aggregation.multiply(\"items.price\", \"items.quantity\")).as(\"totalSales\"),\n                Aggregation.project()\n                        .and(\"_id\").as(\"category\")\n                        .and(\"totalQuantity\").as(\"quantity\")\n                        .and(\"totalSales\").as(\"sales\"),\n                Aggregation.sort(Sort.Direction.DESC, \"sales\")\n        );\n\n        AggregationResults&lt;CategorySales&gt; results = mongoTemplate.aggregate(\n                aggregation, CategorySales.class);\n\n        return results.getMappedResults();\n    }\n\n    public static class CategorySales {\n        private String category;\n        private int quantity;\n        private BigDecimal sales;\n\n        // Getters and setters\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#advanced-aggregation","title":"Advanced Aggregation","text":"<pre><code>@Service\npublic class CustomerInsightsService {\n\n    private final MongoTemplate mongoTemplate;\n\n    public CustomerInsightsService(MongoTemplate mongoTemplate) {\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    public List&lt;CustomerSpending&gt; getTopCustomers(int limit) {\n        TypedAggregation&lt;Order&gt; aggregation = Aggregation.newAggregation(\n                Order.class,\n                Aggregation.match(Criteria.where(\"status\").is(\"DELIVERED\")),\n                Aggregation.group(\"customer\")\n                        .count().as(\"orderCount\")\n                        .sum(\"totalAmount\").as(\"totalSpent\")\n                        .max(\"orderDate\").as(\"lastOrderDate\"),\n                Aggregation.lookup(\"customers\", \"_id\", \"_id\", \"customerDetails\"),\n                Aggregation.unwind(\"customerDetails\"),\n                Aggregation.project()\n                        .and(\"customerDetails.name\").as(\"name\")\n                        .and(\"customerDetails.email\").as(\"email\")\n                        .and(\"orderCount\").as(\"orders\")\n                        .and(\"totalSpent\").as(\"spent\")\n                        .and(\"lastOrderDate\").as(\"lastOrder\"),\n                Aggregation.sort(Sort.Direction.DESC, \"spent\"),\n                Aggregation.limit(limit)\n        );\n\n        AggregationResults&lt;CustomerSpending&gt; results = mongoTemplate.aggregate(\n                aggregation, CustomerSpending.class);\n\n        return results.getMappedResults();\n    }\n\n    public static class CustomerSpending {\n        private String name;\n        private String email;\n        private int orders;\n        private BigDecimal spent;\n        private Date lastOrder;\n\n        // Getters and setters\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#indexing","title":"Indexing","text":"<p>Adding indexes to MongoDB collections improves query performance.</p>"},{"location":"spring-boot/spring-data-mongo/#indexing-with-annotations","title":"Indexing with Annotations","text":"<pre><code>@Document(collection = \"products\")\npublic class Product {\n\n    @Id\n    private String id;\n\n    @Indexed\n    private String name;\n\n    private String description;\n\n    @Indexed(direction = IndexDirection.DESCENDING)\n    private BigDecimal price;\n\n    @Indexed\n    private boolean inStock;\n\n    @Indexed(expireAfterSeconds = 86400)\n    private Date createdAt;\n\n    // Other fields, getters, setters, etc.\n}\n\n@Document(collection = \"customers\")\n@CompoundIndexes({\n    @CompoundIndex(name = \"email_city\", def = \"{'email': 1, 'shippingAddress.city': 1}\")\n})\npublic class Customer {\n\n    @Id\n    private String id;\n\n    @Indexed(unique = true)\n    private String email;\n\n    private String name;\n\n    private Address shippingAddress;\n\n    // Other fields, getters, setters, etc.\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#creating-indexes-programmatically","title":"Creating Indexes Programmatically","text":"<pre><code>@Component\npublic class MongoIndexInitializer implements ApplicationListener&lt;ApplicationReadyEvent&gt; {\n\n    private final MongoTemplate mongoTemplate;\n\n    public MongoIndexInitializer(MongoTemplate mongoTemplate) {\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    @Override\n    public void onApplicationEvent(ApplicationReadyEvent event) {\n        // Create text index\n        mongoTemplate.indexOps(Product.class)\n                .ensureIndex(new TextIndexDefinition.TextIndexDefinitionBuilder()\n                        .onField(\"name\")\n                        .onField(\"description\")\n                        .build());\n\n        // Create geospatial index\n        mongoTemplate.indexOps(\"stores\")\n                .ensureIndex(new GeospatialIndex(\"location\"));\n\n        // Create compound index\n        mongoTemplate.indexOps(Order.class)\n                .ensureIndex(new Index()\n                        .on(\"customer\", Sort.Direction.ASC)\n                        .on(\"orderDate\", Sort.Direction.DESC));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#geospatial-queries","title":"Geospatial Queries","text":"<p>MongoDB supports geospatial queries for location-based applications.</p>"},{"location":"spring-boot/spring-data-mongo/#geospatial-document","title":"Geospatial Document","text":"<pre><code>@Document(collection = \"stores\")\npublic class Store {\n\n    @Id\n    private String id;\n\n    private String name;\n\n    private String address;\n\n    @GeoSpatialIndexed(type = GeoSpatialIndexType.GEO_2DSPHERE)\n    private GeoJsonPoint location;\n\n    // Getters, setters, etc.\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#geospatial-repositories","title":"Geospatial Repositories","text":"<pre><code>public interface StoreRepository extends MongoRepository&lt;Store, String&gt; {\n\n    // Find stores near a point within a distance (in meters)\n    List&lt;Store&gt; findByLocationNear(Point location, Distance distance);\n\n    // Find stores within a circle\n    List&lt;Store&gt; findByLocationWithin(Circle circle);\n\n    // Find stores within a polygon\n    List&lt;Store&gt; findByLocationWithin(Polygon polygon);\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#geospatial-mongotemplate-queries","title":"Geospatial MongoTemplate Queries","text":"<pre><code>@Service\npublic class StoreLocatorService {\n\n    private final MongoTemplate mongoTemplate;\n\n    public StoreLocatorService(MongoTemplate mongoTemplate) {\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    public List&lt;Store&gt; findStoresNearLocation(double latitude, double longitude, double maxDistance) {\n        Point point = new Point(longitude, latitude);\n        Distance distance = new Distance(maxDistance, Metrics.KILOMETERS);\n\n        Query query = new Query(Criteria.where(\"location\").nearSphere(point).maxDistance(distance));\n        return mongoTemplate.find(query, Store.class);\n    }\n\n    public List&lt;Store&gt; findStoresWithinBox(double lowerLeftX, double lowerLeftY, \n                                         double upperRightX, double upperRightY) {\n        Box box = new Box(new Point(lowerLeftX, lowerLeftY), new Point(upperRightX, upperRightY));\n\n        Query query = new Query(Criteria.where(\"location\").within(box));\n        return mongoTemplate.find(query, Store.class);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#gridfs-for-large-files","title":"GridFS for Large Files","text":"<p>MongoDB GridFS is used for storing large files such as images, videos, and PDFs.</p>"},{"location":"spring-boot/spring-data-mongo/#gridfs-operations","title":"GridFS Operations","text":"<pre><code>@Service\npublic class FileStorageService {\n\n    private final GridFsTemplate gridFsTemplate;\n    private final GridFsOperations gridFsOperations;\n\n    public FileStorageService(GridFsTemplate gridFsTemplate, GridFsOperations gridFsOperations) {\n        this.gridFsTemplate = gridFsTemplate;\n        this.gridFsOperations = gridFsOperations;\n    }\n\n    public String storeFile(String filename, InputStream content, String contentType) {\n        DBObject metadata = new BasicDBObject();\n        metadata.put(\"contentType\", contentType);\n\n        ObjectId fileId = gridFsTemplate.store(content, filename, contentType, metadata);\n        return fileId.toString();\n    }\n\n    public GridFSFile getFile(String id) {\n        return gridFsTemplate.findOne(new Query(Criteria.where(\"_id\").is(new ObjectId(id))));\n    }\n\n    public GridFsResource getResource(String id) {\n        GridFSFile file = getFile(id);\n        if (file == null) {\n            return null;\n        }\n        return gridFsOperations.getResource(file);\n    }\n\n    public void deleteFile(String id) {\n        gridFsTemplate.delete(new Query(Criteria.where(\"_id\").is(new ObjectId(id))));\n    }\n\n    public List&lt;GridFSFile&gt; findAllFiles() {\n        return gridFsTemplate.find(new Query()).into(new ArrayList&lt;&gt;());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#using-gridfs-in-a-controller","title":"Using GridFS in a Controller","text":"<pre><code>@RestController\n@RequestMapping(\"/api/files\")\npublic class FileController {\n\n    private final FileStorageService fileStorageService;\n\n    public FileController(FileStorageService fileStorageService) {\n        this.fileStorageService = fileStorageService;\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;String&gt; uploadFile(@RequestParam(\"file\") MultipartFile file) {\n        try {\n            String fileId = fileStorageService.storeFile(\n                    file.getOriginalFilename(),\n                    file.getInputStream(),\n                    file.getContentType()\n            );\n            return ResponseEntity.ok(fileId);\n        } catch (IOException e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\n        }\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Resource&gt; downloadFile(@PathVariable String id) {\n        GridFsResource resource = fileStorageService.getResource(id);\n        if (resource == null) {\n            return ResponseEntity.notFound().build();\n        }\n\n        return ResponseEntity.ok()\n                .contentType(MediaType.parseMediaType(resource.getContentType()))\n                .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + resource.getFilename() + \"\\\"\")\n                .body(resource);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteFile(@PathVariable String id) {\n        fileStorageService.deleteFile(id);\n        return ResponseEntity.ok().build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#change-streams","title":"Change Streams","text":"<p>MongoDB change streams allow applications to watch for changes in the database.</p>"},{"location":"spring-boot/spring-data-mongo/#simple-change-stream-example","title":"Simple Change Stream Example","text":"<pre><code>@Service\npublic class ProductChangeListener {\n\n    private final MongoTemplate mongoTemplate;\n    private final Logger logger = LoggerFactory.getLogger(ProductChangeListener.class);\n\n    public ProductChangeListener(MongoTemplate mongoTemplate) {\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    @PostConstruct\n    public void startListening() {\n        Executors.newSingleThreadExecutor().submit(() -&gt; {\n            ChangeStreamOptions options = ChangeStreamOptions.builder()\n                    .returnFullDocumentOnUpdate()\n                    .build();\n\n            try (MongoCursor&lt;ChangeStreamDocument&lt;Document&gt;&gt; cursor = mongoTemplate\n                    .getCollection(\"products\")\n                    .watch()\n                    .fullDocument(FullDocument.UPDATE_LOOKUP)\n                    .iterator()) {\n\n                while (cursor.hasNext()) {\n                    ChangeStreamDocument&lt;Document&gt; next = cursor.next();\n                    Document fullDocument = next.getFullDocument();\n\n                    if (fullDocument != null) {\n                        logger.info(\"Change detected: {}\", fullDocument.toJson());\n\n                        // Process the change\n                        OperationType operationType = next.getOperationType();\n                        switch (operationType) {\n                            case INSERT:\n                                handleInsert(fullDocument);\n                                break;\n                            case UPDATE:\n                                handleUpdate(fullDocument, next.getUpdateDescription());\n                                break;\n                            case DELETE:\n                                handleDelete(next.getDocumentKey());\n                                break;\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    private void handleInsert(Document document) {\n        // Process insert\n    }\n\n    private void handleUpdate(Document document, UpdateDescription updateDescription) {\n        // Process update\n    }\n\n    private void handleDelete(BsonDocument documentKey) {\n        // Process delete\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#transactions","title":"Transactions","text":"<p>MongoDB supports multi-document transactions (from version 4.0).</p>"},{"location":"spring-boot/spring-data-mongo/#transaction-example","title":"Transaction Example","text":"<pre><code>@Service\n@RequiredArgsConstructor\npublic class OrderService {\n\n    private final MongoTemplate mongoTemplate;\n    private final MongoTransactionManager transactionManager;\n\n    public Order createOrder(OrderRequest request) {\n        TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);\n\n        return transactionTemplate.execute(status -&gt; {\n            try {\n                // Create order\n                Order order = new Order();\n                order.setCustomerId(request.getCustomerId());\n                order.setOrderDate(new Date());\n                order.setStatus(OrderStatus.PENDING);\n                order.setItems(mapOrderItems(request.getItems()));\n                order.calculateTotal();\n\n                mongoTemplate.save(order);\n\n                // Update inventory\n                for (OrderItem item : order.getItems()) {\n                    Query query = new Query(Criteria.where(\"_id\").is(item.getProductId()));\n                    Update update = new Update().inc(\"stockQuantity\", -item.getQuantity());\n                    UpdateResult result = mongoTemplate.updateFirst(query, update, \"products\");\n\n                    if (result.getModifiedCount() == 0) {\n                        throw new RuntimeException(\"Product not found or insufficient stock\");\n                    }\n                }\n\n                // Create payment record\n                Payment payment = new Payment();\n                payment.setOrderId(order.getId());\n                payment.setAmount(order.getTotal());\n                payment.setStatus(PaymentStatus.PENDING);\n\n                mongoTemplate.save(payment);\n\n                return order;\n            } catch (Exception e) {\n                status.setRollbackOnly();\n                throw e;\n            }\n        });\n    }\n\n    private List&lt;OrderItem&gt; mapOrderItems(List&lt;OrderItemRequest&gt; items) {\n        // Map order items from request\n        return items.stream()\n                .map(item -&gt; {\n                    OrderItem orderItem = new OrderItem();\n                    orderItem.setProductId(item.getProductId());\n                    orderItem.setQuantity(item.getQuantity());\n\n                    // Get product details\n                    Product product = mongoTemplate.findById(item.getProductId(), Product.class);\n                    orderItem.setProductName(product.getName());\n                    orderItem.setPrice(product.getPrice());\n\n                    return orderItem;\n                })\n                .collect(Collectors.toList());\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#testing-spring-data-mongodb","title":"Testing Spring Data MongoDB","text":"<p>Testing MongoDB repositories with embedded MongoDB.</p>"},{"location":"spring-boot/spring-data-mongo/#maven-dependencies_1","title":"Maven Dependencies","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;\n    &lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#repository-test","title":"Repository Test","text":"<pre><code>@DataMongoTest\nclass ProductRepositoryTest {\n\n    @Autowired\n    private ProductRepository productRepository;\n\n    @BeforeEach\n    void setup() {\n        productRepository.deleteAll();\n\n        // Create test data\n        Product product1 = new Product();\n        product1.setName(\"Test Product 1\");\n        product1.setPrice(new BigDecimal(\"19.99\"));\n        product1.setInStock(true);\n\n        Product product2 = new Product();\n        product2.setName(\"Test Product 2\");\n        product2.setPrice(new BigDecimal(\"29.99\"));\n        product2.setInStock(false);\n\n        productRepository.saveAll(List.of(product1, product2));\n    }\n\n    @Test\n    void findByName_ShouldReturnProduct() {\n        List&lt;Product&gt; products = productRepository.findByName(\"Test Product 1\");\n\n        assertThat(products).hasSize(1);\n        assertThat(products.get(0).getName()).isEqualTo(\"Test Product 1\");\n    }\n\n    @Test\n    void findByInStockTrue_ShouldReturnInStockProducts() {\n        List&lt;Product&gt; products = productRepository.findByInStockTrue();\n\n        assertThat(products).hasSize(1);\n        assertThat(products.get(0).isInStock()).isTrue();\n    }\n\n    @Test\n    void findByPriceGreaterThan_ShouldReturnExpensiveProducts() {\n        List&lt;Product&gt; products = productRepository.findByPriceGreaterThan(new BigDecimal(\"20.00\"));\n\n        assertThat(products).hasSize(1);\n        assertThat(products.get(0).getName()).isEqualTo(\"Test Product 2\");\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#mongotemplate-test","title":"MongoTemplate Test","text":"<pre><code>@SpringBootTest\nclass ProductServiceTest {\n\n    @Autowired\n    private MongoTemplate mongoTemplate;\n\n    @Autowired\n    private ProductService productService;\n\n    @BeforeEach\n    void setup() {\n        mongoTemplate.dropCollection(Product.class);\n\n        // Create test data\n        Product product1 = new Product();\n        product1.setName(\"Test Product 1\");\n        product1.setPrice(new BigDecimal(\"19.99\"));\n        product1.setInStock(true);\n\n        Product product2 = new Product();\n        product2.setName(\"Test Product 2\");\n        product2.setPrice(new BigDecimal(\"29.99\"));\n        product2.setInStock(false);\n\n        mongoTemplate.insertAll(List.of(product1, product2));\n    }\n\n    @Test\n    void searchProducts_ShouldReturnMatchingProducts() {\n        List&lt;Product&gt; products = productService.searchProducts(\n                \"Test\", null, new BigDecimal(\"25.00\"), null, null);\n\n        assertThat(products).hasSize(1);\n        assertThat(products.get(0).getName()).isEqualTo(\"Test Product 2\");\n    }\n\n    @Test\n    void updateProductStock_ShouldChangeStockStatus() {\n        Product product = mongoTemplate.findOne(\n                Query.query(Criteria.where(\"name\").is(\"Test Product 1\")), \n                Product.class);\n\n        productService.updateProductStock(product.getId(), false);\n\n        Product updatedProduct = mongoTemplate.findById(product.getId(), Product.class);\n        assertThat(updatedProduct.isInStock()).isFalse();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-data-mongo/#test-with-testcontainers","title":"Test with TestContainers","text":"<p>For testing with a real MongoDB instance:</p> <pre><code>@SpringBootTest\n@Testcontainers\nclass ProductServiceIntegrationTest {\n\n    @Container\n    static MongoDBContainer mongoDBContainer = new MongoDBContainer(\"mongo:4.4.6\");\n\n    @DynamicPropertySource\n    static void setProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.data.mongodb.uri\", mongoDBContainer::getReplicaSetUrl);\n    }\n\n    @Autowired\n    private MongoTemplate mongoTemplate;\n\n    @Autowired\n    private ProductService productService;\n\n    // Test methods\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/","title":"Spring Boot 3 Kafka Integration","text":""},{"location":"spring-boot/spring-kafka-integration/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Kafka Core Concepts</li> <li>Setup and Dependencies</li> <li>Kafka Configuration in Spring Boot</li> <li>Creating a Producer</li> <li>Creating a Consumer</li> <li>Topic Configuration</li> <li>Message Serialization/Deserialization</li> <li>Error Handling</li> <li>Transaction Support</li> <li>Testing Kafka Components</li> <li>Monitoring and Metrics</li> <li>Real-World Example</li> <li>Best Practices</li> <li>References</li> </ul>"},{"location":"spring-boot/spring-kafka-integration/#introduction","title":"Introduction","text":"<p>Apache Kafka is a distributed streaming platform that enables building real-time data pipelines and streaming applications. Spring Boot provides excellent integration with Kafka through the <code>spring-kafka</code> library, making it easy to configure producers, consumers, and other Kafka-related components.</p> <p>This guide focuses on Spring Boot 3.x integration with Kafka, covering the basics to advanced features with practical examples.</p>"},{"location":"spring-boot/spring-kafka-integration/#kafka-core-concepts","title":"Kafka Core Concepts","text":"<p>Before diving into Spring Boot integration, let's understand the core concepts of Apache Kafka:</p>"},{"location":"spring-boot/spring-kafka-integration/#topics-and-partitions","title":"Topics and Partitions","text":"<ul> <li>Topic: A named stream of records. Similar to a table in a database but without constraints.</li> <li>Partition: Each topic is divided into partitions. Partitions allow Kafka to scale horizontally and provide parallelism.</li> <li>Partition Ordering: Messages within a partition are ordered, but there's no guarantee of ordering across partitions.</li> <li>Partition Key: Determines which partition a message goes to. Messages with the same key always go to the same partition.</li> </ul> <pre><code>                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502   Topic A   \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u25bc             \u25bc             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Partition 0 \u2502 \u2502 Partition 1 \u2502 \u2502 Partition 2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#producers-and-consumers","title":"Producers and Consumers","text":"<ul> <li>Producer: Application that publishes records to Kafka topics.</li> <li>Consumer: Application that subscribes to topics and processes the records.</li> <li>Publish-Subscribe Pattern: Multiple consumers can read from the same topic.</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Producer  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   Topic     \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Consumer  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u2502             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Consumer  \u2502\n                                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#brokers-and-clusters","title":"Brokers and Clusters","text":"<ul> <li>Broker: A single Kafka server that stores data and serves client requests.</li> <li>Cluster: Multiple brokers working together for scalability and fault tolerance.</li> <li>Controller: One broker in the cluster acts as the controller, responsible for administrative operations.</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Kafka Cluster               \u2502\n\u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Broker 0\u2502   \u2502 Broker 1\u2502   \u2502 Broker 2\u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#consumer-groups","title":"Consumer Groups","text":"<ul> <li>Consumer Group: A set of consumers that cooperate to consume a set of topics.</li> <li>Load Balancing: Each partition is consumed by only one consumer within a group.</li> <li>Scalability: Adding more consumers to a group allows processing more partitions in parallel.</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        Consumer Group A           \u2502\n\u2502                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502Consumer 1\u2502  \u2502Consumer 2\u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502            \u2502\n        \u25bc            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Partition 0  \u2502 \u2502 Partition 1  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#offset-management","title":"Offset Management","text":"<ul> <li>Offset: A sequential ID given to messages in a partition.</li> <li>Consumer Offset: The position of a consumer in a partition.</li> <li>Commit Offset: Consumers periodically commit their position to resume from where they left off.</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Partition                  \u2502\n\u2502                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502  0  \u2502 \u2502  1  \u2502 \u2502  2  \u2502 \u2502  3  \u2502 \u2502  4  \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u25b2\n                      \u2502\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                \u2502Consumer   \u2502\n                \u2502Offset: 2  \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#message-delivery-semantics","title":"Message Delivery Semantics","text":"<ul> <li>At Most Once: Messages may be lost but never redelivered.</li> <li>At Least Once: Messages are never lost but may be redelivered.</li> <li>Exactly Once: Each message is delivered exactly once (achieved with transactions).</li> </ul>"},{"location":"spring-boot/spring-kafka-integration/#replication-and-fault-tolerance","title":"Replication and Fault Tolerance","text":"<ul> <li>Replication Factor: Number of copies of data across the cluster.</li> <li>Leader: Each partition has one leader broker handling all reads and writes.</li> <li>Follower: Replicas that replicate data from the leader.</li> <li>In-Sync Replica (ISR): Followers that are up-to-date with the leader.</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Topic Partition                   \u2502\n\u2502                                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502 Leader  \u2502   \u2502Follower \u2502   \u2502Follower \u2502           \u2502\n\u2502  \u2502(Broker 0)\u2502\u2500\u2500\u25b6\u2502(Broker 1)\u2502\u2500\u2500\u25b6\u2502(Broker 2)\u2502           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#log-compaction","title":"Log Compaction","text":"<ul> <li>Log Compaction: Ensures Kafka retains at least the last known value for each key.</li> <li>Compacted Topics: Special topics that maintain a clean, compacted version of the data.</li> <li>Use Case: Perfect for event sourcing and maintaining the latest state.</li> </ul> <p>These core concepts form the foundation of Kafka's architecture. Understanding them is crucial before diving into Spring Boot's integration with Kafka.</p>"},{"location":"spring-boot/spring-kafka-integration/#setup-and-dependencies","title":"Setup and Dependencies","text":"<p>To use Kafka with Spring Boot 3, add the following dependencies to your <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For Gradle (<code>build.gradle</code>):</p> <pre><code>implementation 'org.springframework.kafka:spring-kafka'\n</code></pre> <p>For testing:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#kafka-configuration-in-spring-boot","title":"Kafka Configuration in Spring Boot","text":"<p>Configure Kafka in your <code>application.yml</code> or <code>application.properties</code>:</p> <pre><code>spring:\n  kafka:\n    bootstrap-servers: localhost:9092\n    producer:\n      key-serializer: org.apache.kafka.common.serialization.StringSerializer\n      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer\n      properties:\n        spring.json.add.type.headers: false\n    consumer:\n      group-id: my-group-id\n      auto-offset-reset: earliest\n      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer\n      properties:\n        spring.json.trusted.packages: com.example.model\n    admin:\n      auto-create: true  # Automatically create topics\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#creating-a-producer","title":"Creating a Producer","text":"<p>A simple producer using Spring Kafka's <code>KafkaTemplate</code>:</p> <pre><code>@Service\npublic class OrderProducer {\n    private static final Logger logger = LoggerFactory.getLogger(OrderProducer.class);\n    private final KafkaTemplate&lt;String, Order&gt; kafkaTemplate;\n    private final String topicName = \"orders\";\n\n    public OrderProducer(KafkaTemplate&lt;String, Order&gt; kafkaTemplate) {\n        this.kafkaTemplate = kafkaTemplate;\n    }\n\n    public void sendOrder(Order order) {\n        kafkaTemplate.send(topicName, order.getId().toString(), order)\n            .addCallback(\n                result -&gt; logger.info(\"Order sent successfully: {}\", order.getId()),\n                ex -&gt; logger.error(\"Failed to send order: {}\", ex.getMessage())\n            );\n    }\n\n    // Using CompletableFuture approach\n    public CompletableFuture&lt;SendResult&lt;String, Order&gt;&gt; sendOrderAsync(Order order) {\n        return kafkaTemplate.send(topicName, order.getId().toString(), order)\n            .completable()\n            .whenComplete((result, ex) -&gt; {\n                if (ex == null) {\n                    logger.info(\"Order sent successfully: {} with offset: {}\", \n                        order.getId(), result.getRecordMetadata().offset());\n                } else {\n                    logger.error(\"Failed to send order: {}\", ex.getMessage());\n                }\n            });\n    }\n}\n</code></pre> <p>The <code>Order</code> class:</p> <pre><code>public class Order {\n    private Long id;\n    private String customerName;\n    private BigDecimal amount;\n    private LocalDateTime orderDate;\n\n    // Constructors, getters, setters\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#creating-a-consumer","title":"Creating a Consumer","text":"<p>A consumer using the <code>@KafkaListener</code> annotation:</p> <pre><code>@Service\npublic class OrderConsumer {\n    private static final Logger logger = LoggerFactory.getLogger(OrderConsumer.class);\n\n    @KafkaListener(topics = \"orders\", groupId = \"order-processing-group\")\n    public void listen(Order order, @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,\n                      @Header(KafkaHeaders.RECEIVED_TIMESTAMP) long timestamp) {\n        logger.info(\"Received order: {}, from partition: {}, timestamp: {}\", \n            order.getId(), partition, timestamp);\n\n        // Process the order\n        processOrder(order);\n    }\n\n    private void processOrder(Order order) {\n        // Business logic for processing order\n        logger.info(\"Processing order: {}, amount: {}\", order.getId(), order.getAmount());\n    }\n}\n</code></pre> <p>Configure the consumer factory:</p> <pre><code>@Configuration\npublic class KafkaConsumerConfig {\n\n    @Bean\n    public ConsumerFactory&lt;String, Order&gt; consumerFactory(KafkaProperties kafkaProperties) {\n        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(kafkaProperties.buildConsumerProperties());\n\n        return new DefaultKafkaConsumerFactory&lt;&gt;(props, \n            new StringDeserializer(),\n            new JsonDeserializer&lt;&gt;(Order.class));\n    }\n\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; kafkaListenerContainerFactory(\n            ConsumerFactory&lt;String, Order&gt; consumerFactory) {\n        ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; factory = \n            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();\n        factory.setConsumerFactory(consumerFactory);\n        return factory;\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#topic-configuration","title":"Topic Configuration","text":"<p>Configuration to automatically create topics:</p> <pre><code>@Configuration\npublic class KafkaTopicConfig {\n\n    @Bean\n    public NewTopic ordersTopic() {\n        // Create a topic with 3 partitions and replication factor of 1\n        return TopicBuilder.name(\"orders\")\n                .partitions(3)\n                .replicas(1)\n                .configs(Map.of(\n                    \"retention.ms\", \"604800000\", // 1 week\n                    \"segment.bytes\", \"1073741824\" // 1 GB\n                ))\n                .build();\n    }\n\n    @Bean\n    public NewTopic notificationsTopic() {\n        return TopicBuilder.name(\"notifications\")\n                .partitions(2)\n                .replicas(1)\n                .build();\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#message-serializationdeserialization","title":"Message Serialization/Deserialization","text":"<p>Using custom serializers and deserializers:</p> <pre><code>public class OrderSerializer implements Serializer&lt;Order&gt; {\n    private final ObjectMapper objectMapper = new ObjectMapper()\n        .registerModule(new JavaTimeModule())\n        .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n\n    @Override\n    public byte[] serialize(String topic, Order data) {\n        try {\n            return objectMapper.writeValueAsBytes(data);\n        } catch (Exception e) {\n            throw new SerializationException(\"Error serializing Order\", e);\n        }\n    }\n}\n\npublic class OrderDeserializer implements Deserializer&lt;Order&gt; {\n    private final ObjectMapper objectMapper = new ObjectMapper()\n        .registerModule(new JavaTimeModule())\n        .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n\n    @Override\n    public Order deserialize(String topic, byte[] data) {\n        try {\n            return objectMapper.readValue(data, Order.class);\n        } catch (Exception e) {\n            throw new SerializationException(\"Error deserializing Order\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#error-handling","title":"Error Handling","text":"<p>Error handling with a custom error handler:</p> <pre><code>@Configuration\npublic class KafkaErrorHandlingConfig {\n\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; kafkaListenerContainerFactory(\n            ConsumerFactory&lt;String, Order&gt; consumerFactory) {\n        ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; factory = \n            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();\n        factory.setConsumerFactory(consumerFactory);\n        factory.setErrorHandler(new SeekToCurrentErrorHandler(\n            new DeadLetterPublishingRecoverer(kafkaTemplate), \n            new FixedBackOff(1000L, 3) // Retry 3 times with 1 second delay\n        ));\n        return factory;\n    }\n\n    // For Spring Boot 3\n    @Bean\n    public DefaultErrorHandler errorHandler(KafkaTemplate&lt;String, Object&gt; template) {\n        DeadLetterPublishingRecoverer recoverer = new DeadLetterPublishingRecoverer(template,\n            (record, exception) -&gt; new TopicPartition(\"orders-failed\", record.partition()));\n\n        DefaultErrorHandler errorHandler = new DefaultErrorHandler(\n            recoverer, \n            new FixedBackOff(1000L, 3));\n\n        // Exception to be retried - customize based on your needs\n        errorHandler.addRetryableExceptions(RecoverableDataAccessException.class);\n\n        // Exception NOT to be retried\n        errorHandler.addNotRetryableExceptions(NullPointerException.class);\n\n        return errorHandler;\n    }\n}\n</code></pre> <p>For a listener:</p> <pre><code>@KafkaListener(topics = \"orders\", groupId = \"order-processing-group\")\npublic void listen(Order order, Acknowledgment acknowledgment) {\n    try {\n        // Process the order\n        processOrder(order);\n        acknowledgment.acknowledge();\n    } catch (Exception e) {\n        // Custom error handling logic\n        logger.error(\"Error processing order: {}\", e.getMessage());\n        // Depending on the error, you might want to:\n        // 1. Acknowledge and move on\n        // 2. Not acknowledge and let it be retried\n        // 3. Publish to a dead-letter topic\n        throw e; // Let the error handler defined earlier handle it\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#transaction-support","title":"Transaction Support","text":"<p>Enabling transactions in Spring Kafka:</p> <pre><code>@Configuration\npublic class KafkaTransactionConfig {\n\n    @Bean\n    public ProducerFactory&lt;String, Order&gt; producerFactory(KafkaProperties kafkaProperties) {\n        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(kafkaProperties.buildProducerProperties());\n\n        // Enable idempotence for exactly-once semantics\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        // Set transaction ID prefix\n        props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, \"tx-\");\n\n        return new DefaultKafkaProducerFactory&lt;&gt;(props);\n    }\n\n    @Bean\n    public KafkaTemplate&lt;String, Order&gt; kafkaTemplate(ProducerFactory&lt;String, Order&gt; producerFactory) {\n        KafkaTemplate&lt;String, Order&gt; template = new KafkaTemplate&lt;&gt;(producerFactory);\n        // Enable transactions for the template\n        template.setDefaultTopic(\"orders\");\n        return template;\n    }\n\n    @Bean\n    public KafkaTransactionManager&lt;String, Order&gt; kafkaTransactionManager(\n            ProducerFactory&lt;String, Order&gt; producerFactory) {\n        return new KafkaTransactionManager&lt;&gt;(producerFactory);\n    }\n}\n</code></pre> <p>Using transactions in a service:</p> <pre><code>@Service\n@Transactional(\"kafkaTransactionManager\")\npublic class TransactionalOrderService {\n    private final KafkaTemplate&lt;String, Order&gt; kafkaTemplate;\n    private final OrderRepository orderRepository;\n\n    public TransactionalOrderService(KafkaTemplate&lt;String, Order&gt; kafkaTemplate, \n                                   OrderRepository orderRepository) {\n        this.kafkaTemplate = kafkaTemplate;\n        this.orderRepository = orderRepository;\n    }\n\n    public void createOrderWithNotification(Order order) {\n        // Save to database\n        orderRepository.save(order);\n\n        // Send to Kafka - this will be in the same transaction\n        kafkaTemplate.send(\"orders\", order.getId().toString(), order);\n\n        // If an exception is thrown here, both the database save and Kafka send will be rolled back\n        ProcessNotification notification = new ProcessNotification(order.getId(), \"Order created\");\n        kafkaTemplate.send(\"notifications\", order.getId().toString(), notification);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#testing-kafka-components","title":"Testing Kafka Components","text":"<p>Testing with <code>EmbeddedKafka</code>:</p> <pre><code>@SpringBootTest\n@EmbeddedKafka(partitions = 1, topics = {\"orders\", \"notifications\"})\nclass OrderServiceIntegrationTest {\n\n    @Autowired\n    private OrderProducer producer;\n\n    @Autowired\n    private Consumer&lt;String, Order&gt; consumer;\n\n    @Autowired\n    private KafkaTemplate&lt;String, Order&gt; kafkaTemplate;\n\n    @Value(\"${spring.kafka.bootstrap-servers}\")\n    private String bootstrapServers;\n\n    @BeforeEach\n    void setUp() {\n        consumer.subscribe(Collections.singletonList(\"orders\"));\n    }\n\n    @Test\n    void testOrderProducer() throws Exception {\n        // Create an order\n        Order order = new Order(1L, \"Customer 1\", BigDecimal.valueOf(99.99), LocalDateTime.now());\n\n        // Send the order\n        producer.sendOrder(order);\n\n        // Verify the order was sent to Kafka\n        ConsumerRecords&lt;String, Order&gt; records = KafkaTestUtils.getRecords(consumer, Duration.ofSeconds(5));\n        assertThat(records.count()).isEqualTo(1);\n\n        ConsumerRecord&lt;String, Order&gt; record = records.iterator().next();\n        assertThat(record.key()).isEqualTo(\"1\");\n        assertThat(record.value().getId()).isEqualTo(1L);\n        assertThat(record.value().getCustomerName()).isEqualTo(\"Customer 1\");\n    }\n}\n</code></pre> <p>Mock testing:</p> <pre><code>@ExtendWith(MockitoExtension.class)\nclass OrderProducerUnitTest {\n\n    @Mock\n    private KafkaTemplate&lt;String, Order&gt; kafkaTemplate;\n\n    @Mock\n    private ListenableFuture&lt;SendResult&lt;String, Order&gt;&gt; future;\n\n    @InjectMocks\n    private OrderProducer producer;\n\n    @Test\n    void testSendOrderSuccess() {\n        // Create an order\n        Order order = new Order(1L, \"Customer 1\", BigDecimal.valueOf(99.99), LocalDateTime.now());\n\n        // Mock success response\n        when(kafkaTemplate.send(anyString(), anyString(), any(Order.class))).thenReturn(future);\n        doAnswer(invocation -&gt; {\n            ListenableFutureCallback&lt;SendResult&lt;String, Order&gt;&gt; callback = invocation.getArgument(0);\n            callback.onSuccess(mock(SendResult.class));\n            return null;\n        }).when(future).addCallback(any(ListenableFutureCallback.class));\n\n        // Call the method\n        producer.sendOrder(order);\n\n        // Verify\n        verify(kafkaTemplate).send(\"orders\", \"1\", order);\n        verify(future).addCallback(any(ListenableFutureCallback.class));\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#monitoring-and-metrics","title":"Monitoring and Metrics","text":"<p>Spring Boot 3 automatically provides Kafka metrics when the Actuator dependency is added:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Configure Actuator in <code>application.yml</code>:</p> <pre><code>management:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,kafkametrics\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n  endpoint:\n    health:\n      show-details: always\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#real-world-example","title":"Real-World Example","text":"<p>In this example, we'll build a real-time order processing system with Kafka:</p> <pre><code>// Order data model\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Order {\n    private Long id;\n    private String customerName;\n    private BigDecimal amount;\n    private LocalDateTime orderDate;\n    private OrderStatus status;\n\n    public enum OrderStatus {\n        CREATED, PROCESSING, SHIPPED, DELIVERED, CANCELED\n    }\n}\n\n// Order Controller to create orders\n@RestController\n@RequestMapping(\"/api/orders\")\npublic class OrderController {\n    private final OrderService orderService;\n\n    public OrderController(OrderService orderService) {\n        this.orderService = orderService;\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody Order order) {\n        order.setOrderDate(LocalDateTime.now());\n        order.setStatus(OrderStatus.CREATED);\n        Order createdOrder = orderService.createOrder(order);\n        return ResponseEntity.status(HttpStatus.CREATED).body(createdOrder);\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Order&gt; getOrder(@PathVariable Long id) {\n        return orderService.getOrder(id)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n}\n\n// Order Service\n@Service\npublic class OrderService {\n    private final OrderRepository orderRepository;\n    private final OrderProducer orderProducer;\n\n    public OrderService(OrderRepository orderRepository, OrderProducer orderProducer) {\n        this.orderRepository = orderRepository;\n        this.orderProducer = orderProducer;\n    }\n\n    @Transactional\n    public Order createOrder(Order order) {\n        // Save to database\n        Order savedOrder = orderRepository.save(order);\n\n        // Send to Kafka\n        orderProducer.sendOrder(savedOrder);\n\n        return savedOrder;\n    }\n\n    public Optional&lt;Order&gt; getOrder(Long id) {\n        return orderRepository.findById(id);\n    }\n}\n\n// Order Producer\n@Service\npublic class OrderProducer {\n    private static final Logger logger = LoggerFactory.getLogger(OrderProducer.class);\n    private final KafkaTemplate&lt;String, Order&gt; kafkaTemplate;\n    private final String orderTopic;\n\n    public OrderProducer(KafkaTemplate&lt;String, Order&gt; kafkaTemplate, \n                       @Value(\"${app.kafka.topics.orders}\") String orderTopic) {\n        this.kafkaTemplate = kafkaTemplate;\n        this.orderTopic = orderTopic;\n    }\n\n    public void sendOrder(Order order) {\n        logger.info(\"Sending order to Kafka: {}\", order.getId());\n        kafkaTemplate.send(orderTopic, order.getId().toString(), order)\n            .addCallback(\n                result -&gt; logger.info(\"Order sent successfully: {}, offset: {}\", \n                    order.getId(), result.getRecordMetadata().offset()),\n                ex -&gt; logger.error(\"Failed to send order: {}\", ex.getMessage())\n            );\n    }\n}\n\n// Order Processing Consumer\n@Service\npublic class OrderProcessingConsumer {\n    private static final Logger logger = LoggerFactory.getLogger(OrderProcessingConsumer.class);\n    private final OrderRepository orderRepository;\n    private final KafkaTemplate&lt;String, Order&gt; kafkaTemplate;\n\n    public OrderProcessingConsumer(OrderRepository orderRepository,\n                                 KafkaTemplate&lt;String, Order&gt; kafkaTemplate) {\n        this.orderRepository = orderRepository;\n        this.kafkaTemplate = kafkaTemplate;\n    }\n\n    @KafkaListener(topics = \"${app.kafka.topics.orders}\", groupId = \"${app.kafka.group-id.order-processing}\")\n    public void processOrder(Order order, Acknowledgment acknowledgment) {\n        logger.info(\"Processing order: {}\", order.getId());\n\n        try {\n            // Update order status\n            order.setStatus(OrderStatus.PROCESSING);\n            orderRepository.save(order);\n\n            // Business logic for processing order\n            processOrderBusiness(order);\n\n            // Update order status to SHIPPED\n            order.setStatus(OrderStatus.SHIPPED);\n            orderRepository.save(order);\n\n            // Send to shipping topic\n            kafkaTemplate.send(\"order-shipped\", order.getId().toString(), order);\n\n            // Acknowledge the message\n            acknowledgment.acknowledge();\n\n            logger.info(\"Order processed successfully: {}\", order.getId());\n        } catch (Exception e) {\n            logger.error(\"Error processing order: {}, reason: {}\", order.getId(), e.getMessage());\n            // Don't acknowledge - will be retried based on retry policy\n            throw e; \n        }\n    }\n\n    private void processOrderBusiness(Order order) {\n        // Simulate order processing\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n// Shipping Service Consumer\n@Service\npublic class ShippingServiceConsumer {\n    private static final Logger logger = LoggerFactory.getLogger(ShippingServiceConsumer.class);\n    private final OrderRepository orderRepository;\n    private final KafkaTemplate&lt;String, Order&gt; kafkaTemplate;\n\n    public ShippingServiceConsumer(OrderRepository orderRepository,\n                                KafkaTemplate&lt;String, Order&gt; kafkaTemplate) {\n        this.orderRepository = orderRepository;\n        this.kafkaTemplate = kafkaTemplate;\n    }\n\n    @KafkaListener(topics = \"order-shipped\", groupId = \"shipping-service\")\n    public void shipOrder(Order order) {\n        logger.info(\"Shipping order: {}\", order.getId());\n\n        // Simulate shipping process\n        try {\n            Thread.sleep(2000);\n\n            // Update order status to DELIVERED\n            order.setStatus(OrderStatus.DELIVERED);\n            orderRepository.save(order);\n\n            // Send to completion topic\n            kafkaTemplate.send(\"order-delivered\", order.getId().toString(), order);\n\n            logger.info(\"Order shipped successfully: {}\", order.getId());\n        } catch (Exception e) {\n            logger.error(\"Error shipping order: {}, reason: {}\", order.getId(), e.getMessage());\n            throw new RuntimeException(\"Shipping failed\", e);\n        }\n    }\n}\n\n// Application.yml configuration\n```yaml\nspring:\n  kafka:\n    bootstrap-servers: localhost:9092\n    producer:\n      key-serializer: org.apache.kafka.common.serialization.StringSerializer\n      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer\n      properties:\n        spring.json.add.type.headers: false\n    consumer:\n      auto-offset-reset: earliest\n      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer\n      properties:\n        spring.json.trusted.packages: com.example.model\n      enable-auto-commit: false\n    listener:\n      ack-mode: MANUAL\n\napp:\n  kafka:\n    topics:\n      orders: orders\n      shipped: order-shipped\n      delivered: order-delivered\n    group-id:\n      order-processing: order-processing-group\n      shipping: shipping-service\n</code></pre>"},{"location":"spring-boot/spring-kafka-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Always Configure Proper Serialization/Deserialization</li> <li>Use appropriate serializers based on your message format (JSON, Avro, etc.)</li> <li> <p>Consider using schema registry for complex data structures</p> </li> <li> <p>Implement Proper Error Handling</p> </li> <li>Use dead-letter topics for failed messages</li> <li>Implement retry mechanisms with backoff policies</li> <li> <p>Log failed messages with detailed error information</p> </li> <li> <p>Use Transactions When Necessary</p> </li> <li>Enable transactions when you need atomic operations across multiple topics</li> <li> <p>Be aware of the performance implications of transactions</p> </li> <li> <p>Monitor Your Kafka Applications</p> </li> <li>Enable metrics with Spring Boot Actuator</li> <li>Set up alerting for important metrics like lag, throughput, and errors</li> <li> <p>Use distributed tracing to track message flow</p> </li> <li> <p>Test Thoroughly</p> </li> <li>Use <code>@EmbeddedKafka</code> for integration testing</li> <li>Mock Kafka components for unit testing</li> <li> <p>Test failure scenarios and recovery processes</p> </li> <li> <p>Optimize Performance</p> </li> <li>Configure batch sizes and linger time for producers</li> <li>Set appropriate concurrency for consumers</li> <li> <p>Monitor and adjust partition count based on throughput</p> </li> <li> <p>Secure Your Kafka Applications</p> </li> <li>Use SSL/TLS for encryption</li> <li>Implement authentication with SASL</li> <li> <p>Set up authorization with ACLs</p> </li> <li> <p>Consider Message Ordering</p> </li> <li>Use a single partition if strict ordering is required</li> <li> <p>Use message keys to ensure related messages go to the same partition</p> </li> <li> <p>Implement Proper Shutdown Hooks</p> </li> <li>Ensure clean shutdown of Kafka producers and consumers</li> <li> <p>Handle application lifecycle events properly</p> </li> <li> <p>Document Your Kafka Architecture</p> <ul> <li>Document topic schemas and their purposes</li> <li>Document consumer groups and their responsibilities</li> <li>Create a diagram of message flows</li> </ul> </li> </ol>"},{"location":"spring-boot/spring-kafka-integration/#references","title":"References","text":"<ul> <li>Spring for Apache Kafka</li> <li>Spring Boot Kafka Official Documentation</li> <li>Apache Kafka Documentation</li> <li>Confluent Developer </li> </ul>"}]}